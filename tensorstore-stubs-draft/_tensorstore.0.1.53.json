{
    "ChunkLayout": {
        "ast": "ClassDef(name='ChunkLayout', bases=[], keywords=[], body=[ClassDef(name='Grid', bases=[], keywords=[], body=[FunctionDef(name='aspect_ratio', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='aspect_ratio_soft_constraint', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='elements', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), FunctionDef(name='elements_soft_constraint', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), FunctionDef(name='ndim', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), FunctionDef(name='rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), FunctionDef(name='shape', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='shape_soft_constraint', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load())), arg(arg='include_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='update', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[arg(arg='rank', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='shape_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='aspect_ratio', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='aspect_ratio_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='elements', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='elements_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='grid', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()), ctx=Load())), arg(arg='grid_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), FunctionDef(name='codec_chunk', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load())), FunctionDef(name='grid_origin', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='grid_origin_soft_constraint', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='inner_order', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='inner_order_soft_constraint', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='ndim', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='read_chunk', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load())), FunctionDef(name='read_chunk_template', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='IndexDomain', ctx=Load())), FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='update', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[arg(arg='rank', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='inner_order', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='inner_order_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='grid_origin', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='grid_origin_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='chunk', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()), ctx=Load())), arg(arg='write_chunk', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()), ctx=Load())), arg(arg='read_chunk', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()), ctx=Load())), arg(arg='codec_chunk', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()), ctx=Load())), arg(arg='chunk_shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='chunk_shape_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='write_chunk_shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='write_chunk_shape_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='read_chunk_shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='read_chunk_shape_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='codec_chunk_shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='codec_chunk_shape_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='chunk_aspect_ratio', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='chunk_aspect_ratio_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='write_chunk_aspect_ratio', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='write_chunk_aspect_ratio_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='read_chunk_aspect_ratio', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='read_chunk_aspect_ratio_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='codec_chunk_aspect_ratio', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='codec_chunk_aspect_ratio_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='chunk_elements', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='chunk_elements_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='write_chunk_elements', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='write_chunk_elements_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='read_chunk_elements', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='read_chunk_elements_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='codec_chunk_elements', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='codec_chunk_elements_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='finalize', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='write_chunk', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load())), FunctionDef(name='write_chunk_template', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='IndexDomain', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "ClassDef(name='Grid', bases=[], keywords=[], body=[FunctionDef(name='aspect_ratio', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='aspect_ratio_soft_constraint', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='elements', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), FunctionDef(name='elements_soft_constraint', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), FunctionDef(name='ndim', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), FunctionDef(name='rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), FunctionDef(name='shape', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='shape_soft_constraint', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load())), arg(arg='include_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='update', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[arg(arg='rank', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='shape_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='aspect_ratio', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='aspect_ratio_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='elements', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='elements_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='grid', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()), ctx=Load())), arg(arg='grid_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None))], decorator_list=[])",
                "children": [
                    {
                        "ast": "FunctionDef(name='aspect_ratio', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load()))",
                        "definition": "@property\ndef aspect_ratio (arg0: ChunkLayout.Grid) -> Optional[Tuple[Optional[float], ...]]: ...",
                        "doc": "Chunk shape aspect ratio.",
                        "type": "property"
                    },
                    {
                        "ast": "FunctionDef(name='aspect_ratio_soft_constraint', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load()))",
                        "definition": "@property\ndef aspect_ratio_soft_constraint (arg0: ChunkLayout.Grid) -> Optional[Tuple[Optional[float], ...]]: ...",
                        "doc": "Soft constraints on chunk shape aspect ratio.",
                        "type": "property"
                    },
                    {
                        "ast": "FunctionDef(name='elements', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))",
                        "definition": "@property\ndef elements (arg0: ChunkLayout.Grid) -> Optional[int]: ...",
                        "doc": "Target number of elements per chunk.",
                        "type": "property"
                    },
                    {
                        "ast": "FunctionDef(name='elements_soft_constraint', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))",
                        "definition": "@property\ndef elements_soft_constraint (arg0: ChunkLayout.Grid) -> Optional[int]: ...",
                        "doc": "Soft constraint on target number of elements per chunk.",
                        "type": "property"
                    },
                    {
                        "ast": "FunctionDef(name='ndim', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))",
                        "definition": "@property\ndef ndim (arg0: ChunkLayout.Grid) -> Optional[int]: ...",
                        "doc": "\nAlias for :py:obj:`.rank`.\n",
                        "type": "property"
                    },
                    {
                        "ast": "FunctionDef(name='rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))",
                        "definition": "@property\ndef rank (arg0: ChunkLayout.Grid) -> Optional[int]: ...",
                        "doc": "\nNumber of dimensions, or :py:obj:`None` if unspecified.\n",
                        "type": "property"
                    },
                    {
                        "ast": "FunctionDef(name='shape', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load()))",
                        "definition": "@property\ndef shape (arg0: ChunkLayout.Grid) -> Optional[Tuple[Optional[int], ...]]: ...",
                        "doc": "Hard constraints on chunk shape.",
                        "type": "property"
                    },
                    {
                        "ast": "FunctionDef(name='shape_soft_constraint', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load()))",
                        "definition": "@property\ndef shape_soft_constraint (arg0: ChunkLayout.Grid) -> Optional[Tuple[Optional[int], ...]]: ...",
                        "doc": "Soft constraints on chunk shape.",
                        "type": "property"
                    },
                    {
                        "ast": "FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load())), arg(arg='include_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load()))",
                        "definition": "def to_json(self: ChunkLayout.Grid, include_defaults: bool = False) -> Any: ...",
                        "doc": "to_json(self: tensorstore.ChunkLayout.Grid, include_defaults: bool = False) -> Any\n\nConverts to the :json:schema:`JSON representation<ChunkLayout/Grid>`.\n",
                        "type": "function"
                    },
                    {
                        "ast": "FunctionDef(name='update', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))], kwonlyargs=[arg(arg='rank', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='shape_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='aspect_ratio', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='aspect_ratio_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='elements', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='elements_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='grid', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()), ctx=Load())), arg(arg='grid_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None))",
                        "definition": "def update(self: ChunkLayout.Grid, *, rank: Optional[int] = None, shape: Optional[Sequence[Optional[int]]] = None, shape_soft_constraint: Optional[Sequence[Optional[int]]] = None, aspect_ratio: Optional[Sequence[Optional[float]]] = None, aspect_ratio_soft_constraint: Optional[Sequence[Optional[float]]] = None, elements: Optional[int] = None, elements_soft_constraint: Optional[int] = None, grid: Optional[ChunkLayout.Grid] = None, grid_soft_constraint: Optional[ChunkLayout.Grid] = None) -> None: ...",
                        "doc": "update(self: tensorstore.ChunkLayout.Grid, *, rank: Optional[int] = None, shape: Optional[Sequence[Optional[int]]] = None, shape_soft_constraint: Optional[Sequence[Optional[int]]] = None, aspect_ratio: Optional[Sequence[Optional[float]]] = None, aspect_ratio_soft_constraint: Optional[Sequence[Optional[float]]] = None, elements: Optional[int] = None, elements_soft_constraint: Optional[int] = None, grid: Optional[tensorstore.ChunkLayout.Grid] = None, grid_soft_constraint: Optional[tensorstore.ChunkLayout.Grid] = None) -> None\n\n\nAdds additional constraints.\n\nArgs:\n  rank: Specifies the number of dimensions.\n  shape: Hard constraints on the chunk size for each dimension.  Corresponds to\n    :json:schema:`ChunkLayout/Grid.shape`.\n  shape_soft_constraint: Soft constraints on the chunk size for each dimension.  Corresponds to\n    :json:schema:`ChunkLayout/Grid.shape_soft_constraint`.\n  aspect_ratio: Aspect ratio for each dimension.  Corresponds to\n    :json:schema:`ChunkLayout/Grid.aspect_ratio`.\n  aspect_ratio_soft_constraint: Soft constraints on the aspect ratio for each dimension.  Corresponds to\n    :json:schema:`ChunkLayout/Grid.aspect_ratio_soft_constraint`.\n  elements: Target number of elements per chunk.  Corresponds to\n    :json:schema:`ChunkLayout/Grid.elements`.\n  elements_soft_constraint: Soft constraint on the target number of elements per chunk.  Corresponds to\n    :json:schema:`ChunkLayout/Grid.elements_soft_constraint`.\n  grid: Other grid constraints to merge in.  Hard and soft constraints in\n    :py:param:`.grid` are retained as hard and soft constraints, respectively.\n  grid_soft_constraint: Other grid constraints to merge in as soft constraints.\n\n",
                        "type": "function"
                    }
                ],
                "definition": "<class 'tensorstore.ChunkLayout.Grid'>",
                "doc": "\nDescribes a regular grid layout for write/read/codec chunks.\n",
                "type": "class"
            },
            {
                "ast": "FunctionDef(name='codec_chunk', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))",
                "definition": "@property\ndef codec_chunk (arg0: ChunkLayout) -> ChunkLayout.Grid: ...",
                "doc": "\nChunk grid used by the codec.\n\nSee also:\n  - JSON :json:schema:`ChunkLayout.codec_chunk` member.\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='grid_origin', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef grid_origin (arg0: ChunkLayout) -> Optional[Tuple[Optional[int], ...]]: ...",
                "doc": "\nHard constraints on the grid origin.\n\nSee also:\n  - JSON :json:schema:`ChunkLayout.grid_origin` member.\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='grid_origin_soft_constraint', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef grid_origin_soft_constraint (arg0: ChunkLayout) -> Optional[Tuple[Optional[int], ...]]: ...",
                "doc": "\nSoft constraints on the grid origin.\n\nSee also:\n  - JSON :json:schema:`ChunkLayout.grid_origin_soft_constraint` member.\n  - :py:obj:`.grid_origin`\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='inner_order', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef inner_order (arg0: ChunkLayout) -> Optional[Tuple[int, ...]]: ...",
                "doc": "\nPermutation specifying the element storage order within the innermost chunks.\n\nIf the inner order is specified as a soft constraint rather than a hard\nconstraint, :py:obj:`.inner_order` is equal to `None` and the soft constraint is\naccessed via :py:obj:`.inner_order_soft_constraint`.\n\nLexicographic order (i.e. C order/row-major order) is specified as ``[0, 1, ...,\nrank-1]``, while colexicographic order (i.e. Fortran order/column-major order)\nis specified as ``[rank-1, ..., 1, 0]``.\n\nSee also:\n  - :py:obj:`.inner_order_soft_constraint`\n  - JSON :json:schema:`ChunkLayout.inner_order` member\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='inner_order_soft_constraint', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef inner_order_soft_constraint (arg0: ChunkLayout) -> Optional[Tuple[int, ...]]: ...",
                "doc": "\nPermutation specifying soft constraint on the element storage order.\n\nIf the inner order is specified as a hard constraint rather than a soft\nconstraint, :py:obj:`.inner_order_soft_constraint` is equal to `None` and the\nhard constraint is accessed via :py:obj:`.inner_order`.\n\nSee also:\n  - :py:obj:`.inner_order`\n  - JSON :json:schema:`ChunkLayout.inner_order_soft_constraint` member\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='ndim', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef ndim (arg0: ChunkLayout) -> int: ...",
                "doc": "\nAlias for :py:obj:`.rank`.\n\nExample:\n\n    >>> layout = ts.ChunkLayout(inner_order=[0, 2, 1])\n    >>> layout.ndim\n    3\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef rank (arg0: ChunkLayout) -> int: ...",
                "doc": "\nNumber of dimensions in the index space.\n\nExample:\n\n    >>> layout = ts.ChunkLayout(inner_order=[0, 2, 1])\n    >>> layout.rank\n    3\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='read_chunk', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))",
                "definition": "@property\ndef read_chunk (arg0: ChunkLayout) -> ChunkLayout.Grid: ...",
                "doc": "\nChunk grid for efficient reads.\n\nSee also:\n  - JSON :json:schema:`ChunkLayout.read_chunk` member.\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='read_chunk_template', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='IndexDomain', ctx=Load()))",
                "definition": "@property\ndef read_chunk_template (arg0: ChunkLayout) -> IndexDomain: ...",
                "doc": "\nChunk offset and shape for efficient reads.\n\nExample:\n\n    >>> layout = ts.ChunkLayout(grid_origin=[5, 6, 7],\n    ...                         read_chunk_shape=[100, 200, 300])\n    >>> layout.read_chunk_template\n    { [5, 105), [6, 206), [7, 307) }\n\nNote:\n\n  Only the hard constraints :py:obj:`.grid_origin` and\n  :py:obj:`~ChunkLayout.Grid.shape` of :py:obj:`.read_chunk` are taken into\n  account.  The soft constraints :py:obj:`.grid_origin_soft_constraint` and all\n  other constraints specified on :py:obj:`.read_chunk` are **ignored**.\n\nFor any dimension ``i`` for which :python:`self.grid_origin[i] is None` or\n:python:`self.read_chunk_shape[i] is None`,\n:python:`self.read_chunk_template[i]` is an unbounded interval\n:python:`ts.Dim()`:\n\n    >>> layout = ts.ChunkLayout(grid_origin=[None, 6, 7],\n    ...                         read_chunk_shape=[100, None, 200])\n    >>> layout.read_chunk_template\n    { (-inf, +inf), (-inf, +inf), [7, 207) }\n\nRaises:\n\n  ValueError: If :py:obj:`.rank` is unspecified or :py:obj:`.grid_origin` and\n    :python:`self.read_chunk.shape` are incompatible.\n\nSee also:\n  - :py:meth:`ChunkLayout.write_chunk_template`\n\nGroup:\n  Chunk templates\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load()))",
                "definition": "def to_json(self: ChunkLayout) -> Any: ...",
                "doc": "to_json(self: tensorstore.ChunkLayout) -> Any\n\n\nConverts to the :json:schema:`JSON representation<ChunkLayout>`.\n\nExample:\n\n    >>> layout = ts.ChunkLayout(\n    ...     inner_order=[0, 2, 1],\n    ...     write_chunk_shape_soft_constraint=[100, None, 200],\n    ...     read_chunk_elements=1000000)\n    >>> layout.to_json()\n    {'inner_order': [0, 2, 1],\n     'read_chunk': {'elements': 1000000},\n     'write_chunk': {'shape_soft_constraint': [100, None, 200]}}\n\nGroup:\n  Accessors\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='update', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[arg(arg='rank', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='inner_order', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='inner_order_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='grid_origin', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='grid_origin_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='chunk', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()), ctx=Load())), arg(arg='write_chunk', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()), ctx=Load())), arg(arg='read_chunk', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()), ctx=Load())), arg(arg='codec_chunk', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()), ctx=Load())), arg(arg='chunk_shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='chunk_shape_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='write_chunk_shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='write_chunk_shape_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='read_chunk_shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='read_chunk_shape_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='codec_chunk_shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='codec_chunk_shape_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='chunk_aspect_ratio', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='chunk_aspect_ratio_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='write_chunk_aspect_ratio', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='write_chunk_aspect_ratio_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='read_chunk_aspect_ratio', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='read_chunk_aspect_ratio_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='codec_chunk_aspect_ratio', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='codec_chunk_aspect_ratio_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='chunk_elements', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='chunk_elements_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='write_chunk_elements', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='write_chunk_elements_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='read_chunk_elements', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='read_chunk_elements_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='codec_chunk_elements', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='codec_chunk_elements_soft_constraint', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='finalize', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None))",
                "definition": "def update(self: ChunkLayout, *, rank: Optional[int] = None, inner_order: Optional[Sequence[int]] = None, inner_order_soft_constraint: Optional[Sequence[int]] = None, grid_origin: Optional[Sequence[Optional[int]]] = None, grid_origin_soft_constraint: Optional[Sequence[Optional[int]]] = None, chunk: Optional[ChunkLayout.Grid] = None, write_chunk: Optional[ChunkLayout.Grid] = None, read_chunk: Optional[ChunkLayout.Grid] = None, codec_chunk: Optional[ChunkLayout.Grid] = None, chunk_shape: Optional[Sequence[Optional[int]]] = None, chunk_shape_soft_constraint: Optional[Sequence[Optional[int]]] = None, write_chunk_shape: Optional[Sequence[Optional[int]]] = None, write_chunk_shape_soft_constraint: Optional[Sequence[Optional[int]]] = None, read_chunk_shape: Optional[Sequence[Optional[int]]] = None, read_chunk_shape_soft_constraint: Optional[Sequence[Optional[int]]] = None, codec_chunk_shape: Optional[Sequence[Optional[int]]] = None, codec_chunk_shape_soft_constraint: Optional[Sequence[Optional[int]]] = None, chunk_aspect_ratio: Optional[Sequence[Optional[float]]] = None, chunk_aspect_ratio_soft_constraint: Optional[Sequence[Optional[float]]] = None, write_chunk_aspect_ratio: Optional[Sequence[Optional[float]]] = None, write_chunk_aspect_ratio_soft_constraint: Optional[Sequence[Optional[float]]] = None, read_chunk_aspect_ratio: Optional[Sequence[Optional[float]]] = None, read_chunk_aspect_ratio_soft_constraint: Optional[Sequence[Optional[float]]] = None, codec_chunk_aspect_ratio: Optional[Sequence[Optional[float]]] = None, codec_chunk_aspect_ratio_soft_constraint: Optional[Sequence[Optional[float]]] = None, chunk_elements: Optional[int] = None, chunk_elements_soft_constraint: Optional[int] = None, write_chunk_elements: Optional[int] = None, write_chunk_elements_soft_constraint: Optional[int] = None, read_chunk_elements: Optional[int] = None, read_chunk_elements_soft_constraint: Optional[int] = None, codec_chunk_elements: Optional[int] = None, codec_chunk_elements_soft_constraint: Optional[int] = None, finalize: Optional[bool] = None) -> None: ...",
                "doc": "update(self: tensorstore.ChunkLayout, *, rank: Optional[int] = None, inner_order: Optional[Sequence[int]] = None, inner_order_soft_constraint: Optional[Sequence[int]] = None, grid_origin: Optional[Sequence[Optional[int]]] = None, grid_origin_soft_constraint: Optional[Sequence[Optional[int]]] = None, chunk: Optional[tensorstore.ChunkLayout.Grid] = None, write_chunk: Optional[tensorstore.ChunkLayout.Grid] = None, read_chunk: Optional[tensorstore.ChunkLayout.Grid] = None, codec_chunk: Optional[tensorstore.ChunkLayout.Grid] = None, chunk_shape: Optional[Sequence[Optional[int]]] = None, chunk_shape_soft_constraint: Optional[Sequence[Optional[int]]] = None, write_chunk_shape: Optional[Sequence[Optional[int]]] = None, write_chunk_shape_soft_constraint: Optional[Sequence[Optional[int]]] = None, read_chunk_shape: Optional[Sequence[Optional[int]]] = None, read_chunk_shape_soft_constraint: Optional[Sequence[Optional[int]]] = None, codec_chunk_shape: Optional[Sequence[Optional[int]]] = None, codec_chunk_shape_soft_constraint: Optional[Sequence[Optional[int]]] = None, chunk_aspect_ratio: Optional[Sequence[Optional[float]]] = None, chunk_aspect_ratio_soft_constraint: Optional[Sequence[Optional[float]]] = None, write_chunk_aspect_ratio: Optional[Sequence[Optional[float]]] = None, write_chunk_aspect_ratio_soft_constraint: Optional[Sequence[Optional[float]]] = None, read_chunk_aspect_ratio: Optional[Sequence[Optional[float]]] = None, read_chunk_aspect_ratio_soft_constraint: Optional[Sequence[Optional[float]]] = None, codec_chunk_aspect_ratio: Optional[Sequence[Optional[float]]] = None, codec_chunk_aspect_ratio_soft_constraint: Optional[Sequence[Optional[float]]] = None, chunk_elements: Optional[int] = None, chunk_elements_soft_constraint: Optional[int] = None, write_chunk_elements: Optional[int] = None, write_chunk_elements_soft_constraint: Optional[int] = None, read_chunk_elements: Optional[int] = None, read_chunk_elements_soft_constraint: Optional[int] = None, codec_chunk_elements: Optional[int] = None, codec_chunk_elements_soft_constraint: Optional[int] = None, finalize: Optional[bool] = None) -> None\n\n\nAdds additional constraints.\n\nArgs:\n  rank: Specifies the number of dimensions.\n  inner_order: Permutation specifying the element storage order within the innermost chunks.\n    Corresponds to the JSON :json:schema:`ChunkLayout.inner_order` member.  This\n    must be a permutation of ``[0, 1, ..., rank-1]``.  Lexicographic order (i.e. C\n    order/row-major order) is specified as ``[0, 1, ..., rank-1]``, while\n    colexicographic order (i.e. Fortran order/column-major order) is specified as\n    ``[rank-1, ..., 1, 0]``.\n  inner_order_soft_constraint: Specifies a preferred value for :py:obj:`~ChunkLayout.inner_order` rather than a\n    hard constraint.  Corresponds to the JSON\n    :json:schema:`ChunkLayout.inner_order_soft_constraint` member.  If\n    :py:obj:`~ChunkLayout.inner_order` is also specified, it takes precedence.\n  grid_origin: Hard constraints on the origin of the chunk grid.\n    Corresponds to the JSON :json:schema:`ChunkLayout.grid_origin` member.\n  grid_origin_soft_constraint: Soft constraints on the origin of the chunk grid.  Corresponds to the JSON\n    :json:schema:`ChunkLayout.grid_origin_soft_constraint` member.\n  chunk: Common constraints on write, read, and codec chunks.  Corresponds to the JSON\n    :json:schema:`ChunkLayout.chunk` member.  The :py:obj:`~ChunkLayout.Grid.shape`\n    and :py:obj:`~ChunkLayout.Grid.elements` constraints apply only to write and\n    read chunks, while the :py:obj:`~ChunkLayout.Grid.aspect_ratio` constraints\n    apply to write, read, and codec chunks.\n  write_chunk: Constraints on write chunks.  Corresponds to the JSON\n    :json:schema:`ChunkLayout.write_chunk` member.\n  read_chunk: Constraints on read chunks.  Corresponds to\n    the JSON :json:schema:`ChunkLayout.read_chunk` member.\n  codec_chunk: Constraints on codec chunks.  Corresponds to\n    the JSON :json:schema:`ChunkLayout.codec_chunk` member.\n  chunk_shape: Hard constraints on both the write and read chunk shape.  Corresponds to the\n    JSON :json:schema:`~ChunkLayout/Grid.shape` member of\n    :json:schema:`ChunkLayout.chunk`.  Equivalent to specifying both\n    :py:param:`.write_chunk_shape` and :py:param:`.read_chunk_shape`.\n  chunk_shape_soft_constraint: Soft constraints on both the write and read chunk shape.  Corresponds to the\n    JSON :json:schema:`~ChunkLayout/Grid.shape_soft_constraint` member of\n    :json:schema:`ChunkLayout.chunk`.  Equivalent to specifying both\n    :py:param:`.write_chunk_shape_soft_constraint` and\n    :py:param:`.read_chunk_shape_soft_constraint`.\n  write_chunk_shape: Hard constraints on the write chunk shape.  Corresponds to the\n    JSON :json:schema:`~ChunkLayout/Grid.shape` member of\n    :json:schema:`ChunkLayout.write_chunk`.\n  write_chunk_shape_soft_constraint: Soft constraints on the write chunk shape.  Corresponds to the\n    JSON :json:schema:`~ChunkLayout/Grid.shape_soft_constraint` member of\n    :json:schema:`ChunkLayout.write_chunk`.\n  read_chunk_shape: Hard constraints on the read chunk shape.  Corresponds to the\n    JSON :json:schema:`~ChunkLayout/Grid.shape` member of\n    :json:schema:`ChunkLayout.read_chunk`.\n  read_chunk_shape_soft_constraint: Soft constraints on the read chunk shape.  Corresponds to the\n    JSON :json:schema:`~ChunkLayout/Grid.shape_soft_constraint` member of\n    :json:schema:`ChunkLayout.read_chunk`.\n  codec_chunk_shape: Soft constraints on the codec chunk shape.  Corresponds to the\n    JSON :json:schema:`~ChunkLayout/Grid.shape` member of\n    :json:schema:`ChunkLayout.codec_chunk`.\n  codec_chunk_shape_soft_constraint: Soft constraints on the codec chunk shape.  Corresponds to the\n    JSON :json:schema:`~ChunkLayout/Grid.shape_soft_constraint` member of\n    :json:schema:`ChunkLayout.codec_chunk`.\n  chunk_aspect_ratio: Hard constraints on the write, read, and codec chunk aspect ratio.  Corresponds\n    to the JSON :json:schema:`~ChunkLayout/Grid.aspect_ratio` member of\n    :json:schema:`ChunkLayout.chunk`.  Equivalent to specifying\n    :py:param:`.write_chunk_aspect_ratio`, :py:param:`.read_chunk_aspect_ratio`, and\n    :py:param:`.codec_chunk_aspect_ratio`.\n  chunk_aspect_ratio_soft_constraint: Soft constraints on the write, read, and codec chunk aspect ratio.  Corresponds\n    to the :json:schema:`~ChunkLayout/Grid.aspect_ratio_soft_constraint` member of\n    :json:schema:`ChunkLayout.chunk`.  Equivalent to specifying\n    :py:param:`.write_chunk_aspect_ratio_soft_constraint`,\n    :py:param:`.read_chunk_aspect_ratio_soft_constraint`, and\n    :py:param:`.codec_chunk_aspect_ratio_soft_constraint`.\n  write_chunk_aspect_ratio: Hard constraints on the write chunk aspect ratio.  Corresponds to the\n    JSON :json:schema:`~ChunkLayout/Grid.aspect_ratio` member of\n    :json:schema:`ChunkLayout.write_chunk`.\n  write_chunk_aspect_ratio_soft_constraint: Soft constraints on the write chunk aspect ratio.  Corresponds to the\n    JSON :json:schema:`~ChunkLayout/Grid.aspect_ratio_soft_constraint` member of\n    :json:schema:`ChunkLayout.write_chunk`.\n  read_chunk_aspect_ratio: Hard constraints on the read chunk aspect ratio.  Corresponds to the\n    JSON :json:schema:`~ChunkLayout/Grid.aspect_ratio` member of\n    :json:schema:`ChunkLayout.read_chunk`.\n  read_chunk_aspect_ratio_soft_constraint: Soft constraints on the read chunk aspect ratio.  Corresponds to the\n    JSON :json:schema:`~ChunkLayout/Grid.aspect_ratio_soft_constraint` member of\n    :json:schema:`ChunkLayout.read_chunk`.\n  codec_chunk_aspect_ratio: Soft constraints on the codec chunk aspect ratio.  Corresponds to the\n    JSON :json:schema:`~ChunkLayout/Grid.aspect_ratio` member of\n    :json:schema:`ChunkLayout.codec_chunk`.\n  codec_chunk_aspect_ratio_soft_constraint: Soft constraints on the codec chunk aspect ratio.  Corresponds to the\n    JSON :json:schema:`~ChunkLayout/Grid.aspect_ratio_soft_constraint` member of\n    :json:schema:`ChunkLayout.codec_chunk`.\n  chunk_elements: Hard constraints on the target number of elements for write and read chunks.\n    Corresponds to the JSON :json:schema:`~ChunkLayout/Grid.elements` member of\n    :json:schema:`ChunkLayout.chunk`.  Equivalent to specifying both\n    :py:param:`.write_chunk_elements` and :py:param:`.read_chunk_elements`.\n  chunk_elements_soft_constraint: Soft constraints on the target number of elements for write and read chunks.\n    Corresponds to the JSON\n    :json:schema:`~ChunkLayout/Grid.elements_soft_constraint` member of\n    :json:schema:`ChunkLayout.chunk`.  Equivalent to specifying both\n    :py:param:`.write_chunk_elements_soft_constraint` and\n    :py:param:`.read_chunk_elements_soft_constraint`.\n  write_chunk_elements: Hard constraints on the target number of elements for write chunks.  Corresponds\n    to the JSON :json:schema:`~ChunkLayout/Grid.elements` member of\n    :json:schema:`ChunkLayout.write_chunk`.\n  write_chunk_elements_soft_constraint: Soft constraints on the target number of elements for write chunks.  Corresponds\n    to the JSON :json:schema:`~ChunkLayout/Grid.elements_soft_constraint` member\n    of :json:schema:`ChunkLayout.write_chunk`.\n  read_chunk_elements: Hard constraints on the target number of elements for read chunks.  Corresponds\n    to the JSON :json:schema:`~ChunkLayout/Grid.elements` member of\n    :json:schema:`ChunkLayout.read_chunk`.\n  read_chunk_elements_soft_constraint: Soft constraints on the target number of elements for read chunks.  Corresponds\n    to the JSON :json:schema:`~ChunkLayout/Grid.elements_soft_constraint` member\n    of :json:schema:`ChunkLayout.read_chunk`.\n  codec_chunk_elements: Hard constraints on the target number of elements for codec chunks.  Corresponds\n    to the JSON :json:schema:`~ChunkLayout/Grid.elements` member of\n    :json:schema:`ChunkLayout.codec_chunk`.\n  codec_chunk_elements_soft_constraint: Soft constraints on the target number of elements for codec chunks.  Corresponds\n    to the JSON :json:schema:`~ChunkLayout/Grid.elements_soft_constraint` member\n    of :json:schema:`ChunkLayout.codec_chunk`.\n  finalize: Validates and converts the layout into a *precise* chunk\n    layout.\n    \n    - All dimensions of :py:obj:`~ChunkLayout.grid_origin` must be specified as hard\n      constraints.\n    \n    - Any write/read/codec chunk :py:obj:`~ChunkLayout.Grid.shape` soft constraints\n      are cleared.\n    \n    - Any unspecified dimensions of the read chunk shape are set from the\n      write chunk shape.\n    \n    - Any write/read/codec chunk :py:obj:`~ChunkLayout.Grid.aspect_ratio` or\n      :py:obj:`~ChunkLayout.Grid.elements` constraints are cleared.\n\n\nGroup:\n  Setters\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='write_chunk', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='ChunkLayout', ctx=Load()), attr='Grid', ctx=Load()))",
                "definition": "@property\ndef write_chunk (arg0: ChunkLayout) -> ChunkLayout.Grid: ...",
                "doc": "\nChunk grid for efficient writes.\n\nSee also:\n  - JSON :json:schema:`ChunkLayout.write_chunk` member.\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='write_chunk_template', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='ChunkLayout', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='IndexDomain', ctx=Load()))",
                "definition": "@property\ndef write_chunk_template (arg0: ChunkLayout) -> IndexDomain: ...",
                "doc": "\nChunk offset and shape for efficient writes.\n\nExample:\n\n    >>> layout = ts.ChunkLayout(grid_origin=[5, 6, 7],\n    ...                         write_chunk_shape=[100, 200, 300])\n    >>> layout.write_chunk_template\n    { [5, 105), [6, 206), [7, 307) }\n\nNote:\n\n  Only the hard constraints :py:obj:`.grid_origin` and\n  :py:obj:`~ChunkLayout.Grid.shape` of :py:obj:`.write_chunk` are taken into\n  account.  The soft constraints :py:obj:`.grid_origin_soft_constraint` and all\n  other constraints specified on :py:obj:`.write_chunk` are **ignored**.\n\nFor any dimension ``i`` for which :python:`self.grid_origin[i] is None` or\n:python:`self.write_chunk.shape[i] is None`,\n:python:`self.write_chunk_template[i]` is an unbounded interval\n:python:`ts.Dim()`:\n\n    >>> layout = ts.ChunkLayout(grid_origin=[None, 6, 7],\n    ...                         write_chunk_shape=[100, None, 200])\n    >>> layout.write_chunk_template\n    { (-inf, +inf), (-inf, +inf), [7, 207) }\n\nRaises:\n\n  ValueError: If :py:obj:`.rank` is unspecified or :py:obj:`.grid_origin` and\n    :python:`self.write_chunk.shape` are incompatible.\n\nSee also:\n  - :py:meth:`ChunkLayout.read_chunk_template`\n\nGroup:\n  Chunk templates\n",
                "type": "property"
            }
        ],
        "definition": "<class 'tensorstore.ChunkLayout'>",
        "doc": "\nDescribes the storage layout of a :py:obj:`tensorstore.TensorStore`.\n\nGroup:\n  Spec\n\nConstructors\n------------\n\nClasses\n-------\n\nAccessors\n---------\n\nSetters\n-------\n\nChunk templates\n---------------\n\nComparison operators\n--------------------\n\n",
        "type": "class"
    },
    "CodecSpec": {
        "ast": "ClassDef(name='CodecSpec', bases=[], keywords=[], body=[FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='CodecSpec', ctx=Load())), arg(arg='include_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='CodecSpec', ctx=Load())), arg(arg='include_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load()))",
                "definition": "def to_json(self: CodecSpec, include_defaults: bool = False) -> Any: ...",
                "doc": "to_json(self: tensorstore.CodecSpec, include_defaults: bool = False) -> Any\n\n\nConverts to the :json:schema:`JSON representation<Codec>`.\n\n",
                "type": "function"
            }
        ],
        "definition": "<class 'tensorstore.CodecSpec'>",
        "doc": "\nSpecifies driver-specific encoding/decoding parameters.\n\nGroup:\n  Spec\n",
        "type": "class"
    },
    "Context": {
        "ast": "ClassDef(name='Context', bases=[], keywords=[], body=[ClassDef(name='Resource', bases=[], keywords=[], body=[FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='Context', ctx=Load()), attr='Resource', ctx=Load())), arg(arg='include_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load()))], decorator_list=[]), ClassDef(name='Spec', bases=[], keywords=[], body=[FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='Context', ctx=Load()), attr='Spec', ctx=Load())), arg(arg='include_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load()))], decorator_list=[]), FunctionDef(name='parent', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Context', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Context', ctx=Load())), FunctionDef(name='spec', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Context', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Context', ctx=Load()), attr='Spec', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "ClassDef(name='Resource', bases=[], keywords=[], body=[FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='Context', ctx=Load()), attr='Resource', ctx=Load())), arg(arg='include_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load()))], decorator_list=[])",
                "children": [
                    {
                        "ast": "FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='Context', ctx=Load()), attr='Resource', ctx=Load())), arg(arg='include_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load()))",
                        "definition": "def to_json(self: Context.Resource, include_defaults: bool = False) -> Any: ...",
                        "doc": "to_json(self: tensorstore.Context.Resource, include_defaults: bool = False) -> Any\n\n\nReturns the :json:schema:`JSON representation<ContextResource>` of the context resource.\n\nExample:\n\n    >>> context = ts.Context(\n    ...     {'cache_pool#a': {\n    ...         'total_bytes_limit': 10000000\n    ...     }})\n    >>> context['cache_pool#a'].to_json()\n    {'total_bytes_limit': 10000000}\n\nGroup:\n  Accessors\n\n",
                        "type": "function"
                    }
                ],
                "definition": "<class 'tensorstore.Context.Resource'>",
                "doc": "\nHandle to a context resource.\n",
                "type": "class"
            },
            {
                "ast": "ClassDef(name='Spec', bases=[], keywords=[], body=[FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='Context', ctx=Load()), attr='Spec', ctx=Load())), arg(arg='include_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load()))], decorator_list=[])",
                "children": [
                    {
                        "ast": "FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='Context', ctx=Load()), attr='Spec', ctx=Load())), arg(arg='include_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load()))",
                        "definition": "def to_json(self: Context.Spec, include_defaults: bool = False) -> Any: ...",
                        "doc": "to_json(self: tensorstore.Context.Spec, include_defaults: bool = False) -> Any\n\n\nReturns the :json:schema:`JSON representation<Context>`.\n\nArgs:\n  include_defaults: Indicates whether to include members even if they are equal to the default value.\n\nGroup:\n  Accessors\n\n",
                        "type": "function"
                    }
                ],
                "definition": "<class 'tensorstore.Context.Spec'>",
                "doc": "\nParsed representation of a :json:schema:`JSON Context<Context>` specification.\n",
                "type": "class"
            },
            {
                "ast": "FunctionDef(name='parent', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Context', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Context', ctx=Load()))",
                "definition": "@property\ndef parent (arg0: Context) -> Context: ...",
                "doc": "\nParent context from which this context inherits.\n\nExample:\n\n    >>> parent = ts.Context({\n    ...     'cache_pool': {\n    ...         'total_bytes_limit': 5000000\n    ...     },\n    ...     'file_io_concurrency': {\n    ...         'limit': 10\n    ...     }\n    ... })\n    >>> child = ts.Context({'cache_pool': {\n    ...     'total_bytes_limit': 10000000\n    ... }},\n    ...                    parent=parent)\n    >>> assert child.parent is parent\n    >>> parent['cache_pool'].to_json()\n    {'total_bytes_limit': 5000000}\n    >>> child['cache_pool'].to_json()\n    {'total_bytes_limit': 10000000}\n    >>> child['file_io_concurrency'].to_json()\n    {'limit': 10}\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='spec', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Context', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Context', ctx=Load()), attr='Spec', ctx=Load()))",
                "definition": "@property\ndef spec (arg0: Context) -> Context.Spec: ...",
                "doc": "\nSpec from which this context was constructed.\n\nExample:\n\n    >>> parent = ts.Context({\n    ...     'cache_pool': {\n    ...         'total_bytes_limit': 5000000\n    ...     },\n    ...     'file_io_concurrency': {\n    ...         'limit': 10\n    ...     }\n    ... })\n    >>> child = ts.Context({'cache_pool': {\n    ...     'total_bytes_limit': 10000000\n    ... }},\n    ...                    parent=parent)\n    >>> child.spec\n    Context.Spec({'cache_pool': {'total_bytes_limit': 10000000}})\n    >>> child.parent.spec\n    Context.Spec({\n      'cache_pool': {'total_bytes_limit': 5000000},\n      'file_io_concurrency': {'limit': 10},\n    })\n\nGroup:\n  Accessors\n",
                "type": "property"
            }
        ],
        "definition": "<class 'tensorstore.Context'>",
        "doc": "\nManages shared TensorStore :ref:`context resources<context>`, such as caches and credentials.\n\nGroup:\n  Core\n\nSee also:\n  :ref:`context`\n\n",
        "type": "class"
    },
    "Dim": {
        "ast": "ClassDef(name='Dim', bases=[], keywords=[], body=[FunctionDef(name='empty', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='exclusive_max', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='exclusive_min', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='finite', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='hull', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Dim', ctx=Load())), arg(arg='other', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Dim', ctx=Load())), FunctionDef(name='implicit_lower', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='implicit_upper', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='inclusive_max', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='inclusive_min', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='intersect', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Dim', ctx=Load())), arg(arg='other', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Dim', ctx=Load())), FunctionDef(name='label', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='size', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "FunctionDef(name='empty', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))",
                "definition": "@property\ndef empty (arg0: Dim) -> bool: ...",
                "doc": "\nReturns `True` if `size` is zero.\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='exclusive_max', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef exclusive_max (arg0: Dim) -> int: ...",
                "doc": "\nExclusive upper bound of the interval.\n\nEqual to :python:`self.inclusive_max + 1`.  If the interval is unbounded above,\nequal to the special value of :py:obj:`+inf+1<tensorstore.inf>`.\n\nExample:\n\n    >>> ts.Dim(inclusive_min=5, inclusive_max=10).exclusive_max\n    11\n    >>> ts.Dim(exclusive_max=5).exclusive_max\n    5\n    >>> ts.Dim().exclusive_max\n    4611686018427387904\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='exclusive_min', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef exclusive_min (arg0: Dim) -> int: ...",
                "doc": "\nExclusive lower bound of the interval.\n\nEqual to :python:`self.inclusive_min - 1`.  If the interval is unbounded below,\nequal to the special value of :py:obj:`-inf-1<tensorstore.inf>`.\n\nExample:\n\n    >>> ts.Dim(inclusive_min=5, inclusive_max=10).exclusive_min\n    4\n    >>> ts.Dim(5).exclusive_min\n    -1\n    >>> ts.Dim(exclusive_max=10).exclusive_min\n    -4611686018427387904\n    >>> ts.Dim().exclusive_min\n    -4611686018427387904\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='finite', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))",
                "definition": "@property\ndef finite (arg0: Dim) -> bool: ...",
                "doc": "\nIndicates if the interval is finite.\n\nExample:\n\n  >>> ts.Dim().finite\n  False\n  >>> ts.Dim(5).finite\n  True\n  >>> ts.Dim(exclusive_max=10).finite\n  False\n  >>> ts.Dim(inclusive_min=10).finite\n  False\n  >>> ts.Dim(inclusive_min=10, exclusive_max=20).finite\n  True\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='hull', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Dim', ctx=Load())), arg(arg='other', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Dim', ctx=Load()))",
                "definition": "def hull(self: Dim, other: Dim) -> Dim: ...",
                "doc": "hull(self: tensorstore.Dim, other: tensorstore.Dim) -> tensorstore.Dim\n\n\nHull with another Dim.\n\nThe ``implicit`` flag that corresponds to the selected bound is propagated.\nThe :py:obj:`.label` field, if non-empty, must match, and will be propagated.\n\nArgs:\n  other: Object to hull with.\n\nExample:\n\n    >>> a = ts.Dim(inclusive_min=1, exclusive_max=5, label='x')\n    >>> a.hull(ts.Dim(size=3))\n    Dim(inclusive_min=0, exclusive_max=5, label=\"x\")\n\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='implicit_lower', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))",
                "definition": "@property\ndef implicit_lower (arg0: Dim) -> bool: ...",
                "doc": "\nIndicates if the lower bound is :ref:`implicit/resizeable<implicit-bounds>`.\n\nExample:\n\n    >>> ts.Dim().implicit_lower\n    True\n    >>> ts.Dim(5).implicit_lower\n    False\n    >>> ts.Dim(exclusive_max=5).implicit_lower\n    True\n    >>> ts.Dim(inclusive_min=1, exclusive_max=5).implicit_lower\n    False\n    >>> ts.Dim(implicit_lower=False).implicit_lower\n    False\n    >>> ts.Dim(inclusive_min=5, implicit_lower=True).implicit_lower\n    True\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='implicit_upper', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))",
                "definition": "@property\ndef implicit_upper (arg0: Dim) -> bool: ...",
                "doc": "\nIndicates if the upper bound is :ref:`implicit/resizeable<implicit-bounds>`.\n\nExample:\n\n    >>> ts.Dim().implicit_upper\n    True\n    >>> ts.Dim(5).implicit_upper\n    False\n    >>> ts.Dim(inclusive_min=5).implicit_upper\n    True\n    >>> ts.Dim(inclusive_min=1, exclusive_max=5).implicit_upper\n    False\n    >>> ts.Dim(implicit_upper=False).implicit_upper\n    False\n    >>> ts.Dim(inclusive_max=5, implicit_upper=True).implicit_upper\n    True\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='inclusive_max', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef inclusive_max (arg0: Dim) -> int: ...",
                "doc": "\nInclusive upper bound of the interval.\n\nEqual to :python:`self.exclusive_max - 1`.  If the interval is unbounded above,\nequal to the special value of :py:obj:`+inf<tensorstore.inf>`.\n\nExample:\n\n    >>> ts.Dim(inclusive_min=5, inclusive_max=10).inclusive_max\n    10\n    >>> ts.Dim(exclusive_max=5).inclusive_max\n    4\n    >>> ts.Dim().inclusive_max\n    4611686018427387903\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='inclusive_min', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef inclusive_min (arg0: Dim) -> int: ...",
                "doc": "\nInclusive lower bound of the interval.\n\nEqual to :python:`self.exclusive_min + 1`.  If the interval is unbounded below,\nequal to the special value of :py:obj:`-inf<tensorstore.inf>`.\n\nExample:\n\n    >>> ts.Dim(5).inclusive_min\n    0\n    >>> ts.Dim(inclusive_min=5, inclusive_max=10).inclusive_min\n    5\n    >>> ts.Dim().inclusive_min\n    -4611686018427387903\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='intersect', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Dim', ctx=Load())), arg(arg='other', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Dim', ctx=Load()))",
                "definition": "def intersect(self: Dim, other: Dim) -> Dim: ...",
                "doc": "intersect(self: tensorstore.Dim, other: tensorstore.Dim) -> tensorstore.Dim\n\n\nIntersect with another Dim.\n\nThe ``implicit`` flag that corresponds to the selected bound is propagated.\nThe :py:obj:`.label`  field, if non-empty, must match, and will be propagated.\n\nArgs:\n  other: Object to intersect with.\n\nExample:\n\n    >>> a = ts.Dim(inclusive_min=1, exclusive_max=5, label='x')\n    >>> a.intersect(ts.Dim(size=3))\n    Dim(inclusive_min=1, exclusive_max=3, label=\"x\")\n\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='label', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))",
                "definition": "@property\ndef label (arg0: Dim) -> str: ...",
                "doc": "\nDimension label, or the empty string to indicate an unlabeled dimension.\n\nExample:\n\n    >>> ts.Dim().label\n    ''\n    >>> ts.Dim(label='x').label\n    'x'\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='size', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Dim', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef size (arg0: Dim) -> int: ...",
                "doc": "\nSize of the interval.\n\nEqual to :python:`self.exclusive_max - self.inclusive_min`.\n\nExample:\n\n    >>> ts.Dim(5).size\n    5\n    >>> ts.Dim(inclusive_min=3, inclusive_max=7).size\n    5\n    >>> ts.Dim().size\n    9223372036854775807\n\nNote:\n\n  If the interval is unbounded below or above\n  (i.e. :python:`self.finite == False`), this value it not particularly\n  meaningful.\n\nGroup:\n  Accessors\n",
                "type": "property"
            }
        ],
        "definition": "<class 'tensorstore.Dim'>",
        "doc": "\n1-d index interval with optionally-implicit bounds and dimension label.\n\nRepresents a contiguous range of integer :ref:`index values<index-space>`.  The\ninclusive lower and upper bounds may either be finite values in the closed\ninterval :math:`[-(2^{62}-2), +(2^{62}-2)]`, or infinite, as indicated by\n-/+ :py:obj:`.inf` for the lower and upper bounds, respectively.\n\nThe lower and upper bounds may additionally be marked as either\n:ref:`explicit or implicit<implicit-bounds>`.\n\nThe interval may also have an associated\n:ref:`dimension label<dimension-labels>`, which is primarily useful for\nspecifying the dimensions of an :py:obj:`.IndexDomain`.\n\nExamples:\n\n    >>> ts.Dim('x')\n    Dim(label=\"x\")\n    >>> ts.Dim(inclusive_min=3, exclusive_max=10, label='x')\n    Dim(inclusive_min=3, exclusive_max=10, label=\"x\")\n\nSee also:\n  :py:obj:`IndexDomain`\n\nGroup:\n  Indexing\n",
        "type": "class"
    },
    "DimExpression": {
        "ast": "ClassDef(name='DimExpression', bases=[], keywords=[], body=[FunctionDef(name='diagonal', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='DimExpression', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='DimExpression', ctx=Load())), FunctionDef(name='label', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Label', ctx=Load())), FunctionDef(name='mark_bounds_implicit', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_MarkBoundsImplicit', ctx=Load())), FunctionDef(name='oindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Oindex', ctx=Load())), FunctionDef(name='stride', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Stride', ctx=Load())), FunctionDef(name='translate_backward_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_TranslateBackwardBy', ctx=Load())), FunctionDef(name='translate_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_TranslateBy', ctx=Load())), FunctionDef(name='translate_to', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_TranslateTo', ctx=Load())), FunctionDef(name='transpose', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Transpose', ctx=Load())), FunctionDef(name='vindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Vindex', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "definition": "<class 'tensorstore.DimExpression._Label'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.DimExpression._MarkBoundsImplicit'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.DimExpression._Oindex'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.DimExpression._Stride'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.DimExpression._TranslateBackwardBy'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.DimExpression._TranslateBy'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.DimExpression._TranslateTo'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.DimExpression._Transpose'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.DimExpression._Vindex'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "ast": "FunctionDef(name='diagonal', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='DimExpression', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='DimExpression', ctx=Load()))",
                "definition": "@property\ndef diagonal (arg0: DimExpression) -> DimExpression: ...",
                "doc": "\nExtracts the diagonal of the selected dimensions.\n\nThe selection dimensions are removed from the resultant index space, and a new\ndimension corresponding to the diagonal is added as the first dimension, with an\ninput domain equal to the intersection of the input domains of the selection\ndimensions.  The new dimension selection is equal to :python:`ts.d[0]`,\ncorresponding to the newly added diagonal dimension.\n\nThe lower and upper bounds of the new diagonal dimension are\n:ref:`implicit<implicit-bounds>` if, and only if, the lower or upper bounds,\nrespectively, of every selected dimension are implicit.\n\nExamples:\n\n    >>> transform = ts.IndexTransform(input_shape=[2, 3],\n    ...                               input_labels=[\"x\", \"y\"])\n    >>> transform[ts.d['x', 'y'].diagonal]\n    Rank 1 -> 2 index space transform:\n      Input domain:\n        0: [0, 2)\n      Output index maps:\n        out[0] = 0 + 1 * in[0]\n        out[1] = 0 + 1 * in[0]\n    >>> transform = ts.IndexTransform(3)\n    >>> transform[ts.d[0, 2].diagonal]\n    Rank 2 -> 3 index space transform:\n      Input domain:\n        0: (-inf*, +inf*)\n        1: (-inf*, +inf*)\n      Output index maps:\n        out[0] = 0 + 1 * in[0]\n        out[1] = 0 + 1 * in[1]\n        out[2] = 0 + 1 * in[0]\n\nNote:\n\n  If zero dimensions are selected, :py:obj:`.diagonal` simply results in a new singleton\n  dimension as the first dimension, equivalent to :python:`[ts.newaxis]`:\n\n  >>> transform = ts.IndexTransform(1)\n  >>> transform[ts.d[()].diagonal]\n  Rank 2 -> 1 index space transform:\n    Input domain:\n      0: (-inf*, +inf*)\n      1: (-inf*, +inf*)\n    Output index maps:\n      out[0] = 0 + 1 * in[1]\n\n  If only one dimension is selected, :py:obj:`.diagonal` is equivalent to\n  :python:`.label[''].transpose[0]`:\n\n  >>> transform = ts.IndexTransform(input_labels=['x', 'y'])\n  >>> transform[ts.d[1].diagonal]\n  Rank 2 -> 2 index space transform:\n    Input domain:\n      0: (-inf*, +inf*)\n      1: (-inf*, +inf*) \"x\"\n    Output index maps:\n      out[0] = 0 + 1 * in[1]\n      out[1] = 0 + 1 * in[0]\n\nGroup:\n  Operations\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='label', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Label', ctx=Load()))",
                "definition": "@property\ndef label (arg0: object) -> DimExpression._Label: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='mark_bounds_implicit', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_MarkBoundsImplicit', ctx=Load()))",
                "definition": "@property\ndef mark_bounds_implicit (arg0: object) -> DimExpression._MarkBoundsImplicit: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='oindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Oindex', ctx=Load()))",
                "definition": "@property\ndef oindex (arg0: object) -> DimExpression._Oindex: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='stride', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Stride', ctx=Load()))",
                "definition": "@property\ndef stride (arg0: object) -> DimExpression._Stride: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='translate_backward_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_TranslateBackwardBy', ctx=Load()))",
                "definition": "@property\ndef translate_backward_by (arg0: object) -> DimExpression._TranslateBackwardBy: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='translate_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_TranslateBy', ctx=Load()))",
                "definition": "@property\ndef translate_by (arg0: object) -> DimExpression._TranslateBy: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='translate_to', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_TranslateTo', ctx=Load()))",
                "definition": "@property\ndef translate_to (arg0: object) -> DimExpression._TranslateTo: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='transpose', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Transpose', ctx=Load()))",
                "definition": "@property\ndef transpose (arg0: object) -> DimExpression._Transpose: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='vindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Vindex', ctx=Load()))",
                "definition": "@property\ndef vindex (arg0: object) -> DimExpression._Vindex: ...",
                "doc": "",
                "type": "property"
            }
        ],
        "definition": "<class 'tensorstore.DimExpression'>",
        "doc": "\nSpecifies an advanced indexing operation.\n\n:ref:`Dimension expressions<python-dim-expressions>` permit indexing using\n:ref:`dimension labels<dimension-labels>`, and also support additional operations\nthat cannot be performed with plain :ref:`python-numpy-style-indexing`.\n\nGroup:\n  Indexing\n\nOperations\n==========\n\n",
        "type": "class"
    },
    "Future": {
        "ast": "ClassDef(name='Future', bases=[], keywords=[], body=[FunctionDef(name='add_done_callback', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Future', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='Future', ctx=Load())], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='cancel', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Future', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='cancelled', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Future', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='done', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Future', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='exception', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Future', ctx=Load())), arg(arg='timeout', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='deadline', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='object', ctx=Load())), FunctionDef(name='force', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Future', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='remove_done_callback', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Future', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='Future', ctx=Load())], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='result', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Future', ctx=Load())), arg(arg='timeout', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='deadline', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='object', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "FunctionDef(name='add_done_callback', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Future', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='Future', ctx=Load())], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None))",
                "definition": "def add_done_callback(self: Future, callback: Callable[[Future], None]) -> None: ...",
                "doc": "add_done_callback(self: tensorstore.Future, callback: Callable[[tensorstore.Future], None]) -> None\n\n\nRegisters a callback to be invoked upon completion of the asynchronous operation.\n\nArgs:\n  callback: Callback to invoke with :python:`self` when this future becomes\n    ready.\n\n.. warning::\n\n   Unlike :py:obj:`python:asyncio.Future.add_done_callback`, but like\n   :py:obj:`python:concurrent.futures.Future.add_done_callback`, the\n   :py:param:`.callback` may be invoked from any thread.  If using\n   :py:mod:`asyncio` and :py:param:`.callback` needs to be invoked from a\n   particular event loop, wrap :py:param:`.callback` with\n   :py:obj:`python:asyncio.loop.call_soon_threadsafe`.\n\nGroup:\n  Callback interface\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='cancel', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Future', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='bool', ctx=Load()))",
                "definition": "def cancel(self: Future) -> bool: ...",
                "doc": "cancel(self: tensorstore.Future) -> bool\n\n\nRequests cancellation of the asynchronous operation.\n\nIf the operation has not already completed, it is marked as unsuccessfully\ncompleted with an instance of :py:obj:`asyncio.CancelledError`.\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='cancelled', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Future', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='bool', ctx=Load()))",
                "definition": "def cancelled(self: Future) -> bool: ...",
                "doc": "cancelled(self: tensorstore.Future) -> bool\n\n\nQueries whether the asynchronous operation has been cancelled.\n\nExample:\n\n    >>> promise, future = ts.Promise.new()\n    >>> future.cancelled()\n    False\n    >>> future.cancel()\n    >>> future.cancelled()\n    True\n    >>> future.exception()\n    Traceback (most recent call last):\n        ...\n    ...CancelledError...\n\nGroup:\n  Accessors\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='done', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Future', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='bool', ctx=Load()))",
                "definition": "def done(self: Future) -> bool: ...",
                "doc": "done(self: tensorstore.Future) -> bool\n\n\nQueries whether the asynchronous operation has completed or been cancelled.\n\nGroup:\n  Accessors\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='exception', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Future', ctx=Load())), arg(arg='timeout', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='deadline', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='object', ctx=Load()))",
                "definition": "def exception(self: Future, timeout: Optional[float] = None, deadline: Optional[float] = None) -> object: ...",
                "doc": "exception(self: tensorstore.Future, timeout: Optional[float] = None, deadline: Optional[float] = None) -> object\n\n\nBlocks until asynchronous operation completes, and returns the error if any.\n\nArgs:\n  timeout: Maximum number of seconds to block.\n  deadline: Deadline in seconds since the Unix epoch.\n\nReturns:\n\n  The error that was produced by the asynchronous operation, or :py:obj:`None`\n  if the operation completed successfully.\n\nRaises:\n\n  TimeoutError: If the result did not become ready within the specified\n    :py:param:`.timeout` or :py:param:`.deadline`.\n\n  KeyboardInterrupt: If running on the main thread and a keyboard interrupt is\n    received.\n\nGroup:\n  Blocking interface\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='force', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Future', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None))",
                "definition": "def force(self: Future) -> None: ...",
                "doc": "force(self: tensorstore.Future) -> None\n\n\nEnsures the asynchronous operation begins executing.\n\nThis is called automatically by :py:obj:`.result` and :py:obj:`.exception`, but\nmust be called explicitly when using :py:obj:`.add_done_callback`.\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='remove_done_callback', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Future', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='Future', ctx=Load())], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='int', ctx=Load()))",
                "definition": "def remove_done_callback(self: Future, callback: Callable[[Future], None]) -> int: ...",
                "doc": "remove_done_callback(self: tensorstore.Future, callback: Callable[[tensorstore.Future], None]) -> int\n\n\nUnregisters a previously-registered callback.\n\nGroup:\n  Callback interface\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='result', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Future', ctx=Load())), arg(arg='timeout', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='deadline', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='object', ctx=Load()))",
                "definition": "def result(self: Future, timeout: Optional[float] = None, deadline: Optional[float] = None) -> object: ...",
                "doc": "result(self: tensorstore.Future, timeout: Optional[float] = None, deadline: Optional[float] = None) -> object\n\n\nBlocks until the asynchronous operation completes, and returns the result.\n\nIf the asynchronous operation completes unsuccessfully, raises the error that\nwas produced.\n\nArgs:\n  timeout: Maximum number of seconds to block.\n  deadline: Deadline in seconds since the Unix epoch.\n\nReturns:\n  The result of the asynchronous operation, if successful.\n\nRaises:\n\n  TimeoutError: If the result did not become ready within the specified\n    :py:param:`.timeout` or :py:param:`.deadline`.\n\n  KeyboardInterrupt: If running on the main thread and a keyboard interrupt is\n    received.\n\nGroup:\n  Blocking interface\n\n",
                "type": "function"
            }
        ],
        "definition": "<class 'tensorstore.Future'>",
        "doc": "\nHandle for *consuming* the result of an asynchronous operation.\n\nThis type supports several different patterns for consuming results:\n\n- Asynchronously with :py:mod:`asyncio`, using the :ref:`await<python:await>`\n  keyword:\n\n      >>> future = ts.open({\n      ...     'driver': 'array',\n      ...     'array': [1, 2, 3],\n      ...     'dtype': 'uint32'\n      ... })\n      >>> await future\n      TensorStore({\n        'array': [1, 2, 3],\n        'context': {'data_copy_concurrency': {}},\n        'driver': 'array',\n        'dtype': 'uint32',\n        'transform': {'input_exclusive_max': [3], 'input_inclusive_min': [0]},\n      })\n\n- Synchronously blocking the current thread, by calling :py:meth:`.result()`.\n\n      >>> future = ts.open({\n      ...     'driver': 'array',\n      ...     'array': [1, 2, 3],\n      ...     'dtype': 'uint32'\n      ... })\n      >>> future.result()\n      TensorStore({\n        'array': [1, 2, 3],\n        'context': {'data_copy_concurrency': {}},\n        'driver': 'array',\n        'dtype': 'uint32',\n        'transform': {'input_exclusive_max': [3], 'input_inclusive_min': [0]},\n      })\n\n- Asynchronously, by registering a callback using :py:meth:`.add_done_callback`:\n\n      >>> future = ts.open({\n      ...     'driver': 'array',\n      ...     'array': [1, 2, 3],\n      ...     'dtype': 'uint32'\n      ... })\n      >>> future.add_done_callback(\n      ...     lambda f: print(f'Callback: {f.result().domain}'))\n      ... future.force()  # ensure the operation is started\n      ... # wait for completion (for testing only)\n      ... result = future.result()\n      Callback: { [0, 3) }\n\nIf an error occurs, instead of returning a value, :py:obj:`.result()` or\n:ref:`await<python:await>` will raise an exception.\n\nThis type supports a subset of the interfaces of\n:py:class:`python:concurrent.futures.Future` and\n:py:class:`python:asyncio.Future`.  Unlike those types, however,\n:py:class:`Future` provides only the *consumer* interface.  The corresponding\n*producer* interface is provided by :py:class:`Promise`.\n\n.. warning::\n\n   While this class is designed to interoperate with :py:mod:`asyncio`, it\n   cannot be used with functions such as :py:obj:`asyncio.wait` that require an\n   :py:class:`python:asyncio.Future`, because :py:obj:`.add_done_callback` does\n   not guarantee that the callback is invoked from the current event loop.  To\n   convert to a real :py:class:`python:asyncio.Future`, use\n   :py:obj:`python:asyncio.ensure_future`:\n\n       >>> dataset = await ts.open({\n       ...     'driver': 'zarr',\n       ...     'kvstore': 'memory://'\n       ... },\n       ...                         dtype=ts.uint32,\n       ...                         shape=[70, 80],\n       ...                         create=True)\n       >>> await asyncio.wait([\n       ...     asyncio.ensure_future(dataset[i * 5].write(i))\n       ...     for i in range(10)\n       ... ])\n\nSee also:\n  - :py:class:`WriteFutures`\n\nGroup:\n  Asynchronous support\n",
        "type": "class"
    },
    "FutureLike": {
        "ast": "ClassDef(name='FutureLike', bases=[], keywords=[], body=[Pass()], decorator_list=[])",
        "children": [],
        "definition": "<class 'tensorstore.FutureLike'>",
        "doc": "Abstract base class for types representing an asynchronous result.\n\n  The following types may be used where a :py:obj:`FutureLike[T]<.FutureLike>`\n  value is expected:\n\n  - an immediate value of type :python:`T`;\n  - :py:class:`tensorstore.Future` that resolves to a value of type :python:`T`;\n  - :ref:`coroutine<async>` that resolves to a value of type :python:`T`.\n\n  Group:\n    Asynchronous support\n\n  ",
        "type": "class"
    },
    "IndexDomain": {
        "ast": "ClassDef(name='IndexDomain', bases=[], keywords=[], body=[FunctionDef(name='T', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='IndexDomain', ctx=Load())), FunctionDef(name='exclusive_max', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='hull', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='IndexDomain', ctx=Load())), arg(arg='other', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='IndexDomain', ctx=Load())), FunctionDef(name='implicit_lower_bounds', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='implicit_upper_bounds', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='inclusive_max', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='inclusive_min', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='index_exp', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='slice', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='intersect', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='IndexDomain', ctx=Load())), arg(arg='other', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='IndexDomain', ctx=Load())), FunctionDef(name='label', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexDomain', ctx=Load()), attr='_Label', ctx=Load())), FunctionDef(name='labels', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='mark_bounds_implicit', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexDomain', ctx=Load()), attr='_MarkBoundsImplicit', ctx=Load())), FunctionDef(name='ndim', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='origin', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='shape', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='size', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='translate_backward_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexDomain', ctx=Load()), attr='_TranslateBackwardBy', ctx=Load())), FunctionDef(name='translate_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexDomain', ctx=Load()), attr='_TranslateBy', ctx=Load())), FunctionDef(name='translate_to', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexDomain', ctx=Load()), attr='_TranslateTo', ctx=Load())), FunctionDef(name='transpose', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='IndexDomain', ctx=Load())), arg(arg='axes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='DimSelectionLike', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='IndexDomain', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "FunctionDef(name='T', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='IndexDomain', ctx=Load()))",
                "definition": "@property\ndef T (arg0: IndexDomain) -> IndexDomain: ...",
                "doc": "\nView with the dimension order reversed (transposed).\n\nExample:\n\n    >>> domain = ts.IndexDomain(labels=['x', 'y', 'z'])\n    >>> domain.T\n    { \"z\": (-inf*, +inf*), \"y\": (-inf*, +inf*), \"x\": (-inf*, +inf*) }\n\nSee also:\n  - `.transpose`\n  - `tensorstore.DimExpression.transpose`\n\nGroup:\n  Indexing\n",
                "type": "property"
            },
            {
                "definition": "<class 'tensorstore.IndexDomain._Label'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.IndexDomain._MarkBoundsImplicit'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.IndexDomain._TranslateBackwardBy'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.IndexDomain._TranslateBy'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.IndexDomain._TranslateTo'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "ast": "FunctionDef(name='exclusive_max', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef exclusive_max (arg0: IndexDomain) -> Tuple[int, ...]: ...",
                "doc": "\nExclusive upper bound of the domain.\n\nExample:\n\n    >>> domain = ts.IndexDomain(inclusive_min=[1, 2, 3], shape=[3, 4, 5])\n    >>> domain.exclusive_max\n    (4, 6, 8)\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='hull', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='IndexDomain', ctx=Load())), arg(arg='other', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='IndexDomain', ctx=Load()))",
                "definition": "def hull(self: IndexDomain, other: IndexDomain) -> IndexDomain: ...",
                "doc": "hull(self: tensorstore.IndexDomain, other: tensorstore.IndexDomain) -> tensorstore.IndexDomain\n\n\nComputes the hull (minimum containing box) with another domain.\n\nThe ``implicit`` flag that corresponds to the selected bound is propagated.\n\nArgs:\n  other: Object to hull with.\n\nExample:\n\n    >>> a = ts.IndexDomain(inclusive_min=[1, 2, 3],\n    ...                    exclusive_max=[4, 5, 6],\n    ...                    labels=['x', 'y', ''])\n    >>> a.hull(ts.IndexDomain(shape=[2, 3, 4]))\n    { \"x\": [0, 4), \"y\": [0, 5), [0, 6) }\n\nGroup:\n  Geometric operations\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='implicit_lower_bounds', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef implicit_lower_bounds (arg0: IndexDomain) -> Tuple[bool, ...]: ...",
                "doc": "\nIndicates whether the lower bound of each dimension is :ref:`implicit or explicit<implicit-bounds>`.\n\nExample:\n\n    >>> domain = ts.IndexDomain(rank=3)\n    >>> domain.implicit_lower_bounds\n    (True, True, True)\n    >>> domain = ts.IndexDomain(inclusive_min=[2, 3, 4])\n    >>> domain.implicit_lower_bounds\n    (False, False, False)\n    >>> domain = ts.IndexDomain(exclusive_max=[2, 3, 4])\n    >>> domain.implicit_lower_bounds\n    (True, True, True)\n    >>> domain = ts.IndexDomain(shape=[4, 5, 6])\n    >>> domain.implicit_lower_bounds\n    (False, False, False)\n    >>> domain = ts.IndexDomain(inclusive_min=[4, 5, 6],\n    ...                         implicit_lower_bounds=[False, True, False])\n    >>> domain.implicit_lower_bounds\n    (False, True, False)\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='implicit_upper_bounds', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef implicit_upper_bounds (arg0: IndexDomain) -> Tuple[bool, ...]: ...",
                "doc": "\nIndicates whether the upper bound of each dimension is :ref:`implicit or explicit<implicit-bounds>`.\n\nExample:\n\n    >>> domain = ts.IndexDomain(rank=3)\n    >>> domain.implicit_upper_bounds\n    (True, True, True)\n    >>> domain = ts.IndexDomain(shape=[2, 3, 4])\n    >>> domain.implicit_upper_bounds\n    (False, False, False)\n    >>> domain = ts.IndexDomain(inclusive_min=[4, 5, 6])\n    >>> domain.implicit_upper_bounds\n    (True, True, True)\n    >>> domain = ts.IndexDomain(exclusive_max=[4, 5, 6],\n    ...                         implicit_upper_bounds=[False, True, False])\n    >>> domain.implicit_upper_bounds\n    (False, True, False)\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='inclusive_max', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef inclusive_max (arg0: IndexDomain) -> Tuple[int, ...]: ...",
                "doc": "\nInclusive upper bound of the domain.\n\nExample:\n\n    >>> domain = ts.IndexDomain(inclusive_min=[1, 2, 3], shape=[3, 4, 5])\n    >>> domain.inclusive_max\n    (3, 5, 7)\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='inclusive_min', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef inclusive_min (arg0: IndexDomain) -> Tuple[int, ...]: ...",
                "doc": "\nInclusive lower bound of the domain, alias of :py:obj:`.origin`.\n\nExample:\n\n    >>> domain = ts.IndexDomain(inclusive_min=[1, 2, 3], shape=[3, 4, 5])\n    >>> domain.inclusive_min\n    (1, 2, 3)\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='index_exp', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='slice', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef index_exp (arg0: IndexDomain) -> Tuple[slice, ...]: ...",
                "doc": "\nEquivalent NumPy-compatible :py:obj:`index expression<numpy.s_>`.\n\nThe index expression consists of a :py:obj:`tuple` of :py:obj:`.rank`\n:py:obj:`slice` objects that specify the lower and upper bounds for each\ndimension, where an infinite bound in the domain corresponds to a bound of\n:py:obj:`None` in the :py:obj:`slice` object.\n\nThe index expression can be used with this library as a\n:ref:`NumPy-style indexing expression<python-numpy-style-indexing>` or to\ndirectly index a `NumPy array<numpy.ndarray>`.\n\nExample:\n\n    >>> ts.IndexDomain(rank=2).index_exp\n    (slice(None, None, None), slice(None, None, None))\n    >>> ts.IndexDomain(inclusive_min=[1, 2], exclusive_max=[5, 10]).index_exp\n    (slice(1, 5, None), slice(2, 10, None))\n    >>> arr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])\n    >>> domain = ts.IndexDomain(inclusive_min=[0, 2], shape=[3, 2])\n    >>> arr[domain.index_exp]\n    array([[3, 4],\n           [8, 9]])\n\nRaises:\n  ValueError: If any finite bound in :py:obj:`.inclusive_min` or\n    :py:obj:`.exclusive_max` is negative.  In this case the index expression\n    would not actually NumPy-compatible since NumPy does not support actual\n    negative indices, and instead interprets negative numbers as counting from\n    the end.\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='intersect', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='IndexDomain', ctx=Load())), arg(arg='other', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='IndexDomain', ctx=Load()))",
                "definition": "def intersect(self: IndexDomain, other: IndexDomain) -> IndexDomain: ...",
                "doc": "intersect(self: tensorstore.IndexDomain, other: tensorstore.IndexDomain) -> tensorstore.IndexDomain\n\n\nIntersects with another domain.\n\nThe ``implicit`` flag that corresponds to the selected bound is propagated.\n\nArgs:\n  other: Object to intersect with.\n\nExample:\n\n    >>> a = ts.IndexDomain(inclusive_min=[1, 2, 3],\n    ...                    exclusive_max=[4, 5, 6],\n    ...                    labels=['x', 'y', ''])\n    >>> a.intersect(ts.IndexDomain(shape=[2, 3, 4]))\n    { \"x\": [1, 2), \"y\": [2, 3), [3, 4) }\n\nGroup:\n  Geometric operations\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='label', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexDomain', ctx=Load()), attr='_Label', ctx=Load()))",
                "definition": "@property\ndef label (arg0: object) -> IndexDomain._Label: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='labels', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef labels (arg0: IndexDomain) -> Tuple[str, ...]: ...",
                "doc": "\n:ref:`Dimension labels<dimension-labels>` for each dimension.\n\nExample:\n\n    >>> domain = ts.IndexDomain(inclusive_min=[1, 2, 3], shape=[3, 4, 5])\n    >>> domain.labels\n    ('', '', '')\n    >>> domain = ts.IndexDomain(inclusive_min=[1, 2, 3],\n    ...                         shape=[3, 4, 5],\n    ...                         labels=['x', 'y', 'z'])\n    >>> domain.labels\n    ('x', 'y', 'z')\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='mark_bounds_implicit', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexDomain', ctx=Load()), attr='_MarkBoundsImplicit', ctx=Load()))",
                "definition": "@property\ndef mark_bounds_implicit (arg0: object) -> IndexDomain._MarkBoundsImplicit: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='ndim', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef ndim (arg0: IndexDomain) -> int: ...",
                "doc": "\nAlias for :py:obj:`.rank`.\n\nExample:\n\n  >>> domain = ts.IndexDomain(shape=[100, 200, 300])\n  >>> domain.ndim\n  3\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='origin', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef origin (arg0: IndexDomain) -> Tuple[int, ...]: ...",
                "doc": "\nInclusive lower bound of the domain.\n\nExample:\n\n    >>> domain = ts.IndexDomain(inclusive_min=[1, 2, 3], shape=[3, 4, 5])\n    >>> domain.origin\n    (1, 2, 3)\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef rank (arg0: IndexDomain) -> int: ...",
                "doc": "\nNumber of dimensions in the index space.\n\nExample:\n\n  >>> domain = ts.IndexDomain(shape=[100, 200, 300])\n  >>> domain.rank\n  3\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='shape', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef shape (arg0: IndexDomain) -> Tuple[int, ...]: ...",
                "doc": "\nShape of the domain.\n\nExample:\n\n    >>> domain = ts.IndexDomain(inclusive_min=[1, 2, 3], shape=[3, 4, 5])\n    >>> domain.shape\n    (3, 4, 5)\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='size', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef size (arg0: IndexDomain) -> int: ...",
                "doc": "Total number of elements in the domain.\n\nThis is simply the product of the extents in :py:obj:`.shape`.\n\nExample:\n\n    >>> domain = ts.IndexDomain(inclusive_min=[1, 2, 3], shape=[3, 4, 5])\n    >>> domain.size\n    60\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='IndexDomain', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load()))",
                "definition": "def to_json(self: IndexDomain) -> Any: ...",
                "doc": "to_json(self: tensorstore.IndexDomain) -> Any\n\n\nReturns the :json:schema:`JSON representation<IndexDomain>`.\n\nGroup:\n  Accessors\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='translate_backward_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexDomain', ctx=Load()), attr='_TranslateBackwardBy', ctx=Load()))",
                "definition": "@property\ndef translate_backward_by (arg0: object) -> IndexDomain._TranslateBackwardBy: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='translate_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexDomain', ctx=Load()), attr='_TranslateBy', ctx=Load()))",
                "definition": "@property\ndef translate_by (arg0: object) -> IndexDomain._TranslateBy: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='translate_to', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexDomain', ctx=Load()), attr='_TranslateTo', ctx=Load()))",
                "definition": "@property\ndef translate_to (arg0: object) -> IndexDomain._TranslateTo: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='transpose', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='IndexDomain', ctx=Load())), arg(arg='axes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='DimSelectionLike', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='IndexDomain', ctx=Load()))",
                "definition": "def transpose(self: IndexDomain, axes: Optional[DimSelectionLike] = None) -> IndexDomain: ...",
                "doc": "transpose(self: tensorstore.IndexDomain, axes: Optional[DimSelectionLike] = None) -> tensorstore.IndexDomain\n\n\nReturns a view with a transposed domain.\n\nThis is equivalent to :python:`self[ts.d[axes].transpose[:]]`.\n\nArgs:\n\n  axes: Specifies the existing dimension corresponding to each dimension of the\n    new view.  Dimensions may be specified either by index or label.  Specifying\n    `None` is equivalent to specifying :python:`[rank-1, ..., 0]`, which\n    reverses the dimension order.\n\nRaises:\n\n  ValueError: If :py:param:`.axes` does not specify a valid permutation.\n\nSee also:\n  - `tensorstore.DimExpression.transpose`\n  - :py:obj:`.T`\n\nGroup:\n  Indexing\n\n",
                "type": "function"
            }
        ],
        "definition": "<class 'tensorstore.IndexDomain'>",
        "doc": "\n:ref:`Domain<index-domain>` (including bounds and optional dimension labels) of an N-dimensional :ref:`index space<index-space>`.\n\nLogically, an :py:class:`.IndexDomain` is the cartesian product of a sequence of `Dim` objects.\n\nNote:\n\n   Index domains are immutable, but\n   :ref:`dimension expressions<python-dim-expressions>` may be applied using\n   :py:obj:`.__getitem__(expr)` to obtain a modified domain.\n\nSee also:\n  - :py:obj:`IndexTransform`, which define a class of functions for index domains.\n  - The :json:schema:`JSON representation<IndexDomain>`.\n\nGroup:\n  Indexing\n",
        "type": "class"
    },
    "IndexTransform": {
        "ast": "ClassDef(name='IndexTransform', bases=[], keywords=[], body=[FunctionDef(name='T', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='IndexTransform', ctx=Load())), FunctionDef(name='domain', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='IndexDomain', ctx=Load())), FunctionDef(name='implicit_lower_bounds', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='implicit_upper_bounds', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='input_exclusive_max', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='input_inclusive_max', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='input_inclusive_min', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='input_labels', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='input_origin', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='input_rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='input_shape', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='label', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexTransform', ctx=Load()), attr='_Label', ctx=Load())), FunctionDef(name='mark_bounds_implicit', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexTransform', ctx=Load()), attr='_MarkBoundsImplicit', ctx=Load())), FunctionDef(name='ndim', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='oindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexTransform', ctx=Load()), attr='_Oindex', ctx=Load())), FunctionDef(name='origin', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='output', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='OutputIndexMaps', ctx=Load())), FunctionDef(name='output_rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='shape', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='size', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='translate_backward_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexTransform', ctx=Load()), attr='_TranslateBackwardBy', ctx=Load())), FunctionDef(name='translate_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexTransform', ctx=Load()), attr='_TranslateBy', ctx=Load())), FunctionDef(name='translate_to', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexTransform', ctx=Load()), attr='_TranslateTo', ctx=Load())), FunctionDef(name='transpose', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='IndexTransform', ctx=Load())), arg(arg='axes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='DimSelectionLike', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='IndexTransform', ctx=Load())), FunctionDef(name='vindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexTransform', ctx=Load()), attr='_Vindex', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "FunctionDef(name='T', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='IndexTransform', ctx=Load()))",
                "definition": "@property\ndef T (arg0: IndexTransform) -> IndexTransform: ...",
                "doc": "View with transposed domain (reversed dimension order).\n\nThis is equivalent to: :python:`self[ts.d[::-1].transpose[:]]`.\n\nSee also:\n  - `.transpose`\n  - `tensorstore.DimExpression.transpose`\n\nGroup:\n  Indexing\n",
                "type": "property"
            },
            {
                "definition": "<class 'tensorstore.IndexTransform._Label'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.IndexTransform._MarkBoundsImplicit'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.IndexTransform._Oindex'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.IndexTransform._TranslateBackwardBy'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.IndexTransform._TranslateBy'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.IndexTransform._TranslateTo'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.IndexTransform._Vindex'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "ast": "FunctionDef(name='domain', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='IndexDomain', ctx=Load()))",
                "definition": "@property\ndef domain (arg0: IndexTransform) -> IndexDomain: ...",
                "doc": "\nInput domain of the index transform.\n\nExample:\n\n    >>> transform = ts.IndexTransform(input_shape=[3, 4, 5],\n    ...                               input_labels=[\"x\", \"y\", \"z\"])\n    >>> transform.domain\n    { \"x\": [0, 3), \"y\": [0, 4), \"z\": [0, 5) }\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='implicit_lower_bounds', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef implicit_lower_bounds (arg0: IndexTransform) -> Tuple[bool, ...]: ...",
                "doc": "\nIndicates whether the lower bound of each input dimension is :ref:`implicit or explicit<implicit-bounds>`.\n\nAlias for the :py:obj:`~tensorstore.IndexDomain.implicit_lower_bounds` property of the :py:obj:`.domain`.\n\nExample:\n\n    >>> transform = ts.IndexTransform(input_rank=3)\n    >>> transform.implicit_lower_bounds\n    (True, True, True)\n    >>> transform = ts.IndexTransform(input_inclusive_min=[2, 3, 4])\n    >>> transform.implicit_lower_bounds\n    (False, False, False)\n    >>> transform = ts.IndexTransform(input_exclusive_max=[2, 3, 4])\n    >>> transform.implicit_lower_bounds\n    (True, True, True)\n    >>> transform = ts.IndexTransform(input_shape=[4, 5, 6])\n    >>> transform.implicit_lower_bounds\n    (False, False, False)\n    >>> transform = ts.IndexTransform(\n    ...     input_inclusive_min=[4, 5, 6],\n    ...     implicit_lower_bounds=[False, True, False])\n    >>> transform.implicit_lower_bounds\n    (False, True, False)\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='implicit_upper_bounds', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef implicit_upper_bounds (arg0: IndexTransform) -> Tuple[bool, ...]: ...",
                "doc": "\nIndicates whether the upper bound of each input dimension is :ref:`implicit or explicit<implicit-bounds>`.\n\nAlias for the :py:obj:`~tensorstore.IndexDomain.implicit_upper_bounds` property of the :py:obj:`.domain`.\n\nExample:\n\n    >>> transform = ts.IndexTransform(input_rank=3)\n    >>> transform.implicit_upper_bounds\n    (True, True, True)\n    >>> transform = ts.IndexTransform(input_shape=[2, 3, 4])\n    >>> transform.implicit_upper_bounds\n    (False, False, False)\n    >>> transform = ts.IndexTransform(input_inclusive_min=[4, 5, 6])\n    >>> transform.implicit_upper_bounds\n    (True, True, True)\n    >>> transform = ts.IndexTransform(\n    ...     input_exclusive_max=[4, 5, 6],\n    ...     implicit_upper_bounds=[False, True, False])\n    >>> transform.implicit_upper_bounds\n    (False, True, False)\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='input_exclusive_max', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef input_exclusive_max (arg0: IndexTransform) -> Tuple[int, ...]: ...",
                "doc": "\nExclusive upper bound of the input domain.\n\nAlias for the :py:obj:`~tensorstore.IndexDomain.exclusive_max` property of the :py:obj:`.domain`.\n\nExample:\n\n    >>> transform = ts.IndexTransform(input_inclusive_min=[1, 2, 3],\n    ...                               input_shape=[3, 4, 5])\n    >>> transform.input_exclusive_max\n    (4, 6, 8)\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='input_inclusive_max', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef input_inclusive_max (arg0: IndexTransform) -> Tuple[int, ...]: ...",
                "doc": "\nInclusive upper bound of the input domain.\n\nAlias for the :py:obj:`~tensorstore.IndexDomain.inclusive_max` property of the :py:obj:`.domain`.\n\nExample:\n\n    >>> transform = ts.IndexTransform(input_inclusive_min=[1, 2, 3],\n    ...                               input_shape=[3, 4, 5])\n    >>> transform.input_inclusive_max\n    (3, 5, 7)\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='input_inclusive_min', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef input_inclusive_min (arg0: IndexTransform) -> Tuple[int, ...]: ...",
                "doc": "\nInclusive lower bound of the input domain, alias for :py:obj:`.input_origin`.\n\nAlias for the :py:obj:`~tensorstore.IndexDomain.inclusive_min` property of the :py:obj:`.domain`.\n\nExample:\n\n    >>> transform = ts.IndexTransform(input_inclusive_min=[1, 2, 3],\n    ...                               input_shape=[3, 4, 5])\n    >>> transform.input_inclusive_min\n    (1, 2, 3)\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='input_labels', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef input_labels (arg0: IndexTransform) -> Tuple[str, ...]: ...",
                "doc": "\n:ref:`Dimension labels<dimension-labels>` for each input dimension.\n\nAlias for the :py:obj:`~tensorstore.IndexDomain.labels` property of the :py:obj:`.domain`.\n\nExample:\n\n    >>> transform = ts.IndexTransform(input_inclusive_min=[1, 2, 3],\n    ...                               input_shape=[3, 4, 5],\n    ...                               input_labels=['x', 'y', 'z'])\n    >>> transform.input_labels\n    ('x', 'y', 'z')\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='input_origin', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef input_origin (arg0: IndexTransform) -> Tuple[int, ...]: ...",
                "doc": "\nInclusive lower bound of the input domain.\n\nAlias for the :py:obj:`~tensorstore.IndexDomain.origin` property of the :py:obj:`.domain`.\n\nExample:\n\n    >>> transform = ts.IndexTransform(input_inclusive_min=[1, 2, 3],\n    ...                               input_shape=[3, 4, 5])\n    >>> transform.input_origin\n    (1, 2, 3)\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='input_rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef input_rank (arg0: IndexTransform) -> int: ...",
                "doc": "\nRank of the input space.\n\nExample:\n\n    >>> transform = ts.IndexTransform(input_shape=[3, 4, 5],\n    ...                               input_labels=[\"x\", \"y\", \"z\"])\n    >>> transform.input_rank\n    3\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='input_shape', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef input_shape (arg0: IndexTransform) -> Tuple[int, ...]: ...",
                "doc": "\nShape of the input domain.\n\nAlias for the :py:obj:`~tensorstore.IndexDomain.shape` property of the :py:obj:`.domain`.\n\nExample:\n\n    >>> transform = ts.IndexTransform(input_shape=[3, 4, 5])\n    >>> transform.input_shape\n    (3, 4, 5)\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='label', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexTransform', ctx=Load()), attr='_Label', ctx=Load()))",
                "definition": "@property\ndef label (arg0: object) -> IndexTransform._Label: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='mark_bounds_implicit', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexTransform', ctx=Load()), attr='_MarkBoundsImplicit', ctx=Load()))",
                "definition": "@property\ndef mark_bounds_implicit (arg0: object) -> IndexTransform._MarkBoundsImplicit: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='ndim', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef ndim (arg0: IndexTransform) -> int: ...",
                "doc": "\nRank of the input space, alias for :py:obj:`.input_rank`.\n\nExample:\n\n    >>> transform = ts.IndexTransform(input_shape=[3, 4, 5],\n    ...                               input_labels=[\"x\", \"y\", \"z\"])\n    >>> transform.ndim\n    3\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='oindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexTransform', ctx=Load()), attr='_Oindex', ctx=Load()))",
                "definition": "@property\ndef oindex (arg0: object) -> IndexTransform._Oindex: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='origin', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef origin (arg0: IndexTransform) -> Tuple[int, ...]: ...",
                "doc": "Inclusive lower bound of the domain.\n\nThis is equivalent to :python:`self.domain.origin`.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='output', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='OutputIndexMaps', ctx=Load()))",
                "definition": "@property\ndef output (arg0: IndexTransform) -> OutputIndexMaps: ...",
                "doc": "\nOutput index maps.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='output_rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef output_rank (arg0: IndexTransform) -> int: ...",
                "doc": "\nRank of the output space.\n\nExample:\n\n    >>> transform = ts.IndexTransform(input_shape=[3, 4, 5],\n    ...                               input_labels=[\"x\", \"y\", \"z\"],\n    ...                               output=[ts.OutputIndexMap(offset=5)])\n    >>> transform.output_rank\n    1\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='shape', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef shape (arg0: IndexTransform) -> Tuple[int, ...]: ...",
                "doc": "Shape of the domain.\n\nThis is equivalent to :python:`self.domain.shape`.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='size', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef size (arg0: IndexTransform) -> int: ...",
                "doc": "Total number of elements in the domain.\n\nThis is equivalent to :python:`self.domain.size`.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='IndexTransform', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load()))",
                "definition": "def to_json(self: IndexTransform) -> Any: ...",
                "doc": "to_json(self: tensorstore.IndexTransform) -> Any\n\n\nReturns the :json:schema:`JSON representation<IndexTransform>` of the transform.\n\nExample:\n\n   >>> transform = ts.IndexTransform(\n   ...     input_inclusive_min=[1, 2, -1],\n   ...     implicit_lower_bounds=[1, 0, 0],\n   ...     input_shape=[3, 2, 2],\n   ...     implicit_upper_bounds=[0, 1, 0],\n   ...     input_labels=['x', 'y', 'z'],\n   ...     output=[\n   ...         ts.OutputIndexMap(offset=7, stride=13, input_dimension=1),\n   ...         ts.OutputIndexMap(offset=8),\n   ...         ts.OutputIndexMap(\n   ...             offset=1,\n   ...             stride=-2,\n   ...             index_array=[[[1, 2]]],\n   ...             index_range=ts.Dim(inclusive_min=-3, exclusive_max=10),\n   ...         ),\n   ...     ],\n   ... )\n   >>> transform.to_json()\n   {'input_exclusive_max': [4, [4], 1],\n    'input_inclusive_min': [[1], 2, -1],\n    'input_labels': ['x', 'y', 'z'],\n    'output': [{'input_dimension': 1, 'offset': 7, 'stride': 13},\n               {'offset': 8},\n               {'index_array': [[[1, 2]]], 'offset': 1, 'stride': -2}]}\n\nGroup:\n  Accessors\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='translate_backward_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexTransform', ctx=Load()), attr='_TranslateBackwardBy', ctx=Load()))",
                "definition": "@property\ndef translate_backward_by (arg0: object) -> IndexTransform._TranslateBackwardBy: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='translate_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexTransform', ctx=Load()), attr='_TranslateBy', ctx=Load()))",
                "definition": "@property\ndef translate_by (arg0: object) -> IndexTransform._TranslateBy: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='translate_to', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexTransform', ctx=Load()), attr='_TranslateTo', ctx=Load()))",
                "definition": "@property\ndef translate_to (arg0: object) -> IndexTransform._TranslateTo: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='transpose', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='IndexTransform', ctx=Load())), arg(arg='axes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='DimSelectionLike', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='IndexTransform', ctx=Load()))",
                "definition": "def transpose(self: IndexTransform, axes: Optional[DimSelectionLike] = None) -> IndexTransform: ...",
                "doc": "transpose(self: tensorstore.IndexTransform, axes: Optional[DimSelectionLike] = None) -> tensorstore.IndexTransform\n\n\nReturns a view with a transposed domain.\n\nThis is equivalent to :python:`self[ts.d[axes].transpose[:]]`.\n\nArgs:\n\n  axes: Specifies the existing dimension corresponding to each dimension of the\n    new view.  Dimensions may be specified either by index or label.  Specifying\n    `None` is equivalent to specifying :python:`[rank-1, ..., 0]`, which\n    reverses the dimension order.\n\nRaises:\n\n  ValueError: If :py:param:`.axes` does not specify a valid permutation.\n\nSee also:\n  - `tensorstore.DimExpression.transpose`\n  - :py:obj:`.T`\n\nGroup:\n  Indexing\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='vindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='IndexTransform', ctx=Load()), attr='_Vindex', ctx=Load()))",
                "definition": "@property\ndef vindex (arg0: object) -> IndexTransform._Vindex: ...",
                "doc": "",
                "type": "property"
            }
        ],
        "definition": "<class 'tensorstore.IndexTransform'>",
        "doc": "\nRepresents a transform from an input index space to an output space.\n\nThe :ref:`index transform abstraction<index-transform>` underlies all indexing\noperations in the TensorStore library, and enables fully-composable virtual\nviews.  For many common use cases cases, however, it does not need to be used\ndirectly; instead, it is used indirectly through\n:ref:`indexing operations<python-indexing>` on the :py:class:`TensorStore` class\nand other :py:class:`Indexable` types.\n\nSee also:\n  - :py:obj:`IndexDomain`, which represents the domain of an index transform.\n  - The :json:schema:`JSON representation<IndexTransform>`.\n\nGroup:\n  Indexing\n\nConstructors\n============\n\nAccessors\n=========\n\nIndexing\n========\n\n",
        "type": "class"
    },
    "Indexable": {
        "ast": "ClassDef(name='Indexable', bases=[], keywords=[], body=[Pass()], decorator_list=[])",
        "children": [],
        "definition": "<class 'tensorstore.Indexable'>",
        "doc": "Abstract base class for types that support :ref:`TensorStore indexing operations<python-indexing>`.\n\n  Supported types are:\n\n  - :py:class:`tensorstore.TensorStore`\n  - :py:class:`tensorstore.Spec`\n  - :py:class:`tensorstore.IndexTransform`\n\n  Group:\n    Indexing\n  ",
        "type": "class"
    },
    "KvStore": {
        "ast": "ClassDef(name='KvStore', bases=[], keywords=[], body=[ClassDef(name='KeyRange', bases=[], keywords=[], body=[FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load())), FunctionDef(name='empty', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='exclusive_max', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='inclusive_min', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='ReadResult', bases=[], keywords=[], body=[FunctionDef(name='stamp', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='ReadResult', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='KvStore', ctx=Load()), attr='TimestampedStorageGeneration', ctx=Load())), FunctionDef(name='state', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='ReadResult', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Literal', ctx=Load()), slice=Tuple(elts=[Constant(value='unspecified'), Constant(value='missing'), Constant(value='value')], ctx=Load()), ctx=Load())), FunctionDef(name='value', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='ReadResult', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bytes', ctx=Load()))], decorator_list=[]), ClassDef(name='Spec', bases=[], keywords=[], body=[FunctionDef(name='base', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()), ctx=Load())), FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load())), FunctionDef(name='path', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load())), arg(arg='include_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='update', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()))], kwonlyargs=[arg(arg='unbind_context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='strip_context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Context', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='url', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='TimestampedStorageGeneration', bases=[], keywords=[], body=[FunctionDef(name='generation', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='TimestampedStorageGeneration', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bytes', ctx=Load())), FunctionDef(name='time', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='TimestampedStorageGeneration', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))], decorator_list=[]), FunctionDef(name='base', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='KvStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='KvStore', ctx=Load()), ctx=Load())), FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='KvStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='KvStore', ctx=Load())), FunctionDef(name='delete_range', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='KvStore', ctx=Load())), arg(arg='range', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Constant(value=None), ctx=Load())), FunctionDef(name='experimental_copy_range_to', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='KvStore', ctx=Load())), arg(arg='target', annotation=Name(id='KvStore', ctx=Load())), arg(arg='source_range', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()), ctx=Load())), arg(arg='source_staleness_bound', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Constant(value=None), ctx=Load())), FunctionDef(name='list', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='KvStore', ctx=Load())), arg(arg='range', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()), ctx=Load())), arg(arg='strip_prefix_length', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=0)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='bytes', ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='open', args=arguments(posonlyargs=[], args=[arg(arg='spec', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Context', ctx=Load()), ctx=Load())), arg(arg='transaction', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Transaction', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Name(id='KvStore', ctx=Load()), ctx=Load())), FunctionDef(name='path', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='KvStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='read', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='KvStore', ctx=Load())), arg(arg='key', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[arg(arg='if_not_equal', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='staleness_bound', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Attribute(value=Name(id='KvStore', ctx=Load()), attr='ReadResult', ctx=Load()), ctx=Load())), FunctionDef(name='spec', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='KvStore', ctx=Load()))], kwonlyargs=[arg(arg='retain_context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='unbind_context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load())), FunctionDef(name='transaction', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='KvStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Transaction', ctx=Load()), ctx=Load())), FunctionDef(name='url', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='KvStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='with_transaction', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='KvStore', ctx=Load())), arg(arg='transaction', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Transaction', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='KvStore', ctx=Load())), FunctionDef(name='write', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='KvStore', ctx=Load())), arg(arg='key', annotation=Name(id='str', ctx=Load())), arg(arg='value', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='if_equal', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Attribute(value=Name(id='KvStore', ctx=Load()), attr='TimestampedStorageGeneration', ctx=Load()), ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "ClassDef(name='KeyRange', bases=[], keywords=[], body=[FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load())), FunctionDef(name='empty', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='exclusive_max', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='inclusive_min', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))], decorator_list=[])",
                "children": [
                    {
                        "ast": "FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()))",
                        "definition": "def copy(self: KvStore.KeyRange) -> KvStore.KeyRange: ...",
                        "doc": "copy(self: tensorstore.KvStore.KeyRange) -> tensorstore.KvStore.KeyRange\n\n\nReturns a copy of the range.\n\nGroup:\n  Accessors\n\n",
                        "type": "function"
                    },
                    {
                        "ast": "FunctionDef(name='empty', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))",
                        "definition": "@property\ndef empty (arg0: KvStore.KeyRange) -> bool: ...",
                        "doc": "\nIndicates if the range contains no keys.\n\nExample:\n\n    >>> r = ts.KvStore.KeyRange(b'x', b'y')\n    >>> r.empty\n    False\n    >>> r = ts.KvStore.KeyRange(b'x', b'x')\n    >>> r.empty\n    True\n    >>> r = ts.KvStore.KeyRange(b'y', b'x')\n    >>> r.empty\n    True\n\nGroup:\n  Accessors\n",
                        "type": "property"
                    },
                    {
                        "ast": "FunctionDef(name='exclusive_max', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))",
                        "definition": "@property\ndef exclusive_max (arg0: KvStore.KeyRange) -> str: ...",
                        "doc": "\nExclusive upper bound of the range.\n\nAs a special case, an empty string indicates no upper bound.\n\nGroup:\n  Accessors\n",
                        "type": "property"
                    },
                    {
                        "ast": "FunctionDef(name='inclusive_min', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))",
                        "definition": "@property\ndef inclusive_min (arg0: KvStore.KeyRange) -> str: ...",
                        "doc": "\nInclusive lower bound of the range.\n\nIn accordance with the usual lexicographical order, an empty string indicates no\nlower bound.\n\nGroup:\n  Accessors\n",
                        "type": "property"
                    }
                ],
                "definition": "<class 'tensorstore.KvStore.KeyRange'>",
                "doc": "\nHalf-open interval of byte string keys, according to lexicographical order.\n",
                "type": "class"
            },
            {
                "ast": "ClassDef(name='ReadResult', bases=[], keywords=[], body=[FunctionDef(name='stamp', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='ReadResult', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='KvStore', ctx=Load()), attr='TimestampedStorageGeneration', ctx=Load())), FunctionDef(name='state', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='ReadResult', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Literal', ctx=Load()), slice=Tuple(elts=[Constant(value='unspecified'), Constant(value='missing'), Constant(value='value')], ctx=Load()), ctx=Load())), FunctionDef(name='value', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='ReadResult', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bytes', ctx=Load()))], decorator_list=[])",
                "children": [
                    {
                        "ast": "FunctionDef(name='stamp', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='ReadResult', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='KvStore', ctx=Load()), attr='TimestampedStorageGeneration', ctx=Load()))",
                        "definition": "@property\ndef stamp (arg0: KvStore.ReadResult) -> KvStore.TimestampedStorageGeneration: ...",
                        "doc": "\nGeneration and timestamp associated with the value.\n",
                        "type": "property"
                    },
                    {
                        "ast": "FunctionDef(name='state', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='ReadResult', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Literal', ctx=Load()), slice=Tuple(elts=[Constant(value='unspecified'), Constant(value='missing'), Constant(value='value')], ctx=Load()), ctx=Load()))",
                        "definition": "@property\ndef state (arg0: KvStore.ReadResult) -> Literal['unspecified', 'missing', 'value']: ...",
                        "doc": "\nIndicates the interpretation of :py:obj:`.value`.\n",
                        "type": "property"
                    },
                    {
                        "ast": "FunctionDef(name='value', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='ReadResult', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bytes', ctx=Load()))",
                        "definition": "@property\ndef value (arg0: KvStore.ReadResult) -> bytes: ...",
                        "doc": "\nValue associated with the key.\n",
                        "type": "property"
                    }
                ],
                "definition": "<class 'tensorstore.KvStore.ReadResult'>",
                "doc": "\nSpecifies the result of a read operation.\n",
                "type": "class"
            },
            {
                "ast": "ClassDef(name='Spec', bases=[], keywords=[], body=[FunctionDef(name='base', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()), ctx=Load())), FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load())), FunctionDef(name='path', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load())), arg(arg='include_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='update', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()))], kwonlyargs=[arg(arg='unbind_context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='strip_context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Context', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='url', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))], decorator_list=[])",
                "children": [
                    {
                        "ast": "FunctionDef(name='base', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()), ctx=Load()))",
                        "definition": "@property\ndef base (arg0: KvStore.Spec) -> Optional[KvStore.Spec]: ...",
                        "doc": "\nUnderlying key-value store, if this is a key-value store adapter.\n\nAdapter key-value stores include:\n\n- :ref:`OCDBT<ocdbt-kvstore-driver>`\n- :ref:`neuroglancer_uint64_sharded<neuroglancer-uint64-sharded-kvstore-driver>`\n\nFor regular, non-adapter key-value stores, this is :python:`None`.\n\nExample:\n\n    >>> spec = ts.KvStore.Spec({'driver': 'ocdbt', 'base': 'memory://'})\n    >>> spec.base\n    KvStore.Spec({'driver': 'memory'})\n\nSee also:\n\n  - :py:obj:`KvStore.base`\n\nGroup:\n  Accessors\n",
                        "type": "property"
                    },
                    {
                        "ast": "FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()))",
                        "definition": "def copy(self: KvStore.Spec) -> KvStore.Spec: ...",
                        "doc": "copy(self: tensorstore.KvStore.Spec) -> tensorstore.KvStore.Spec\n\n\nReturns a copy of the key-value store spec.\n\nExample:\n\n  >>> a = ts.KvStore.Spec({'driver': 'file', 'path': 'tmp/data/'})\n  >>> b = a.copy()\n  >>> a.path = 'tmp/data/abc/'\n  >>> a\n  KvStore.Spec({'driver': 'file', 'path': 'tmp/data/abc/'})\n  >>> b\n  KvStore.Spec({'driver': 'file', 'path': 'tmp/data/'})\n\nGroup:\n  Accessors\n\n",
                        "type": "function"
                    },
                    {
                        "ast": "FunctionDef(name='path', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))",
                        "definition": "@property\ndef path (arg0: KvStore.Spec) -> str: ...",
                        "doc": "\nPath prefix within the base key-value store.\n\nExample:\n\n    >>> spec = ts.KvStore.Spec({'driver': 'file', 'path': 'tmp/data'})\n    >>> spec.path\n    'tmp/data'\n\nGroup:\n  Accessors\n",
                        "type": "property"
                    },
                    {
                        "ast": "FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load())), arg(arg='include_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load()))",
                        "definition": "def to_json(self: KvStore.Spec, include_defaults: bool = False) -> Any: ...",
                        "doc": "to_json(self: tensorstore.KvStore.Spec, include_defaults: bool = False) -> Any\n\n\nConverts to the :json:schema:`JSON representation<KvStore>`.\n\nExample:\n\n  >>> spec = ts.KvStore.Spec({'driver': 'file', 'path': 'tmp/dataset/'})\n  >>> spec /= 'abc/'\n  >>> spec.to_json()\n  {'driver': 'file', 'path': 'tmp/dataset/abc/'}\n  >>> spec.to_json(include_defaults=True)\n  {'context': {},\n   'driver': 'file',\n   'file_io_concurrency': 'file_io_concurrency',\n   'file_io_sync': 'file_io_sync',\n   'path': 'tmp/dataset/abc/'}\n\nGroup:\n  Accessors\n\n",
                        "type": "function"
                    },
                    {
                        "ast": "FunctionDef(name='update', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()))], kwonlyargs=[arg(arg='unbind_context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='strip_context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Context', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None))",
                        "definition": "def update(self: KvStore.Spec, *, unbind_context: Optional[bool] = None, strip_context: Optional[bool] = None, context: Optional[Context] = None) -> None: ...",
                        "doc": "update(self: tensorstore.KvStore.Spec, *, unbind_context: Optional[bool] = None, strip_context: Optional[bool] = None, context: Optional[tensorstore.Context] = None) -> None\n\n\nModifies a spec.\n\nExample:\n\n    >>> spec = ts.KvStore.Spec({\n    ...     'driver': 'memory',\n    ...     'path': 'abc/',\n    ...     'memory_key_value_store': 'memory_key_value_store#a'\n    ... })\n    >>> spec.update(context=ts.Context({'memory_key_value_store#a': {}}))\n    >>> spec\n    KvStore.Spec({\n      'context': {'memory_key_value_store#a': {}},\n      'driver': 'memory',\n      'memory_key_value_store': ['memory_key_value_store#a'],\n      'path': 'abc/',\n    })\n    >>> spec.update(unbind_context=True)\n    >>> spec\n    KvStore.Spec({\n      'context': {'memory_key_value_store#a': {}},\n      'driver': 'memory',\n      'memory_key_value_store': 'memory_key_value_store#a',\n      'path': 'abc/',\n    })\n    >>> spec.update(strip_context=True)\n    >>> spec\n    KvStore.Spec({'driver': 'memory', 'path': 'abc/'})\n\nArgs:\n\n  unbind_context: Convert any bound context resources to context resource specs that fully capture\n    the graph of shared context resources and interdependencies.\n    \n    Re-binding/re-opening the resultant spec will result in a new graph of new\n    context resources that is isomorphic to the original graph of context resources.\n    The resultant spec will not refer to any external context resources;\n    consequently, binding it to any specific context will have the same effect as\n    binding it to a default context.\n    \n    Specifying a value of :python:`False` has no effect.\n  strip_context: Replace any bound context resources and unbound context resource specs by\n    default context resource specs.\n    \n    If the resultant :py:obj:`~tensorstore.KvStore.Spec` is re-opened with, or\n    re-bound to, a new context, it will use the default context resources specified\n    by that context.\n    \n    Specifying a value of :python:`False` has no effect.\n  context: Bind any context resource specs using the specified shared resource context.\n    \n    Any already-bound context resources remain unchanged.  Additionally, any context\n    resources specified by a nested :json:schema:`KvStore.context` spec will be\n    created as specified, but won't be overridden by :py:param:`.context`.\n\n\nGroup:\n  Mutators\n\n\n",
                        "type": "function"
                    },
                    {
                        "ast": "FunctionDef(name='url', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))",
                        "definition": "@property\ndef url (arg0: KvStore.Spec) -> str: ...",
                        "doc": "\n:json:schema:`URL representation<KvStoreUrl>` of the key-value store specification.\n\nExample:\n\n    >>> spec = ts.KvStore.Spec({\n    ...     'driver': 'gcs',\n    ...     'bucket': 'my-bucket',\n    ...     'path': 'path/to/object'\n    ... })\n    >>> spec.url\n    'gs://my-bucket/path/to/object'\n\nGroup:\n  Accessors\n",
                        "type": "property"
                    }
                ],
                "definition": "<class 'tensorstore.KvStore.Spec'>",
                "doc": "\nParsed representation of a :json:schema:`JSON key-value store<KvStore>` specification.\n",
                "type": "class"
            },
            {
                "ast": "ClassDef(name='TimestampedStorageGeneration', bases=[], keywords=[], body=[FunctionDef(name='generation', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='TimestampedStorageGeneration', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bytes', ctx=Load())), FunctionDef(name='time', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='TimestampedStorageGeneration', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))], decorator_list=[])",
                "children": [
                    {
                        "ast": "FunctionDef(name='generation', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='TimestampedStorageGeneration', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bytes', ctx=Load()))",
                        "definition": "@property\ndef generation (arg0: KvStore.TimestampedStorageGeneration) -> bytes: ...",
                        "doc": "\nIdentifies a specific version of a key-value store entry.\n\nAn empty string :python:`b''` indicates an unspecified version.\n\nGroup:\n  Accessors\n",
                        "type": "property"
                    },
                    {
                        "ast": "FunctionDef(name='time', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='TimestampedStorageGeneration', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))",
                        "definition": "@property\ndef time (arg0: KvStore.TimestampedStorageGeneration) -> float: ...",
                        "doc": "\nTime (seconds since Unix epoch) at which :py:obj:`.generation` is valid.\n\nGroup:\n  Accessors\n",
                        "type": "property"
                    }
                ],
                "definition": "<class 'tensorstore.KvStore.TimestampedStorageGeneration'>",
                "doc": "\nSpecifies a storage generation identifier and a timestamp.\n",
                "type": "class"
            },
            {
                "ast": "FunctionDef(name='base', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='KvStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='KvStore', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef base (arg0: KvStore) -> Optional[KvStore]: ...",
                "doc": "\nUnderlying key-value store, if this is a key-value store adapter.\n\nAdapter key-value stores include:\n\n- :ref:`ocdbt-kvstore-driver`\n- :ref:`neuroglancer-uint64-sharded-kvstore-driver`\n\nFor regular, non-adapter key-value stores, this is :python:`None`.\n\nExample:\n\n    >>> store = await ts.KvStore.open({\n    ...     'driver': 'ocdbt',\n    ...     'base': 'memory://'\n    ... })\n    >>> store.base\n    KvStore({'context': {'memory_key_value_store': {}}, 'driver': 'memory'})\n\nSee also:\n\n  - :py:obj:`KvStore.Spec.base`\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='KvStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='KvStore', ctx=Load()))",
                "definition": "def copy(self: KvStore) -> KvStore: ...",
                "doc": "copy(self: tensorstore.KvStore) -> tensorstore.KvStore\n\n\nReturns a copy of the key-value store.\n\nExample:\n\n  >>> a = await ts.KvStore.open({'driver': 'file', 'path': 'tmp/data/'})\n  >>> b = a.copy()\n  >>> a.path = 'tmp/data/abc/'\n  >>> a\n  KvStore({\n    'context': {'file_io_concurrency': {}, 'file_io_sync': True},\n    'driver': 'file',\n    'path': 'tmp/data/abc/',\n  })\n  >>> b\n  KvStore({\n    'context': {'file_io_concurrency': {}, 'file_io_sync': True},\n    'driver': 'file',\n    'path': 'tmp/data/',\n  })\n\nGroup:\n  Accessors\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='delete_range', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='KvStore', ctx=Load())), arg(arg='range', annotation=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Constant(value=None), ctx=Load()))",
                "definition": "def delete_range(self: KvStore, range: KvStore.KeyRange) -> Future[None]: ...",
                "doc": "delete_range(self: tensorstore.KvStore, range: tensorstore.KvStore.KeyRange) -> tensorstore.Future[None]\n\n\nDeletes a key range.\n\nExample:\n\n    >>> store = await ts.KvStore.open({'driver': 'memory'})\n    >>> await store.write(b'a', b'value')\n    >>> await store.write(b'b', b'value')\n    >>> await store.write(b'c', b'value')\n    >>> await store.list()\n    [b'a', b'b', b'c']\n    >>> await store.delete_range(ts.KvStore.KeyRange(b'aa', b'cc'))\n    >>> await store.list()\n    [b'a']\n\nArgs:\n\n  range: Key range to delete.  This is relative to the existing :py:obj:`.path`,\n    if any.\n\nReturns:\n\n  - If no :py:obj:`.transaction` is specified, returns a :py:obj:`Future` that\n    becomes ready when the delete operation has completed and durability is\n    guaranteed (to the extent supported by the\n    :ref:`driver<key-value-store-drivers>`).\n\n  - If a :py:obj:`.transaction` is specified, returns a :py:obj:`Future` that\n    becomes ready when the delete operation is recorded in the transaction.  The\n    delete operation is not actually performed until the transaction is\n    committed.\n\nGroup:\n  I/O\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='experimental_copy_range_to', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='KvStore', ctx=Load())), arg(arg='target', annotation=Name(id='KvStore', ctx=Load())), arg(arg='source_range', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()), ctx=Load())), arg(arg='source_staleness_bound', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Constant(value=None), ctx=Load()))",
                "definition": "def experimental_copy_range_to(self: KvStore, target: KvStore, source_range: Optional[KvStore.KeyRange] = None, source_staleness_bound: Optional[float] = None) -> Future[None]: ...",
                "doc": "experimental_copy_range_to(self: tensorstore.KvStore, target: tensorstore.KvStore, source_range: Optional[tensorstore.KvStore.KeyRange] = None, source_staleness_bound: Optional[float] = None) -> tensorstore.Future[None]\n\n\nCopies a range of keys.\n\n.. warning::\n\n   This API is experimental and subject to change.\n\nExample:\n\n    >>> store = await ts.KvStore.open({\n    ...     'driver': 'ocdbt',\n    ...     'base': 'memory://'\n    ... })\n    >>> await store.write(b'x/a', b'value')\n    >>> await store.write(b'x/b', b'value')\n    >>> await store.list()\n    [b'x/a', b'x/b']\n    >>> await (store / \"x/\").experimental_copy_range_to(store / \"y/\")\n    >>> await store.list()\n    [b'x/a', b'x/b', b'y/a', b'y/b']\n\n.. note::\n\n   Depending on the kvstore implementation, this operation may be able to\n   perform the copy without actually re-writing the data.\n\nArgs:\n\n  target: Target key-value store.\n\n    .. warning::\n\n       This may refer to the same kvstore as ``self``, but the target key range\n       must not overlap with ``self``.  If this requirement is violated, the\n       behavior is unspecified.\n\n  source_range: Key range to include.  This is relative to the existing\n    :py:obj:`.path`, if any.  If not specified, all keys under :py:obj:`.path`\n    are copied.\n  source_staleness_bound: Specifies a time in (fractional) seconds since the\n    Unix epoch.  If specified, data that is cached internally by the kvstore\n    implementation may be used without validation if not older than the\n    :py:param:`.source_staleness_bound`.  Cached data older than\n    :py:param:`.source_staleness_bound` must be validated before being returned.\n    A value of :python:`float('inf')` indicates that the result must be current\n    as of the time the :py:obj:`.read` request was made, i.e. it is equivalent\n    to specifying a value of :python:`time.time()`.  A value of\n    :python:`float('-inf')` indicates that cached data may be returned without\n    validation irrespective of its age.\n\nReturns:\n\n  - If no :py:obj:`.transaction` is specified for :py:param:`.target`, returns a\n    :py:obj:`Future` that becomes ready when the copy operation has completed\n    and durability is guaranteed (to the extent supported by the\n    :ref:`driver<key-value-store-drivers>`).\n\n  - If a :py:obj:`.transaction` is specified for :py:param:`.target`, returns a\n    :py:obj:`Future` that becomes ready when the copy operation is recorded in\n    the transaction.  The copy operation is not actually performed until the\n    transaction is committed.\n\nGroup:\n  I/O\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='list', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='KvStore', ctx=Load())), arg(arg='range', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='KvStore', ctx=Load()), attr='KeyRange', ctx=Load()), ctx=Load())), arg(arg='strip_prefix_length', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=0)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='bytes', ctx=Load()), ctx=Load()), ctx=Load()))",
                "definition": "def list(self: KvStore, range: Optional[KvStore.KeyRange] = None, strip_prefix_length: int = 0) -> Future[List[bytes]]: ...",
                "doc": "list(self: tensorstore.KvStore, range: Optional[tensorstore.KvStore.KeyRange] = None, strip_prefix_length: int = 0) -> tensorstore.Future[List[bytes]]\n\n\nLists the keys in the key-value store.\n\nExample:\n\n    >>> store = ts.KvStore.open({'driver': 'memory'}).result()\n    >>> store[b'a'] = b'value'\n    >>> store[b'b'] = b'value'\n    >>> store.list().result()\n    [b'a', b'b']\n    >>> store.list(ts.KvStore.KeyRange(inclusive_min=b'b')).result()\n    [b'b']\n\nArgs:\n\n  range: If specified, restricts to the specified key range.\n\n  strip_prefix_length: Strips the specified number of bytes from the start of\n    the returned keys.\n\nReturns:\n\n  Future that resolves to the list of matching keys, in an unspecified order.\n\nRaises:\n\n  ValueError: If a :py:obj:`.transaction` is specified.\n\nWarning:\n\n  This returns all keys within :py:param:`range` as a single :py:obj:`list`.  If\n  there are a large number of matching keys, this can consume a large amount of\n  memory.\n\nGroup:\n  I/O\n\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='open', args=arguments(posonlyargs=[], args=[arg(arg='spec', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Context', ctx=Load()), ctx=Load())), arg(arg='transaction', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Transaction', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Name(id='KvStore', ctx=Load()), ctx=Load()))",
                "definition": "def open(spec: Union[KvStore.Spec, Any], *, context: Optional[Context] = None, transaction: Optional[Transaction] = None) -> Future[KvStore]: ...",
                "doc": "open(spec: Union[tensorstore.KvStore.Spec, Any], *, context: Optional[tensorstore.Context] = None, transaction: Optional[tensorstore.Transaction] = None) -> tensorstore.Future[tensorstore.KvStore]\n\n\nOpens a key-value store.\n\nExample of opening from a :json:schema:`JSON KvStore spec<KvStore>`:\n\n    >>> kvstore = await ts.KvStore.open({'driver': 'memory', 'path': 'abc/'})\n    >>> await kvstore.write(b'x', b'y')\n    KvStore.TimestampedStorageGeneration(b'...', ...)\n    >>> await kvstore.read(b'x')\n    KvStore.ReadResult(state='value', value=b'y', stamp=KvStore.TimestampedStorageGeneration(b'...', ...))\n\nExample of opening from a :json:schema:`URL<KvStoreUrl>`:\n\n    >>> kvstore = await ts.KvStore.open('memory://abc/')\n    >>> kvstore.spec()\n    KvStore.Spec({'driver': 'memory', 'path': 'abc/'})\n\nExample of opening from an existing :py:obj:`KvStore.Spec`:\n\n    >>> spec = ts.KvStore.Spec({'driver': 'memory', 'path': 'abc/'})\n    >>> kvstore = await ts.KvStore.open(spec)\n    >>> kvstore.spec()\n    KvStore.Spec({'driver': 'memory', 'path': 'abc/'})\n\nArgs:\n\n  spec: Key-value store spec to open.  May also be specified as\n    :json:schema:`JSON<KvStore>` or a :json:schema:`URL<KvStoreUrl>`.\n\n  context: Bind any context resource specs using the specified shared resource context.\n    \n    Any already-bound context resources remain unchanged.  Additionally, any context\n    resources specified by a nested :json:schema:`KvStore.context` spec will be\n    created as specified, but won't be overridden by :py:param:`.context`.\n  transaction: Transaction to use for read/write operations.  By default, operations are\n    non-transactional.\n    \n    .. note::\n    \n       To perform transactional operations using a :py:obj:`KvStore` that was\n       previously opened without a transaction, use\n       :py:obj:`KvStore.with_transaction`.\n\n\nGroup:\n  Constructors\n\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='path', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='KvStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))",
                "definition": "@property\ndef path (arg0: KvStore) -> str: ...",
                "doc": "\nPath prefix within the base key-value store.\n\nExample:\n\n    >>> store = await ts.KvStore.open({\n    ...     'driver': 'gcs',\n    ...     'bucket': 'my-bucket',\n    ...     'path': 'path/to/object'\n    ... })\n    >>> store.spec()\n    KvStore.Spec({'bucket': 'my-bucket', 'driver': 'gcs', 'path': 'path/to/object'})\n    >>> store.path\n    'path/to/object'\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='read', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='KvStore', ctx=Load())), arg(arg='key', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[arg(arg='if_not_equal', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='staleness_bound', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Attribute(value=Name(id='KvStore', ctx=Load()), attr='ReadResult', ctx=Load()), ctx=Load()))",
                "definition": "def read(self: KvStore, key: str, *, if_not_equal: Optional[str] = None, staleness_bound: Optional[float] = None) -> Future[KvStore.ReadResult]: ...",
                "doc": "read(self: tensorstore.KvStore, key: str, *, if_not_equal: Optional[str] = None, staleness_bound: Optional[float] = None) -> tensorstore.Future[tensorstore.KvStore.ReadResult]\n\n\nReads the value of a single key.\n\nA missing key is not treated as an error; instead, a :py:obj:`.ReadResult` with\n:py:obj:`.ReadResult.state` set to :python:`'missing'` is returned.\n\nNote:\n\n  The behavior in the case of a missing key differs from that of\n  :py:obj:`.__getitem__`, which raises :py:obj:`KeyError` to indicate a missing\n  key.\n\nExample:\n\n    >>> store = await ts.KvStore.open({'driver': 'memory'})\n    >>> await store.write(b'a', b'value')\n    KvStore.TimestampedStorageGeneration(...)\n    >>> await store.read(b'a')\n    KvStore.ReadResult(state='value', value=b'value', stamp=KvStore.TimestampedStorageGeneration(...))\n    >>> store[b'a']\n    b'value'\n    >>> await store.read(b'b')\n    KvStore.ReadResult(state='missing', value=b'', stamp=KvStore.TimestampedStorageGeneration(...))\n    >>> store[b'b']\n    Traceback (most recent call last):\n        ...\n    KeyError...\n\n    >>> store[b'a'] = b'value'\n    >>> store[b'b'] = b'value'\n    >>> store.list().result()\n\nIf a :py:obj:`.transaction` is bound, the read reflects any writes made within\nthe transaction, and the commit of the transaction will fail if the value\nassociated with :py:param:`key` changes after the read due to external writes,\ni.e. consistent reads are guaranteed.\n\nArgs:\n\n  key: The key to read.  This is appended (without any separator) to the\n    existing :py:obj:`.path`, if any.\n\n  if_not_equal: If specified, the read is aborted if the generation associated\n    with :py:param:`key` matches :py:param:`if_not_equal`.  An aborted read due\n    to this condition is indicated by a :py:obj:`.ReadResult.state` of\n    :python:`'unspecified'`.  This may be useful for validating a cached value\n    cache validation at a higher level.\n\n  staleness_bound: Specifies a time in (fractional) seconds since the Unix\n    epoch.  If specified, data that is cached internally by the kvstore\n    implementation may be used without validation if not older than the\n    :py:param:`staleness_bound`.  Cached data older than\n    :py:param:`staleness_bound` must be validated before being returned.  A\n    value of :python:`float('inf')` indicates that the result must be current as\n    of the time the :py:obj:`.read` request was made, i.e. it is equivalent to\n    specifying a value of :python:`time.time()`.  A value of\n    :python:`float('-inf')` indicates that cached data may be returned without\n    validation irrespective of its age.\n\nReturns:\n  Future that resolves when the read operation completes.\n\nSee also:\n\n  - :py:obj:`.write`\n  - :py:obj:`.__getitem__`\n  - :py:obj:`.__setitem__`\n  - :py:obj:`.__delitem__`\n\nGroup:\n  I/O\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='spec', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='KvStore', ctx=Load()))], kwonlyargs=[arg(arg='retain_context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='unbind_context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()))",
                "definition": "def spec(self: KvStore, *, retain_context: Optional[bool] = None, unbind_context: Optional[bool] = None) -> KvStore.Spec: ...",
                "doc": "spec(self: tensorstore.KvStore, *, retain_context: Optional[bool] = None, unbind_context: Optional[bool] = None) -> tensorstore.KvStore.Spec\n\n\nSpec that may be used to re-open or re-create the key-value store.\n\nExample:\n\n    >>> kvstore = await ts.KvStore.open({'driver': 'memory', 'path': 'abc/'})\n    >>> kvstore.spec()\n    KvStore.Spec({'driver': 'memory', 'path': 'abc/'})\n    >>> kvstore.spec(unbind_context=True)\n    KvStore.Spec({'context': {'memory_key_value_store': {}}, 'driver': 'memory', 'path': 'abc/'})\n    >>> kvstore.spec(retain_context=True)\n    KvStore.Spec({\n      'context': {'memory_key_value_store': {}},\n      'driver': 'memory',\n      'memory_key_value_store': ['memory_key_value_store'],\n      'path': 'abc/',\n    })\n\nArgs:\n\n  retain_context: Retain all bound context resources (e.g. specific concurrency pools, specific\n    cache pools).\n    \n    The resultant :py:obj:`~tensorstore.KvStore.Spec` may be used to re-open the\n    :py:obj:`~tensorstore.KvStore` using the identical context resources.\n    \n    Specifying a value of :python:`False` has no effect.\n  unbind_context: Convert any bound context resources to context resource specs that fully capture\n    the graph of shared context resources and interdependencies.\n    \n    Re-binding/re-opening the resultant spec will result in a new graph of new\n    context resources that is isomorphic to the original graph of context resources.\n    The resultant spec will not refer to any external context resources;\n    consequently, binding it to any specific context will have the same effect as\n    binding it to a default context.\n    \n    Specifying a value of :python:`False` has no effect.\n\n\nGroup:\n  Accessors\n\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='transaction', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='KvStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Transaction', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef transaction (arg0: KvStore) -> Optional[Transaction]: ...",
                "doc": "\nTransaction bound to this key-value store.\n\nGroup:\n  Transactions\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='url', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='KvStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))",
                "definition": "@property\ndef url (arg0: KvStore) -> str: ...",
                "doc": "\n:json:schema:`URL representation<KvStoreUrl>` of the key-value store specification.\n\nExample:\n\n    >>> store = await ts.KvStore.open({\n    ...     'driver': 'gcs',\n    ...     'bucket': 'my-bucket',\n    ...     'path': 'path/to/object'\n    ... })\n    >>> store.url\n    'gs://my-bucket/path/to/object'\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='with_transaction', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='KvStore', ctx=Load())), arg(arg='transaction', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Transaction', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='KvStore', ctx=Load()))",
                "definition": "def with_transaction(self: KvStore, transaction: Optional[Transaction]) -> KvStore: ...",
                "doc": "with_transaction(self: tensorstore.KvStore, transaction: Optional[tensorstore.Transaction]) -> tensorstore.KvStore\n\nReturns a transaction-bound view of this key-value store.\n\nThe returned view may be used to perform transactional read/write operations.\n\nExample:\n\n    >>> store = await ts.KvStore.open({'driver': 'memory'})\n    >>> txn = ts.Transaction()\n    >>> await store.with_transaction(txn).write(b'a', b'value')\n    >>> (await store.with_transaction(txn).read(b'a')).value\n    b'value'\n    >>> await txn.commit_async()\n\nGroup:\n  Transactions\n\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='write', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='KvStore', ctx=Load())), arg(arg='key', annotation=Name(id='str', ctx=Load())), arg(arg='value', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='if_equal', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Attribute(value=Name(id='KvStore', ctx=Load()), attr='TimestampedStorageGeneration', ctx=Load()), ctx=Load()))",
                "definition": "def write(self: KvStore, key: str, value: Optional[str], *, if_equal: Optional[str] = None) -> Future[KvStore.TimestampedStorageGeneration]: ...",
                "doc": "write(self: tensorstore.KvStore, key: str, value: Optional[str], *, if_equal: Optional[str] = None) -> tensorstore.Future[tensorstore.KvStore.TimestampedStorageGeneration]\n\n\nWrites or deletes a single key.\n\nExample:\n\n    >>> store = await ts.KvStore.open({'driver': 'memory'})\n    >>> await store.write(b'a', b'value')\n    KvStore.TimestampedStorageGeneration(...)\n    >>> await store.read(b'a')\n    KvStore.ReadResult(state='value', value=b'value', stamp=KvStore.TimestampedStorageGeneration(...))\n    >>> await store.write(b'a', None)\n    KvStore.TimestampedStorageGeneration(...)\n    >>> await store.read(b'a')\n    KvStore.ReadResult(state='missing', value=b'', stamp=KvStore.TimestampedStorageGeneration(...))\n\nArgs:\n\n  key: Key to write/delete.  This is appended (without any separator) to the\n    existing :py:obj:`.path`, if any.\n\n  value: Value to store, or :py:obj:`None` to delete.\n\n  if_equal: If specified, indicates a conditional write operation.  The write is\n    performed only if the existing generation associated with :py:param:`key`\n    matches :py:param:`if_equal`.\n\nReturns:\n\n  - If no :py:obj:`.transaction` is specified, returns a :py:obj:`Future` that\n    resolves to the new storage generation for :py:param:`key` once the write\n    operation completes and durability is guaranteed (to the extent supported by\n    the :ref:`driver<key-value-store-drivers>`).\n\n  - If a :py:obj:`.transaction` is specified, returns a :py:obj:`Future` that\n    resolves to an empty storage generation once the write operation is recorded\n    in the transaction.  The write operation is not actually performed until the\n    transaction is committed.\n\nSee also:\n\n  - :py:obj:`.__setitem__`\n  - :py:obj:`.__delitem__`\n\nGroup:\n  I/O\n\n",
                "type": "function"
            }
        ],
        "definition": "<class 'tensorstore.KvStore'>",
        "doc": "\nKey-value store that maps an ordered set of byte string keys to byte string values.\n\nThis is used as the storage interface for most of the\n:ref:`TensorStore drivers<tensorstore-drivers>`.\n\nThe actual storage mechanism is determined by the\n:ref:`driver<key-value-store-drivers>`.\n\nExample:\n\n    >>> store = await ts.KvStore.open({'driver': 'memory'})\n    >>> await store.write(b'a', b'value')\n    KvStore.TimestampedStorageGeneration(...)\n    >>> await store.read(b'a')\n    KvStore.ReadResult(state='value', value=b'value', stamp=KvStore.TimestampedStorageGeneration(...))\n    >>> await store.read(b'b')\n    KvStore.ReadResult(state='missing', value=b'', stamp=KvStore.TimestampedStorageGeneration(...))\n    >>> await store.list()\n    [b'a']\n\nBy default, operations are non-transactional, but transactional operations are\nalso supported:\n\n    >>> txn = ts.Transaction()\n    >>> store.with_transaction(txn)[b'a']\n    b'value'\n    >>> store.with_transaction(txn)[b'a'] = b'new value'\n    >>> store.with_transaction(txn)[b'a']\n    b'new value'\n    >>> store[b'a']\n    b'value'\n    >>> txn.commit_sync()\n    >>> store[b'a']\n    b'new value'\n\nGroup:\n  Core\n\nClasses\n-------\n\nConstructors\n------------\n\nAccessors\n---------\n\nI/O\n---\n\nSynchronous I/O\n---------------\n\n",
        "type": "class"
    },
    "OpenMode": {
        "ast": "ClassDef(name='OpenMode', bases=[], keywords=[], body=[FunctionDef(name='assume_cached_metadata', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OpenMode', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='assume_metadata', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OpenMode', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='create', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OpenMode', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='delete_existing', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OpenMode', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='open', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OpenMode', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "FunctionDef(name='assume_cached_metadata', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OpenMode', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))",
                "definition": "@property\ndef assume_cached_metadata (arg0: OpenMode) -> bool: ...",
                "doc": "\nSkip reading the metadata when opening.\n\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='assume_metadata', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OpenMode', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))",
                "definition": "@property\ndef assume_metadata (arg0: OpenMode) -> bool: ...",
                "doc": "\nDon't access the stored metadata.\n\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='create', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OpenMode', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))",
                "definition": "@property\ndef create (arg0: OpenMode) -> bool: ...",
                "doc": "\nAllow creating a new TensorStore.\n\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='delete_existing', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OpenMode', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))",
                "definition": "@property\ndef delete_existing (arg0: OpenMode) -> bool: ...",
                "doc": "\nDelete any existing data before creating a new array.\n\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='open', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OpenMode', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))",
                "definition": "@property\ndef open (arg0: OpenMode) -> bool: ...",
                "doc": "\nAllow opening an existing TensorStore.\n\n\nGroup:\n  Accessors\n",
                "type": "property"
            }
        ],
        "definition": "<class 'tensorstore.OpenMode'>",
        "doc": "\nSpecifies the mode to use when opening a `TensorStore`.\n\nGroup:\n  Spec\n",
        "type": "class"
    },
    "OutputIndexMap": {
        "ast": "ClassDef(name='OutputIndexMap', bases=[], keywords=[], body=[FunctionDef(name='index_array', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OutputIndexMap', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load()), ctx=Load())), FunctionDef(name='index_range', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OutputIndexMap', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Dim', ctx=Load()), ctx=Load())), FunctionDef(name='input_dimension', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OutputIndexMap', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), FunctionDef(name='method', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OutputIndexMap', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='OutputIndexMethod', ctx=Load())), FunctionDef(name='offset', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OutputIndexMap', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='stride', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OutputIndexMap', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "FunctionDef(name='index_array', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OutputIndexMap', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef index_array (arg0: OutputIndexMap) -> Optional[numpy.typing.ArrayLike]: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='index_range', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OutputIndexMap', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Dim', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef index_range (arg0: OutputIndexMap) -> Optional[Dim]: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='input_dimension', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OutputIndexMap', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef input_dimension (arg0: OutputIndexMap) -> Optional[int]: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='method', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OutputIndexMap', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='OutputIndexMethod', ctx=Load()))",
                "definition": "@property\ndef method (arg0: OutputIndexMap) -> OutputIndexMethod: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='offset', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OutputIndexMap', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef offset (arg0: OutputIndexMap) -> int: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='stride', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OutputIndexMap', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef stride (arg0: OutputIndexMap) -> Optional[int]: ...",
                "doc": "",
                "type": "property"
            }
        ],
        "definition": "<class 'tensorstore.OutputIndexMap'>",
        "doc": "\nRepresents an output index map for an index transform.\n\nSee also:\n  - :py:obj:`IndexTransform.output`\n  - :py:obj:`OutputIndexMaps`\n  - :py:obj:`OutputIndexMethod`\n\nGroup:\n  Indexing\n",
        "type": "class"
    },
    "OutputIndexMaps": {
        "ast": "ClassDef(name='OutputIndexMaps', bases=[], keywords=[], body=[FunctionDef(name='rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OutputIndexMaps', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "FunctionDef(name='rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OutputIndexMaps', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef rank (arg0: OutputIndexMaps) -> int: ...",
                "doc": "Returns the output rank.",
                "type": "property"
            }
        ],
        "definition": "<class 'tensorstore.OutputIndexMaps'>",
        "doc": "\nView of the output index maps for an index transform.\n\nSee also:\n  - :py:obj:`IndexTransform.output`\n  - :py:obj:`OutputIndexMap`\n  - :py:obj:`OutputIndexMethod`\n\nGroup:\n  Indexing\n",
        "type": "class"
    },
    "OutputIndexMethod": {
        "ast": "ClassDef(name='OutputIndexMethod', bases=[], keywords=[], body=[Assign(targets=[Name(id='array', ctx=Store())], value=Attribute(value=Name(id='OutputIndexMethod', ctx=Load()), attr='array', ctx=Load())), Assign(targets=[Name(id='constant', ctx=Store())], value=Attribute(value=Name(id='OutputIndexMethod', ctx=Load()), attr='constant', ctx=Load())), FunctionDef(name='name', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='handle', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), Assign(targets=[Name(id='single_input_dimension', ctx=Store())], value=Attribute(value=Name(id='OutputIndexMethod', ctx=Load()), attr='single_input_dimension', ctx=Load())), FunctionDef(name='value', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OutputIndexMethod', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "Assign(targets=[Name(id='array', ctx=Store())], value=Attribute(value=Name(id='OutputIndexMethod', ctx=Load()), attr='array', ctx=Load()))",
                "definition": "OutputIndexMethod.array",
                "doc": "\nIndicates the :ref:`output index method<output-index-methods>` of an :py:class:`OutputIndexMap`.\n\nSee also:\n  - :py:obj:`IndexTransform.output`\n  - :py:obj:`OutputIndexMap`\n  - :py:obj:`OutputIndexMaps`\n\nGroup:\n  Indexing\n\n\n\nMembers:\n\n  constant\n\n  single_input_dimension\n\n  array",
                "type": "unknown"
            },
            {
                "ast": "Assign(targets=[Name(id='constant', ctx=Store())], value=Attribute(value=Name(id='OutputIndexMethod', ctx=Load()), attr='constant', ctx=Load()))",
                "definition": "OutputIndexMethod.constant",
                "doc": "\nIndicates the :ref:`output index method<output-index-methods>` of an :py:class:`OutputIndexMap`.\n\nSee also:\n  - :py:obj:`IndexTransform.output`\n  - :py:obj:`OutputIndexMap`\n  - :py:obj:`OutputIndexMaps`\n\nGroup:\n  Indexing\n\n\n\nMembers:\n\n  constant\n\n  single_input_dimension\n\n  array",
                "type": "unknown"
            },
            {
                "ast": "FunctionDef(name='name', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='handle', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))",
                "definition": "@property\ndef name(self: handle) -> str: ...",
                "doc": "name(self: handle) -> str\n",
                "type": "property"
            },
            {
                "ast": "Assign(targets=[Name(id='single_input_dimension', ctx=Store())], value=Attribute(value=Name(id='OutputIndexMethod', ctx=Load()), attr='single_input_dimension', ctx=Load()))",
                "definition": "OutputIndexMethod.single_input_dimension",
                "doc": "\nIndicates the :ref:`output index method<output-index-methods>` of an :py:class:`OutputIndexMap`.\n\nSee also:\n  - :py:obj:`IndexTransform.output`\n  - :py:obj:`OutputIndexMap`\n  - :py:obj:`OutputIndexMaps`\n\nGroup:\n  Indexing\n\n\n\nMembers:\n\n  constant\n\n  single_input_dimension\n\n  array",
                "type": "unknown"
            },
            {
                "ast": "FunctionDef(name='value', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='OutputIndexMethod', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef value (arg0: OutputIndexMethod) -> int: ...",
                "doc": "",
                "type": "property"
            }
        ],
        "definition": "<class 'tensorstore.OutputIndexMethod'>",
        "doc": "\nIndicates the :ref:`output index method<output-index-methods>` of an :py:class:`OutputIndexMap`.\n\nSee also:\n  - :py:obj:`IndexTransform.output`\n  - :py:obj:`OutputIndexMap`\n  - :py:obj:`OutputIndexMaps`\n\nGroup:\n  Indexing\n\n\n\nMembers:\n\n  constant\n\n  single_input_dimension\n\n  array",
        "type": "class"
    },
    "Promise": {
        "ast": "ClassDef(name='Promise', bases=[], keywords=[], body=[FunctionDef(name='new', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='Promise', ctx=Load()), Name(id='Future', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='set_exception', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Promise', ctx=Load())), arg(arg='exception', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='set_result', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Promise', ctx=Load())), arg(arg='result', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None))], decorator_list=[])",
        "children": [
            {
                "ast": "FunctionDef(name='new', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='Promise', ctx=Load()), Name(id='Future', ctx=Load())], ctx=Load()), ctx=Load()))",
                "definition": "def new() -> Tuple[Promise, Future]: ...",
                "doc": "new() -> Tuple[tensorstore.Promise, tensorstore.Future]\n\n\nCreates a linked promise and future pair.\n\nGroup:\n  Constructors\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='set_exception', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Promise', ctx=Load())), arg(arg='exception', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None))",
                "definition": "def set_exception(self: Promise, exception: object) -> None: ...",
                "doc": "set_exception(self: tensorstore.Promise, exception: object) -> None\n\n\nMarks the linked future as unsuccessfully completed with the specified error.\n\nExample:\n\n    >>> promise, future = ts.Promise.new()\n    >>> future.done()\n    False\n    >>> promise.set_exception(Exception(5))\n    >>> future.done()\n    True\n    >>> future.result()\n    Traceback (most recent call last):\n        ...\n    Exception: 5\n\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='set_result', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Promise', ctx=Load())), arg(arg='result', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None))",
                "definition": "def set_result(self: Promise, result: object) -> None: ...",
                "doc": "set_result(self: tensorstore.Promise, result: object) -> None\n\n\nMarks the linked future as successfully completed with the specified result.\n\nExample:\n\n    >>> promise, future = ts.Promise.new()\n    >>> future.done()\n    False\n    >>> promise.set_result(5)\n    >>> future.done()\n    True\n    >>> future.result()\n    5\n\n\n",
                "type": "function"
            }
        ],
        "definition": "<class 'tensorstore.Promise'>",
        "doc": "\nHandle for *producing* the result of an asynchronous operation.\n\nA promise represents the producer interface corresponding to a\n:py:class:`Future`, and may be used to signal the completion of an asynchronous\noperation.\n\n    >>> promise, future = ts.Promise.new()\n    >>> future.done()\n    False\n    >>> promise.set_result(5)\n    >>> future.done()\n    True\n    >>> future.result()\n    5\n\nSee also:\n  - :py:class:`Future`\n\nGroup:\n  Asynchronous support\n",
        "type": "class"
    },
    "Schema": {
        "ast": "ClassDef(name='Schema', bases=[], keywords=[], body=[FunctionDef(name='T', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Schema', ctx=Load())), FunctionDef(name='chunk_layout', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='ChunkLayout', ctx=Load())), FunctionDef(name='codec', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='CodecSpec', ctx=Load()), ctx=Load())), FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Schema', ctx=Load())), FunctionDef(name='dimension_units', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Unit', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='domain', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='IndexDomain', ctx=Load()), ctx=Load())), FunctionDef(name='dtype', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='dtype', ctx=Load()), ctx=Load())), FunctionDef(name='fill_value', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load()), ctx=Load())), FunctionDef(name='label', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Schema', ctx=Load()), attr='_Label', ctx=Load())), FunctionDef(name='mark_bounds_implicit', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Schema', ctx=Load()), attr='_MarkBoundsImplicit', ctx=Load())), FunctionDef(name='ndim', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), FunctionDef(name='oindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Schema', ctx=Load()), attr='_Oindex', ctx=Load())), FunctionDef(name='origin', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), FunctionDef(name='shape', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='size', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Schema', ctx=Load())), arg(arg='include_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='translate_backward_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Schema', ctx=Load()), attr='_TranslateBackwardBy', ctx=Load())), FunctionDef(name='translate_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Schema', ctx=Load()), attr='_TranslateBy', ctx=Load())), FunctionDef(name='translate_to', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Schema', ctx=Load()), attr='_TranslateTo', ctx=Load())), FunctionDef(name='transpose', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Schema', ctx=Load())), arg(arg='axes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='DimSelectionLike', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Schema', ctx=Load())), FunctionDef(name='update', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[arg(arg='rank', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='dtype', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='dtype', ctx=Load()), ctx=Load())), arg(arg='domain', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='IndexDomain', ctx=Load()), ctx=Load())), arg(arg='shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='chunk_layout', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='ChunkLayout', ctx=Load()), ctx=Load())), arg(arg='codec', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='CodecSpec', ctx=Load()), ctx=Load())), arg(arg='fill_value', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load()), ctx=Load())), arg(arg='dimension_units', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Unit', ctx=Load()), Name(id='str', ctx=Load()), Name(id='Real', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='Real', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='schema', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Schema', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='vindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Schema', ctx=Load()), attr='_Vindex', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "FunctionDef(name='T', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Schema', ctx=Load()))",
                "definition": "@property\ndef T (arg0: Schema) -> Schema: ...",
                "doc": "View with transposed domain (reversed dimension order).\n\nThis is equivalent to: :python:`self[ts.d[::-1].transpose[:]]`.\n\nSee also:\n  - `.transpose`\n  - `tensorstore.DimExpression.transpose`\n\nGroup:\n  Indexing\n",
                "type": "property"
            },
            {
                "definition": "<class 'tensorstore.Schema._Label'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.Schema._MarkBoundsImplicit'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.Schema._Oindex'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.Schema._TranslateBackwardBy'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.Schema._TranslateBy'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.Schema._TranslateTo'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.Schema._Vindex'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "ast": "FunctionDef(name='chunk_layout', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='ChunkLayout', ctx=Load()))",
                "definition": "@property\ndef chunk_layout (arg0: Schema) -> ChunkLayout: ...",
                "doc": "\nChunk layout constraints specified by the schema.\n\nExample:\n\n  >>> schema = ts.Schema(chunk_layout=ts.ChunkLayout(inner_order=[0, 1, 2]))\n  >>> schema.update(chunk_layout=ts.ChunkLayout(grid_origin=[0, 0, 0]))\n  >>> schema.chunk_layout\n  ChunkLayout({'grid_origin': [0, 0, 0], 'inner_order': [0, 1, 2]})\n\nNote:\n\n  Each access to this property returns a new copy of the chunk layout.\n  Modifying the returned chunk layout (e.g. by calling\n  :py:obj:`tensorstore.ChunkLayout.update`) will not affect the schema object\n  from which it was obtained.\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='codec', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='CodecSpec', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef codec (arg0: Schema) -> Optional[CodecSpec]: ...",
                "doc": "\nCodec constraints specified by the schema.\n\nExample:\n\n  >>> schema = ts.Schema()\n  >>> print(schema.codec)\n  None\n  >>> schema.update(codec=ts.CodecSpec({\n  ...     'driver': 'zarr',\n  ...     'compressor': None\n  ... }))\n  >>> schema.update(codec=ts.CodecSpec({'driver': 'zarr', 'filters': None}))\n  >>> schema.codec\n  CodecSpec({'compressor': None, 'driver': 'zarr', 'filters': None})\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Schema', ctx=Load()))",
                "definition": "def copy(self: Schema) -> Schema: ...",
                "doc": "copy(self: tensorstore.Schema) -> tensorstore.Schema\n\n\nReturns a copy of the schema.\n\nExample:\n\n  >>> a = ts.Schema(dtype=ts.uint8)\n  >>> b = a.copy()\n  >>> a.update(rank=2)\n  >>> b.update(rank=3)\n  >>> a\n  Schema({'dtype': 'uint8', 'rank': 2})\n  >>> b\n  Schema({'dtype': 'uint8', 'rank': 3})\n\nGroup:\n  Accessors\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='dimension_units', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Unit', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef dimension_units (arg0: Schema) -> Optional[Tuple[Optional[Unit], ...]]: ...",
                "doc": "\nPhysical units of each dimension of the domain.\n\nThe *physical unit* for a dimension is the physical quantity corresponding to a\nsingle index increment along each dimension.\n\nA value of :python:`None` indicates that the unit is unknown/unconstrained.  A\ndimension-less quantity is indicated by a unit of :python:`ts.Unit(1, \"\")`.\n\nWhen creating a new TensorStore, the specified units may be stored as part of\nthe metadata.\n\nWhen opening an existing TensorStore, the specified units serve as a constraint,\nto ensure the units are as expected.  Additionally, for drivers like\n:ref:`neuroglancer_precomputed<neuroglancer-precomputed-driver>` that support\nmultiple scales, the desired scale can be selected by specifying constraints on\nthe units.\n\nExample:\n\n  >>> schema = ts.Schema()\n  >>> print(schema.dimension_units)\n  None\n  >>> schema.update(rank=3)\n  >>> schema.dimension_units\n  (None, None, None)\n  >>> schema.update(dimension_units=['3nm', None, ''])\n  >>> schema.dimension_units\n  (Unit(3, \"nm\"), None, Unit(1, \"\"))\n  >>> schema.update(dimension_units=[None, '4nm', None])\n  >>> schema.dimension_units\n  (Unit(3, \"nm\"), Unit(4, \"nm\"), Unit(1, \"\"))\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='domain', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='IndexDomain', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef domain (arg0: Schema) -> Optional[IndexDomain]: ...",
                "doc": "\nDomain of the schema, or `None` if unspecified.\n\nExample:\n\n  >>> schema = ts.Schema()\n  >>> print(schema.domain)\n  None\n  >>> schema.update(domain=ts.IndexDomain(labels=['x', 'y', 'z']))\n  >>> schema.update(domain=ts.IndexDomain(shape=[100, 200, 300]))\n  >>> schema.domain\n  { \"x\": [0, 100), \"y\": [0, 200), \"z\": [0, 300) }\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='dtype', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='dtype', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef dtype (arg0: Schema) -> Optional[dtype]: ...",
                "doc": "\nData type, or :python:`None` if unspecified.\n\nExample:\n\n  >>> schema = ts.Schema(rank=3)\n  >>> print(spec.dtype)\n  None\n\n  >>> spec = ts.Schema(dtype=ts.uint8, rank=3)\n  >>> spec.dtype\n  dtype(\"uint8\")\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='fill_value', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef fill_value (arg0: Schema) -> Optional[numpy.typing.ArrayLike]: ...",
                "doc": "\nFill value specified by the schema.\n\nExample:\n\n  >>> schema = ts.Schema()\n  >>> print(schema.fill_value)\n  None\n  >>> schema.update(fill_value=42)\n  >>> schema.fill_value\n  array(42)\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='label', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Schema', ctx=Load()), attr='_Label', ctx=Load()))",
                "definition": "@property\ndef label (arg0: object) -> Schema._Label: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='mark_bounds_implicit', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Schema', ctx=Load()), attr='_MarkBoundsImplicit', ctx=Load()))",
                "definition": "@property\ndef mark_bounds_implicit (arg0: object) -> Schema._MarkBoundsImplicit: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='ndim', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef ndim (arg0: Schema) -> Optional[int]: ...",
                "doc": "\nAlias for :py:obj:`.rank`.\n\nExample:\n\n  >>> schema = ts.Schema(rank=3)\n  >>> schema.ndim\n  3\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='oindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Schema', ctx=Load()), attr='_Oindex', ctx=Load()))",
                "definition": "@property\ndef oindex (arg0: object) -> Schema._Oindex: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='origin', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef origin (arg0: Schema) -> Tuple[int, ...]: ...",
                "doc": "Inclusive lower bound of the domain.\n\nThis is equivalent to :python:`self.domain.origin`.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef rank (arg0: Schema) -> Optional[int]: ...",
                "doc": "\nRank of the schema, or `None` if unspecified.\n\nExample:\n\n  >>> schema = ts.Schema(dtype=ts.uint8)\n  >>> print(schema.rank)\n  None\n  >>> schema.update(chunk_layout=ts.ChunkLayout(grid_origin=[0, 1, 2]))\n  >>> schema.rank\n  3\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='shape', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef shape (arg0: Schema) -> Tuple[int, ...]: ...",
                "doc": "Shape of the domain.\n\nThis is equivalent to :python:`self.domain.shape`.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='size', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef size (arg0: Schema) -> int: ...",
                "doc": "Total number of elements in the domain.\n\nThis is equivalent to :python:`self.domain.size`.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Schema', ctx=Load())), arg(arg='include_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load()))",
                "definition": "def to_json(self: Schema, include_defaults: bool = False) -> Any: ...",
                "doc": "to_json(self: tensorstore.Schema, include_defaults: bool = False) -> Any\n\n\nConverts to the :json:schema:`JSON representation<Schema>`.\n\nExample:\n\n  >>> schema = ts.Schema(dtype=ts.uint8,\n  ...                    chunk_layout=ts.ChunkLayout(grid_origin=[0, 0, 0],\n  ...                                                inner_order=[0, 2, 1]))\n  >>> schema.to_json()\n  {'chunk_layout': {'grid_origin': [0, 0, 0], 'inner_order': [0, 2, 1]},\n   'dtype': 'uint8',\n   'rank': 3}\n\nGroup:\n  Accessors\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='translate_backward_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Schema', ctx=Load()), attr='_TranslateBackwardBy', ctx=Load()))",
                "definition": "@property\ndef translate_backward_by (arg0: object) -> Schema._TranslateBackwardBy: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='translate_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Schema', ctx=Load()), attr='_TranslateBy', ctx=Load()))",
                "definition": "@property\ndef translate_by (arg0: object) -> Schema._TranslateBy: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='translate_to', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Schema', ctx=Load()), attr='_TranslateTo', ctx=Load()))",
                "definition": "@property\ndef translate_to (arg0: object) -> Schema._TranslateTo: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='transpose', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Schema', ctx=Load())), arg(arg='axes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='DimSelectionLike', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Schema', ctx=Load()))",
                "definition": "def transpose(self: Schema, axes: Optional[DimSelectionLike] = None) -> Schema: ...",
                "doc": "transpose(self: tensorstore.Schema, axes: Optional[DimSelectionLike] = None) -> tensorstore.Schema\n\n\nReturns a view with a transposed domain.\n\nThis is equivalent to :python:`self[ts.d[axes].transpose[:]]`.\n\nArgs:\n\n  axes: Specifies the existing dimension corresponding to each dimension of the\n    new view.  Dimensions may be specified either by index or label.  Specifying\n    `None` is equivalent to specifying :python:`[rank-1, ..., 0]`, which\n    reverses the dimension order.\n\nRaises:\n\n  ValueError: If :py:param:`.axes` does not specify a valid permutation.\n\nSee also:\n  - `tensorstore.DimExpression.transpose`\n  - :py:obj:`.T`\n\nGroup:\n  Indexing\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='update', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Schema', ctx=Load()))], kwonlyargs=[arg(arg='rank', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='dtype', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='dtype', ctx=Load()), ctx=Load())), arg(arg='domain', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='IndexDomain', ctx=Load()), ctx=Load())), arg(arg='shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='chunk_layout', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='ChunkLayout', ctx=Load()), ctx=Load())), arg(arg='codec', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='CodecSpec', ctx=Load()), ctx=Load())), arg(arg='fill_value', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load()), ctx=Load())), arg(arg='dimension_units', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Unit', ctx=Load()), Name(id='str', ctx=Load()), Name(id='Real', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='Real', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='schema', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Schema', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None))",
                "definition": "def update(self: Schema, *, rank: Optional[int] = None, dtype: Optional[dtype] = None, domain: Optional[IndexDomain] = None, shape: Optional[Sequence[int]] = None, chunk_layout: Optional[ChunkLayout] = None, codec: Optional[CodecSpec] = None, fill_value: Optional[numpy.typing.ArrayLike] = None, dimension_units: Optional[Sequence[Optional[Union[Unit, str, Real, Tuple[Real, str]]]]] = None, schema: Optional[Schema] = None) -> None: ...",
                "doc": "update(self: tensorstore.Schema, *, rank: Optional[int] = None, dtype: Optional[tensorstore.dtype] = None, domain: Optional[tensorstore.IndexDomain] = None, shape: Optional[Sequence[int]] = None, chunk_layout: Optional[tensorstore.ChunkLayout] = None, codec: Optional[tensorstore.CodecSpec] = None, fill_value: Optional[numpy.typing.ArrayLike] = None, dimension_units: Optional[Sequence[Optional[Union[tensorstore.Unit, str, Real, Tuple[Real, str]]]]] = None, schema: Optional[tensorstore.Schema] = None) -> None\n\n\nAdds additional constraints.\n\nExample:\n\n  >>> schema = ts.Schema(rank=3)\n  >>> schema\n  Schema({'rank': 3})\n  >>> schema.update(dtype=ts.uint8)\n  >>> schema\n  Schema({'dtype': 'uint8', 'rank': 3})\n\nArgs:\n  rank: Constrains the rank of the TensorStore.  If there is an index transform, the\n    rank constraint must match the rank of the *input* space.\n  dtype: Constrains the data type of the TensorStore.  If a data type has already been\n    set, it is an error to specify a different data type.\n  domain: Constrains the domain of the TensorStore.  If there is an existing\n    domain, the specified domain is merged with it as follows:\n    \n    1. The rank must match the existing rank.\n    \n    2. All bounds must match, except that a finite or explicit bound is permitted to\n       match an infinite and implicit bound, and takes precedence.\n    \n    3. If both the new and existing domain specify non-empty labels for a dimension,\n       the labels must be equal.  If only one of the domains specifies a non-empty\n       label for a dimension, the non-empty label takes precedence.\n    \n    Note that if there is an index transform, the domain must match the *input*\n    space, not the output space.\n  shape: Constrains the shape and origin of the TensorStore.  Equivalent to specifying a\n    :py:param:`domain` of :python:`ts.IndexDomain(shape=shape)`.\n    \n    .. note::\n    \n       This option also constrains the origin of all dimensions to be zero.\n  chunk_layout: Constrains the chunk layout.  If there is an existing chunk layout constraint,\n    the constraints are merged.  If the constraints are incompatible, an error\n    is raised.\n  codec: Constrains the codec.  If there is an existing codec constraint, the constraints\n    are merged.  If the constraints are incompatible, an error is raised.\n  fill_value: Specifies the fill value for positions that have not been written.\n    \n    The fill value data type must be convertible to the actual data type, and the\n    shape must be :ref:`broadcast-compatible<index-domain-alignment>` with the\n    domain.\n    \n    If an existing fill value has already been set as a constraint, it is an\n    error to specify a different fill value (where the comparison is done after\n    normalization by broadcasting).\n  dimension_units: Specifies the physical units of each dimension of the domain.\n    \n    The *physical unit* for a dimension is the physical quantity corresponding to a\n    single index increment along each dimension.\n    \n    A value of :python:`None` indicates that the unit is unknown.  A dimension-less\n    quantity can be indicated by a unit of :python:`\"\"`.\n  schema: Additional schema constraints to merge with existing constraints.\n\n\nGroup:\n  Mutators\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='vindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Schema', ctx=Load()), attr='_Vindex', ctx=Load()))",
                "definition": "@property\ndef vindex (arg0: object) -> Schema._Vindex: ...",
                "doc": "",
                "type": "property"
            }
        ],
        "definition": "<class 'tensorstore.Schema'>",
        "doc": "\nDriver-independent options for defining a TensorStore schema.\n\nGroup:\n  Spec\n",
        "type": "class"
    },
    "Spec": {
        "ast": "ClassDef(name='Spec', bases=[], keywords=[], body=[FunctionDef(name='T', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Spec', ctx=Load())), FunctionDef(name='base', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Spec', ctx=Load()), ctx=Load())), FunctionDef(name='chunk_layout', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='ChunkLayout', ctx=Load())), FunctionDef(name='codec', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='CodecSpec', ctx=Load()), ctx=Load())), FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Spec', ctx=Load())), FunctionDef(name='dimension_units', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Unit', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='domain', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='IndexDomain', ctx=Load()), ctx=Load())), FunctionDef(name='dtype', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='dtype', ctx=Load()), ctx=Load())), FunctionDef(name='fill_value', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load()), ctx=Load())), FunctionDef(name='kvstore', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()), ctx=Load())), FunctionDef(name='label', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Spec', ctx=Load()), attr='_Label', ctx=Load())), FunctionDef(name='mark_bounds_implicit', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Spec', ctx=Load()), attr='_MarkBoundsImplicit', ctx=Load())), FunctionDef(name='ndim', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), FunctionDef(name='oindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Spec', ctx=Load()), attr='_Oindex', ctx=Load())), FunctionDef(name='open_mode', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='OpenMode', ctx=Load())), FunctionDef(name='origin', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), FunctionDef(name='schema', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Schema', ctx=Load())), FunctionDef(name='shape', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='size', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Spec', ctx=Load())), arg(arg='include_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='transform', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='IndexTransform', ctx=Load()), ctx=Load())), FunctionDef(name='translate_backward_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Spec', ctx=Load()), attr='_TranslateBackwardBy', ctx=Load())), FunctionDef(name='translate_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Spec', ctx=Load()), attr='_TranslateBy', ctx=Load())), FunctionDef(name='translate_to', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Spec', ctx=Load()), attr='_TranslateTo', ctx=Load())), FunctionDef(name='transpose', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Spec', ctx=Load())), arg(arg='axes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='DimSelectionLike', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Spec', ctx=Load())), FunctionDef(name='update', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[arg(arg='open_mode', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='OpenMode', ctx=Load()), ctx=Load())), arg(arg='open', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='create', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='delete_existing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='assume_metadata', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='assume_cached_metadata', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='unbind_context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='strip_context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Context', ctx=Load()), ctx=Load())), arg(arg='kvstore', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()), ctx=Load())), arg(arg='rank', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='dtype', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='dtype', ctx=Load()), ctx=Load())), arg(arg='domain', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='IndexDomain', ctx=Load()), ctx=Load())), arg(arg='shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='chunk_layout', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='ChunkLayout', ctx=Load()), ctx=Load())), arg(arg='codec', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='CodecSpec', ctx=Load()), ctx=Load())), arg(arg='fill_value', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load()), ctx=Load())), arg(arg='dimension_units', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Unit', ctx=Load()), Name(id='str', ctx=Load()), Name(id='Real', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='Real', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='schema', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Schema', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='vindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Spec', ctx=Load()), attr='_Vindex', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "FunctionDef(name='T', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Spec', ctx=Load()))",
                "definition": "@property\ndef T (arg0: Spec) -> Spec: ...",
                "doc": "View with transposed domain (reversed dimension order).\n\nThis is equivalent to: :python:`self[ts.d[::-1].transpose[:]]`.\n\nSee also:\n  - `.transpose`\n  - `tensorstore.DimExpression.transpose`\n\nGroup:\n  Indexing\n",
                "type": "property"
            },
            {
                "definition": "<class 'tensorstore.Spec._Label'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.Spec._MarkBoundsImplicit'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.Spec._Oindex'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.Spec._TranslateBackwardBy'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.Spec._TranslateBy'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.Spec._TranslateTo'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.Spec._Vindex'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "ast": "FunctionDef(name='base', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Spec', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef base (arg0: Spec) -> Optional[Spec]: ...",
                "doc": "\n\nSpec of the underlying `TensorStore`, if this is an adapter of a single\nunderlying `TensorStore`.\n\nOtherwise, equal to :python:`None`.\n\nDrivers that support this method include:\n\n- :ref:`driver/cast`\n- :ref:`driver/downsample`\n\nExample:\n\n  >>> spec = ts.Spec({\n  ...     'driver': 'zarr',\n  ...     'kvstore': 'memory://',\n  ... })\n  >>> spec.update(shape=[100, 200], dtype=ts.uint32)\n  >>> cast_spec = ts.cast(spec, ts.float32)\n  >>> cast_spec\n  Spec({\n    'base': {\n      'driver': 'zarr',\n      'dtype': 'uint32',\n      'kvstore': {'driver': 'memory'},\n      'schema': {\n        'domain': {'exclusive_max': [100, 200], 'inclusive_min': [0, 0]},\n      },\n    },\n    'driver': 'cast',\n    'dtype': 'float32',\n    'transform': {\n      'input_exclusive_max': [[100], [200]],\n      'input_inclusive_min': [0, 0],\n    },\n  })\n  >>> cast_spec[30:40, 20:25].base\n  Spec({\n    'driver': 'zarr',\n    'dtype': 'uint32',\n    'kvstore': {'driver': 'memory'},\n    'schema': {'domain': {'exclusive_max': [100, 200], 'inclusive_min': [0, 0]}},\n    'transform': {\n      'input_exclusive_max': [40, 25],\n      'input_inclusive_min': [30, 20],\n    },\n  })\n  >>> downsampled_spec = ts.downsample(spec,\n  ...                                  downsample_factors=[2, 4],\n  ...                                  method='mean')\n  >>> downsampled_spec\n  Spec({\n    'base': {\n      'driver': 'zarr',\n      'kvstore': {'driver': 'memory'},\n      'schema': {\n        'domain': {'exclusive_max': [100, 200], 'inclusive_min': [0, 0]},\n      },\n      'transform': {\n        'input_exclusive_max': [[100], [200]],\n        'input_inclusive_min': [0, 0],\n      },\n    },\n    'downsample_factors': [2, 4],\n    'downsample_method': 'mean',\n    'driver': 'downsample',\n    'dtype': 'uint32',\n    'transform': {\n      'input_exclusive_max': [[50], [50]],\n      'input_inclusive_min': [0, 0],\n    },\n  })\n  >>> downsampled_spec[30:40, 20:25].base\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='chunk_layout', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='ChunkLayout', ctx=Load()))",
                "definition": "@property\ndef chunk_layout (arg0: Spec) -> ChunkLayout: ...",
                "doc": "\n\nEffective :ref:`chunk layout<chunk-layout>`, including any constraints implied\nby driver-specific options.\n\nExample:\n\n  >>> spec = ts.Spec({\n  ...     'driver': 'zarr',\n  ...     'kvstore': {\n  ...         'driver': 'memory'\n  ...     },\n  ...     'metadata': {\n  ...         'chunks': [100, 200, 300],\n  ...         'order': 'C'\n  ...     }\n  ... })\n  >>> spec.chunk_layout\n  ChunkLayout({})\n\nNote:\n\n  This does not perform any I/O.  Only directly-specified constraints are\n  included.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='codec', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='CodecSpec', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef codec (arg0: Spec) -> Optional[CodecSpec]: ...",
                "doc": "\n\nEffective :ref:`codec<codec>`, including any constraints implied\nby driver-specific options.\n\nExample:\n\n  >>> spec = ts.Spec({\n  ...     'driver': 'zarr',\n  ...     'kvstore': {\n  ...         'driver': 'memory'\n  ...     },\n  ...     'metadata': {\n  ...         'compressor': None,\n  ...     }\n  ... })\n  >>> spec.codec\n  CodecSpec({'compressor': None, 'driver': 'zarr'})\n\nNote:\n\n  This does not perform any I/O.  Only directly-specified constraints are\n  included.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Spec', ctx=Load()))",
                "definition": "def copy(self: Spec) -> Spec: ...",
                "doc": "copy(self: tensorstore.Spec) -> tensorstore.Spec\n\n\nReturns a copy of the spec.\n\nExample:\n\n  >>> a = ts.Spec({'driver': 'n5', 'kvstore': {'driver': 'memory'}})\n  >>> b = a.copy()\n  >>> a.update(dtype=ts.uint8)\n  >>> b.update(dtype=ts.uint16)\n  >>> a\n  Spec({'driver': 'n5', 'dtype': 'uint8', 'kvstore': {'driver': 'memory'}})\n  >>> b\n  Spec({'driver': 'n5', 'dtype': 'uint16', 'kvstore': {'driver': 'memory'}})\n\nGroup:\n  Accessors\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='dimension_units', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Unit', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef dimension_units (arg0: Spec) -> Optional[Tuple[Optional[Unit], ...]]: ...",
                "doc": "\n\nEffective physical units of each dimension of the domain, including any\nconstraints implied by driver-specific options.\n\nExample:\n\n  >>> spec = ts.Spec({\n  ...     'driver': 'n5',\n  ...     'kvstore': {\n  ...         'driver': 'memory'\n  ...     },\n  ...     'metadata': {\n  ...         'units': ['nm', 'nm', 'um'],\n  ...         'resolution': [200, 300, 1],\n  ...     }\n  ... })\n  >>> spec.dimension_units\n  (Unit(200, \"nm\"), Unit(300, \"nm\"), Unit(1, \"um\"))\n\nNote:\n\n  This does not perform any I/O.  Only directly-specified constraints are\n  included.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='domain', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='IndexDomain', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef domain (arg0: Spec) -> Optional[IndexDomain]: ...",
                "doc": "\n\nEffective :ref:`index domain<index-domain>`, including any constraints implied\nby driver-specific options.\n\nExample:\n\n  >>> spec = ts.Spec({\n  ...     'driver': 'zarr',\n  ...     'kvstore': {\n  ...         'driver': 'memory'\n  ...     },\n  ...     'metadata': {\n  ...         'dtype': '<u2',\n  ...         'shape': [1000, 2000, 3000],\n  ...     }\n  ... })\n  >>> spec.domain\n  { [0, 1000*), [0, 2000*), [0, 3000*) }\n\nNote:\n\n  This does not perform any I/O.  Only directly-specified constraints are\n  included.\n\nGroup:\n  Accessors\n\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='dtype', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='dtype', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef dtype (arg0: Spec) -> Optional[dtype]: ...",
                "doc": "\nData type, or :python:`None` if unspecified.\n\nExample:\n\n  >>> spec = ts.Spec({'driver': 'n5', 'kvstore': {'driver': 'memory'}})\n  >>> print(spec.dtype)\n  None\n\n  >>> spec = ts.Spec({\n  ...     'driver': 'n5',\n  ...     'kvstore': {\n  ...         'driver': 'memory'\n  ...     },\n  ...     'metadata': {\n  ...         'dataType': 'uint8'\n  ...     }\n  ... })\n  >>> spec.dtype\n  dtype(\"uint8\")\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='fill_value', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef fill_value (arg0: Spec) -> Optional[numpy.typing.ArrayLike]: ...",
                "doc": "\n\nEffective fill value, including any constraints implied by driver-specific\noptions.\n\nExample:\n\n  >>> spec = ts.Spec({\n  ...     'driver': 'zarr',\n  ...     'kvstore': {\n  ...         'driver': 'memory'\n  ...     },\n  ...     'metadata': {\n  ...         'compressor': None,\n  ...         'dtype': '<f4',\n  ...         'fill_value': 42,\n  ...     }\n  ... })\n  >>> spec.fill_value\n  array(42., dtype=float32)\n\nNote:\n\n  This does not perform any I/O.  Only directly-specified constraints are\n  included.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='kvstore', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef kvstore (arg0: Spec) -> Optional[KvStore.Spec]: ...",
                "doc": "\n\nSpec of the associated key-value store used as the underlying storage.\n\nEqual to :python:`None` if the driver does not use a key-value store or the\nkey-value store has not been specified.\n\nExample:\n\n  >>> spec = ts.Spec({\n  ...     'driver': 'n5',\n  ...     'kvstore': {\n  ...         'driver': 'memory',\n  ...         'path': 'abc/',\n  ...     },\n  ... })\n  >>> spec.kvstore\n  KvStore.Spec({'driver': 'memory', 'path': 'abc/'})\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='label', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Spec', ctx=Load()), attr='_Label', ctx=Load()))",
                "definition": "@property\ndef label (arg0: object) -> Spec._Label: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='mark_bounds_implicit', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Spec', ctx=Load()), attr='_MarkBoundsImplicit', ctx=Load()))",
                "definition": "@property\ndef mark_bounds_implicit (arg0: object) -> Spec._MarkBoundsImplicit: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='ndim', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef ndim (arg0: Spec) -> Optional[int]: ...",
                "doc": "\nAlias for :py:obj:`.rank`.\n\nExample:\n\n  >>> spec = ts.Spec({'driver': 'n5', 'kvstore': {'driver': 'memory'}})\n  >>> print(spec.ndim)\n  None\n\n  >>> spec = ts.Spec({\n  ...     'driver': 'n5',\n  ...     'kvstore': {\n  ...         'driver': 'memory'\n  ...     },\n  ...     'metadata': {\n  ...         'dimensions': [100, 200]\n  ...     }\n  ... })\n  >>> spec.ndim\n  2\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='oindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Spec', ctx=Load()), attr='_Oindex', ctx=Load()))",
                "definition": "@property\ndef oindex (arg0: object) -> Spec._Oindex: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='open_mode', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='OpenMode', ctx=Load()))",
                "definition": "@property\ndef open_mode (arg0: Spec) -> OpenMode: ...",
                "doc": "\nOpen mode with which the driver will be opened.\n\nIf not applicable, equal to :python:`OpenMode()`.\n\nExample:\n\n  >>> spec = ts.Spec({'driver': 'zarr', 'kvstore': 'memory://'})\n  >>> spec.open_mode\n  OpenMode(open=True)\n  >>> spec.update(create=True, delete_existing=True)\n  >>> spec.open_mode\n  OpenMode(create=True, delete_existing=True)\n  >>> spec.update(open_mode=ts.OpenMode(open=True, create=True))\n  >>> spec.open_mode\n  OpenMode(open=True, create=True)\n\n.. note::\n\n   This is a read-only accessor.  Mutating the returned `OpenMode` object does\n   not affect this `Spec` object.  To change the open mode, use `.update`.\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='origin', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef origin (arg0: Spec) -> Tuple[int, ...]: ...",
                "doc": "Inclusive lower bound of the domain.\n\nThis is equivalent to :python:`self.domain.origin`.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef rank (arg0: Spec) -> Optional[int]: ...",
                "doc": "\nReturns the rank of the domain, or `None` if unspecified.\n\nExample:\n\n  >>> spec = ts.Spec({'driver': 'n5', 'kvstore': {'driver': 'memory'}})\n  >>> print(spec.rank)\n  None\n\n  >>> spec = ts.Spec({\n  ...     'driver': 'n5',\n  ...     'kvstore': {\n  ...         'driver': 'memory'\n  ...     },\n  ...     'metadata': {\n  ...         'dimensions': [100, 200]\n  ...     }\n  ... })\n  >>> spec.rank\n  2\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='schema', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Schema', ctx=Load()))",
                "definition": "@property\ndef schema (arg0: Spec) -> Schema: ...",
                "doc": "\nEffective :ref:`schema<schema>`, including any constraints implied by driver-specific options.\n\nExample:\n\n  >>> spec = ts.Spec({\n  ...     'driver': 'zarr',\n  ...     'kvstore': {\n  ...         'driver': 'memory'\n  ...     },\n  ...     'metadata': {\n  ...         'dtype': '<u2',\n  ...         'chunks': [100, 200, 300],\n  ...         'shape': [1000, 2000, 3000],\n  ...         'order': 'C'\n  ...     }\n  ... })\n  >>> spec.schema\n  Schema({\n    'chunk_layout': {\n      'grid_origin': [0, 0, 0],\n      'inner_order': [0, 1, 2],\n      'read_chunk': {'shape': [100, 200, 300]},\n      'write_chunk': {'shape': [100, 200, 300]},\n    },\n    'codec': {'driver': 'zarr'},\n    'domain': {\n      'exclusive_max': [[1000], [2000], [3000]],\n      'inclusive_min': [0, 0, 0],\n    },\n    'dtype': 'uint16',\n    'rank': 3,\n  })\n\nNote:\n\n  This does not perform any I/O.  Only directly-specified constraints are\n  included.\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='shape', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef shape (arg0: Spec) -> Tuple[int, ...]: ...",
                "doc": "Shape of the domain.\n\nThis is equivalent to :python:`self.domain.shape`.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='size', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef size (arg0: Spec) -> int: ...",
                "doc": "Total number of elements in the domain.\n\nThis is equivalent to :python:`self.domain.size`.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Spec', ctx=Load())), arg(arg='include_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load()))",
                "definition": "def to_json(self: Spec, include_defaults: bool = False) -> Any: ...",
                "doc": "to_json(self: tensorstore.Spec, include_defaults: bool = False) -> Any\n\n\nConverts to the :json:schema:`JSON representation<TensorStore>`.\n\nExample:\n\n  >>> spec = ts.Spec({\n  ...     'driver': 'n5',\n  ...     'kvstore': {\n  ...         'driver': 'memory'\n  ...     },\n  ...     'metadata': {\n  ...         'dimensions': [100, 200]\n  ...     }\n  ... })\n  >>> spec = spec[ts.d[0].translate_by[5]]\n  >>> spec.to_json()\n  {'driver': 'n5',\n   'kvstore': {'driver': 'memory'},\n   'metadata': {'dimensions': [100, 200]},\n   'transform': {'input_exclusive_max': [[105], [200]],\n                 'input_inclusive_min': [5, 0],\n                 'output': [{'input_dimension': 0, 'offset': -5},\n                            {'input_dimension': 1}]}}\n\nGroup:\n  Accessors\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='transform', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='IndexTransform', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef transform (arg0: Spec) -> Optional[IndexTransform]: ...",
                "doc": "\nThe :ref:`index transform<index-transform>`, or `None` if unspecified.\n\nExample:\n\n  >>> spec = ts.Spec({'driver': 'n5', 'kvstore': {'driver': 'memory'}})\n  >>> print(spec.transform)\n  None\n\n  >>> spec = ts.Spec({\n  ...     'driver': 'n5',\n  ...     'kvstore': {\n  ...         'driver': 'memory'\n  ...     },\n  ...     'metadata': {\n  ...         'dimensions': [100, 200],\n  ...         'axes': ['x', 'y']\n  ...     }\n  ... })\n  >>> spec.transform\n  Rank 2 -> 2 index space transform:\n    Input domain:\n      0: [0, 100*) \"x\"\n      1: [0, 200*) \"y\"\n    Output index maps:\n      out[0] = 0 + 1 * in[0]\n      out[1] = 0 + 1 * in[1]\n  >>> spec[ts.d['x'].translate_by[5]].transform\n  Rank 2 -> 2 index space transform:\n    Input domain:\n      0: [5, 105*) \"x\"\n      1: [0, 200*) \"y\"\n    Output index maps:\n      out[0] = -5 + 1 * in[0]\n      out[1] = 0 + 1 * in[1]\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='translate_backward_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Spec', ctx=Load()), attr='_TranslateBackwardBy', ctx=Load()))",
                "definition": "@property\ndef translate_backward_by (arg0: object) -> Spec._TranslateBackwardBy: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='translate_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Spec', ctx=Load()), attr='_TranslateBy', ctx=Load()))",
                "definition": "@property\ndef translate_by (arg0: object) -> Spec._TranslateBy: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='translate_to', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Spec', ctx=Load()), attr='_TranslateTo', ctx=Load()))",
                "definition": "@property\ndef translate_to (arg0: object) -> Spec._TranslateTo: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='transpose', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Spec', ctx=Load())), arg(arg='axes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='DimSelectionLike', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Spec', ctx=Load()))",
                "definition": "def transpose(self: Spec, axes: Optional[DimSelectionLike] = None) -> Spec: ...",
                "doc": "transpose(self: tensorstore.Spec, axes: Optional[DimSelectionLike] = None) -> tensorstore.Spec\n\n\nReturns a view with a transposed domain.\n\nThis is equivalent to :python:`self[ts.d[axes].transpose[:]]`.\n\nArgs:\n\n  axes: Specifies the existing dimension corresponding to each dimension of the\n    new view.  Dimensions may be specified either by index or label.  Specifying\n    `None` is equivalent to specifying :python:`[rank-1, ..., 0]`, which\n    reverses the dimension order.\n\nRaises:\n\n  ValueError: If :py:param:`.axes` does not specify a valid permutation.\n\nSee also:\n  - `tensorstore.DimExpression.transpose`\n  - :py:obj:`.T`\n\nGroup:\n  Indexing\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='update', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Spec', ctx=Load()))], kwonlyargs=[arg(arg='open_mode', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='OpenMode', ctx=Load()), ctx=Load())), arg(arg='open', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='create', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='delete_existing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='assume_metadata', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='assume_cached_metadata', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='unbind_context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='strip_context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Context', ctx=Load()), ctx=Load())), arg(arg='kvstore', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()), ctx=Load())), arg(arg='rank', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='dtype', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='dtype', ctx=Load()), ctx=Load())), arg(arg='domain', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='IndexDomain', ctx=Load()), ctx=Load())), arg(arg='shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='chunk_layout', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='ChunkLayout', ctx=Load()), ctx=Load())), arg(arg='codec', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='CodecSpec', ctx=Load()), ctx=Load())), arg(arg='fill_value', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load()), ctx=Load())), arg(arg='dimension_units', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Unit', ctx=Load()), Name(id='str', ctx=Load()), Name(id='Real', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='Real', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='schema', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Schema', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None))",
                "definition": "def update(self: Spec, *, open_mode: Optional[OpenMode] = None, open: Optional[bool] = None, create: Optional[bool] = None, delete_existing: Optional[bool] = None, assume_metadata: Optional[bool] = None, assume_cached_metadata: Optional[bool] = None, unbind_context: Optional[bool] = None, strip_context: Optional[bool] = None, context: Optional[Context] = None, kvstore: Optional[KvStore.Spec] = None, rank: Optional[int] = None, dtype: Optional[dtype] = None, domain: Optional[IndexDomain] = None, shape: Optional[Sequence[int]] = None, chunk_layout: Optional[ChunkLayout] = None, codec: Optional[CodecSpec] = None, fill_value: Optional[numpy.typing.ArrayLike] = None, dimension_units: Optional[Sequence[Optional[Union[Unit, str, Real, Tuple[Real, str]]]]] = None, schema: Optional[Schema] = None) -> None: ...",
                "doc": "update(self: tensorstore.Spec, *, open_mode: Optional[tensorstore.OpenMode] = None, open: Optional[bool] = None, create: Optional[bool] = None, delete_existing: Optional[bool] = None, assume_metadata: Optional[bool] = None, assume_cached_metadata: Optional[bool] = None, unbind_context: Optional[bool] = None, strip_context: Optional[bool] = None, context: Optional[tensorstore.Context] = None, kvstore: Optional[tensorstore.KvStore.Spec] = None, rank: Optional[int] = None, dtype: Optional[tensorstore.dtype] = None, domain: Optional[tensorstore.IndexDomain] = None, shape: Optional[Sequence[int]] = None, chunk_layout: Optional[tensorstore.ChunkLayout] = None, codec: Optional[tensorstore.CodecSpec] = None, fill_value: Optional[numpy.typing.ArrayLike] = None, dimension_units: Optional[Sequence[Optional[Union[tensorstore.Unit, str, Real, Tuple[Real, str]]]]] = None, schema: Optional[tensorstore.Schema] = None) -> None\n\n\nAdds additional constraints or changes the open mode.\n\nExample:\n\n  >>> spec = ts.Spec({'driver': 'n5', 'kvstore': {'driver': 'memory'}})\n  >>> spec.update(shape=[100, 200, 300])\n  >>> spec\n  Spec({\n    'driver': 'n5',\n    'kvstore': {'driver': 'memory'},\n    'schema': {\n      'domain': {'exclusive_max': [100, 200, 300], 'inclusive_min': [0, 0, 0]},\n    },\n    'transform': {\n      'input_exclusive_max': [[100], [200], [300]],\n      'input_inclusive_min': [0, 0, 0],\n    },\n  })\n\nArgs:\n  open_mode: Overrides the existing open mode.\n  open: Allow opening an existing TensorStore.  Overrides the existing open mode.\n  create: Allow creating a new TensorStore.  Overrides the existing open mode.  To open or\n    create, specify :python:`create=True` and :python:`open=True`.\n  delete_existing: Delete any existing data before creating a new array.  Overrides the existing\n    open mode.  Must be specified in conjunction with :python:`create=True`.\n  assume_metadata: Neither read nor write stored metadata.  Instead, just assume any necessary\n    metadata based on constraints in the spec, using the same defaults for any\n    unspecified metadata as when creating a new TensorStore.  The stored metadata\n    need not even exist.  Operations such as resizing that modify the stored\n    metadata are not supported.  Overrides the existing open mode.  Requires that\n    :py:param:`.open` is `True` and :py:param:`.delete_existing` is `False`.  This\n    option takes precedence over `.assume_cached_metadata` if that option is also\n    specified.\n    \n    .. warning::\n    \n       This option can lead to data corruption if the assumed metadata does\n       not match the stored metadata, or multiple concurrent writers use\n       different assumed metadata.\n    \n    .. seealso:\n    \n       - :ref:`python-open-assume-metadata`\n  assume_cached_metadata: Skip reading the metadata when opening.  Instead, just assume any necessary\n    metadata based on constraints in the spec, using the same defaults for any\n    unspecified metadata as when creating a new TensorStore.  The stored metadata\n    may still be accessed by subsequent operations that need to re-validate or\n    modify the metadata.  Requires that :py:param:`.open` is `True` and\n    :py:param:`.delete_existing` is `False`.  The :py:param:`.assume_metadata`\n    option takes precedence if also specified.\n    \n    .. warning::\n    \n       This option can lead to data corruption if the assumed metadata does\n       not match the stored metadata, or multiple concurrent writers use\n       different assumed metadata.\n    \n    .. seealso:\n    \n       - :ref:`python-open-assume-metadata`\n  unbind_context: Convert any bound context resources to context resource specs that fully capture\n    the graph of shared context resources and interdependencies.\n    \n    Re-binding/re-opening the resultant spec will result in a new graph of new\n    context resources that is isomorphic to the original graph of context resources.\n    The resultant spec will not refer to any external context resources;\n    consequently, binding it to any specific context will have the same effect as\n    binding it to a default context.\n    \n    Specifying a value of :python:`False` has no effect.\n  strip_context: Replace any bound context resources and unbound context resource specs by\n    default context resource specs.\n    \n    If the resultant :py:obj:`~tensorstore.Spec` is re-opened with, or re-bound to,\n    a new context, it will use the default context resources specified by that\n    context.\n    \n    Specifying a value of :python:`False` has no effect.\n  context: Bind any context resource specs using the specified shared resource context.\n    \n    Any already-bound context resources remain unchanged.  Additionally, any context\n    resources specified by a nested :json:schema:`TensorStore.context` spec will be\n    created as specified, but won't be overridden by :py:param:`.context`.\n  kvstore: Sets the associated key-value store used as the underlying storage.\n    \n    If the :py:obj:`~tensorstore.Spec.kvstore` has already been set, it is\n    overridden.\n    \n    It is an error to specify this if the TensorStore driver does not use a\n    key-value store.\n  rank: Constrains the rank of the TensorStore.  If there is an index transform, the\n    rank constraint must match the rank of the *input* space.\n  dtype: Constrains the data type of the TensorStore.  If a data type has already been\n    set, it is an error to specify a different data type.\n  domain: Constrains the domain of the TensorStore.  If there is an existing\n    domain, the specified domain is merged with it as follows:\n    \n    1. The rank must match the existing rank.\n    \n    2. All bounds must match, except that a finite or explicit bound is permitted to\n       match an infinite and implicit bound, and takes precedence.\n    \n    3. If both the new and existing domain specify non-empty labels for a dimension,\n       the labels must be equal.  If only one of the domains specifies a non-empty\n       label for a dimension, the non-empty label takes precedence.\n    \n    Note that if there is an index transform, the domain must match the *input*\n    space, not the output space.\n  shape: Constrains the shape and origin of the TensorStore.  Equivalent to specifying a\n    :py:param:`domain` of :python:`ts.IndexDomain(shape=shape)`.\n    \n    .. note::\n    \n       This option also constrains the origin of all dimensions to be zero.\n  chunk_layout: Constrains the chunk layout.  If there is an existing chunk layout constraint,\n    the constraints are merged.  If the constraints are incompatible, an error\n    is raised.\n  codec: Constrains the codec.  If there is an existing codec constraint, the constraints\n    are merged.  If the constraints are incompatible, an error is raised.\n  fill_value: Specifies the fill value for positions that have not been written.\n    \n    The fill value data type must be convertible to the actual data type, and the\n    shape must be :ref:`broadcast-compatible<index-domain-alignment>` with the\n    domain.\n    \n    If an existing fill value has already been set as a constraint, it is an\n    error to specify a different fill value (where the comparison is done after\n    normalization by broadcasting).\n  dimension_units: Specifies the physical units of each dimension of the domain.\n    \n    The *physical unit* for a dimension is the physical quantity corresponding to a\n    single index increment along each dimension.\n    \n    A value of :python:`None` indicates that the unit is unknown.  A dimension-less\n    quantity can be indicated by a unit of :python:`\"\"`.\n  schema: Additional schema constraints to merge with existing constraints.\n\n\nGroup:\n  Mutators\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='vindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='Spec', ctx=Load()), attr='_Vindex', ctx=Load()))",
                "definition": "@property\ndef vindex (arg0: object) -> Spec._Vindex: ...",
                "doc": "",
                "type": "property"
            }
        ],
        "definition": "<class 'tensorstore.Spec'>",
        "doc": "\nSpecification for opening or creating a :py:obj:`.TensorStore`.\n\nGroup:\n  Spec\n\nConstructors\n============\n\nAccessors\n=========\n\nIndexing\n========\n\nComparison operators\n====================\n\n",
        "type": "class"
    },
    "TensorStore": {
        "ast": "ClassDef(name='TensorStore', bases=[], keywords=[], body=[ClassDef(name='StorageStatistics', bases=[], keywords=[], body=[FunctionDef(name='fully_stored', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='StorageStatistics', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), FunctionDef(name='not_stored', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='StorageStatistics', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='T', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='TensorStore', ctx=Load())), FunctionDef(name='astype', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='TensorStore', ctx=Load())), arg(arg='dtype', annotation=Name(id='dtype', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='TensorStore', ctx=Load())), FunctionDef(name='base', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='TensorStore', ctx=Load()), ctx=Load())), FunctionDef(name='chunk_layout', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='ChunkLayout', ctx=Load())), FunctionDef(name='codec', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='CodecSpec', ctx=Load()), ctx=Load())), FunctionDef(name='dimension_units', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Unit', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='domain', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='IndexDomain', ctx=Load())), FunctionDef(name='dtype', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='dtype', ctx=Load())), FunctionDef(name='fill_value', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load()), ctx=Load())), FunctionDef(name='kvstore', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='KvStore', ctx=Load()), ctx=Load())), FunctionDef(name='label', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='_Label', ctx=Load())), FunctionDef(name='mark_bounds_implicit', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='_MarkBoundsImplicit', ctx=Load())), FunctionDef(name='mode', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='ndim', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='oindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='_Oindex', ctx=Load())), FunctionDef(name='origin', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='read', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='TensorStore', ctx=Load())), arg(arg='order', annotation=Subscript(value=Name(id='Literal', ctx=Load()), slice=Tuple(elts=[Constant(value='C'), Constant(value='F')], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='C')]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load()), ctx=Load())), FunctionDef(name='readable', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='resize', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='TensorStore', ctx=Load())), arg(arg='inclusive_min', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='exclusive_max', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='resize_metadata_only', annotation=Name(id='bool', ctx=Load())), arg(arg='resize_tied_bounds', annotation=Name(id='bool', ctx=Load())), arg(arg='expand_only', annotation=Name(id='bool', ctx=Load())), arg(arg='shrink_only', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=False), Constant(value=False), Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Name(id='TensorStore', ctx=Load()), ctx=Load())), FunctionDef(name='resolve', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='TensorStore', ctx=Load())), arg(arg='fix_resizable_bounds', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Name(id='TensorStore', ctx=Load()), ctx=Load())), FunctionDef(name='schema', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Schema', ctx=Load())), FunctionDef(name='shape', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='size', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='spec', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[arg(arg='open_mode', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='OpenMode', ctx=Load()), ctx=Load())), arg(arg='open', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='create', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='delete_existing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='assume_metadata', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='assume_cached_metadata', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='minimal_spec', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='retain_context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='unbind_context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Spec', ctx=Load())), FunctionDef(name='storage_statistics', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[arg(arg='query_not_stored', annotation=Name(id='bool', ctx=Load())), arg(arg='query_fully_stored', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False), Constant(value=False)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='StorageStatistics', ctx=Load()), ctx=Load())), FunctionDef(name='transaction', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Transaction', ctx=Load()), ctx=Load())), FunctionDef(name='translate_backward_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='_TranslateBackwardBy', ctx=Load())), FunctionDef(name='translate_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='_TranslateBy', ctx=Load())), FunctionDef(name='translate_to', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='_TranslateTo', ctx=Load())), FunctionDef(name='transpose', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='TensorStore', ctx=Load())), arg(arg='axes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='DimSelectionLike', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='TensorStore', ctx=Load())), FunctionDef(name='vindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='_Vindex', ctx=Load())), FunctionDef(name='with_transaction', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='TensorStore', ctx=Load())), arg(arg='transaction', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Transaction', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='TensorStore', ctx=Load())), FunctionDef(name='writable', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='write', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='TensorStore', ctx=Load())), arg(arg='source', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='TensorStore', ctx=Load()), Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='WriteFutures', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "ClassDef(name='StorageStatistics', bases=[], keywords=[], body=[FunctionDef(name='fully_stored', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='StorageStatistics', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), FunctionDef(name='not_stored', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='StorageStatistics', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], decorator_list=[])",
                "children": [
                    {
                        "ast": "FunctionDef(name='fully_stored', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='StorageStatistics', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))",
                        "definition": "@property\ndef fully_stored (arg0: TensorStore.StorageStatistics) -> Optional[bool]: ...",
                        "doc": "\nIndicates whether data is stored for *all* elements of the specified :py:obj:~TensorStore.domain`.\n\nFor the statistics returned by :py:obj:`TensorStore.storage_statistics`, if\n:py:param:`~TensorStore.storage_statistics.query_fully_stored` is not set to\n:python:`True`, then this will be `None`.\n",
                        "type": "property"
                    },
                    {
                        "ast": "FunctionDef(name='not_stored', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='StorageStatistics', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))",
                        "definition": "@property\ndef not_stored (arg0: TensorStore.StorageStatistics) -> Optional[bool]: ...",
                        "doc": "\nIndicates whether *no* data is stored for the specified :py:obj:`~TensorStore.domain`.\n\nFor the statistics returned by :py:obj:`TensorStore.storage_statistics`, if\n:py:param:`~TensorStore.storage_statistics.query_not_stored` is not set to\n:python:`True`, then this will be `None`.\n\nIf :python:`False`, it is guaranteed that all elements within the domain are equal\nto the :py:obj:`~TensorStore.fill_value`.\n",
                        "type": "property"
                    }
                ],
                "definition": "<class 'tensorstore.TensorStore.StorageStatistics'>",
                "doc": "\nStatistics related to the storage of an array specified by a :py:class:`TensorStore`.\n\n.. seealso::\n\n   :py:obj:`tensorstore.TensorStore.storage_statistics`\n\nThese statistics provide information about the elements of an array that are\n*stored*, but depending on the :ref:`driver<tensorstore-drivers>`, whether data\nis stored for a given element is not necessarily equivalent to whether that\nelement has been successfully written:\n\n- There are cases where an element may be stored even if it has not been\n  explicitly written.  For example, when using a\n  :ref:`chunked storage driver<chunked-drivers>`, an entire chunk must be stored\n  in order to store any element within the chunk, and it is not possible to\n  determine which elements of the chunk were explicitly written.  If any chunk\n  corresponding to a region that intersects the domain is stored, then\n  :py:obj:`.not_stored` will be :python:`False`, even if no element actually within\n  the domain was explicitly written.  Similarly, if at least one element of each\n  chunk that intersects the domain is stored, then :py:obj:`.fully_stored` will be\n  :python:`True`, even if no element of the domain was every explicitly written.\n\n- Some drivers may not store chunks that are entirely equal to the\n  :py:obj:`TensorStore.fill_value`.  With such drivers, if all elements of the\n  domain are equal to the fill value, even if some or all of the elements have\n  been explicitly written, :py:obj:`.not_stored` may be :python:`True`.\n\nGroup:\n  I/O\n",
                "type": "class"
            },
            {
                "ast": "FunctionDef(name='T', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='TensorStore', ctx=Load()))",
                "definition": "@property\ndef T (arg0: TensorStore) -> TensorStore: ...",
                "doc": "View with transposed domain (reversed dimension order).\n\nThis is equivalent to: :python:`self[ts.d[::-1].transpose[:]]`.\n\nSee also:\n  - `.transpose`\n  - `tensorstore.DimExpression.transpose`\n\nGroup:\n  Indexing\n",
                "type": "property"
            },
            {
                "definition": "<class 'tensorstore.TensorStore._Label'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.TensorStore._MarkBoundsImplicit'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.TensorStore._Oindex'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.TensorStore._TranslateBackwardBy'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.TensorStore._TranslateBy'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.TensorStore._TranslateTo'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.TensorStore._Vindex'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "ast": "FunctionDef(name='astype', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='TensorStore', ctx=Load())), arg(arg='dtype', annotation=Name(id='dtype', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='TensorStore', ctx=Load()))",
                "definition": "def astype(self: TensorStore, dtype: dtype) -> TensorStore: ...",
                "doc": "astype(self: tensorstore.TensorStore, dtype: tensorstore.dtype) -> tensorstore.TensorStore\n\n\nReturns a read/write view as the specified data type.\n\nExample:\n\n  >>> store = ts.array([1, 2, 3], dtype=ts.uint32)\n  >>> store.astype(ts.string)\n  TensorStore({\n    'base': {'array': [1, 2, 3], 'driver': 'array', 'dtype': 'uint32'},\n    'context': {'data_copy_concurrency': {}},\n    'driver': 'cast',\n    'dtype': 'string',\n    'transform': {'input_exclusive_max': [3], 'input_inclusive_min': [0]},\n  })\n\nGroup:\n  Data type\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='base', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='TensorStore', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef base (arg0: TensorStore) -> Optional[TensorStore]: ...",
                "doc": "\nUnderlying `TensorStore`, if this is an adapter.\n\nEqual to :python:`None` if the driver is not an adapter of a single underlying\n`TensorStore`.\n\nExample:\n\n    >>> store = await ts.open(\n    ...     {\n    ...         'driver': 'zarr',\n    ...         'kvstore': {\n    ...             'driver': 'memory',\n    ...             'path': 'abc/',\n    ...         }\n    ...     },\n    ...     create=True,\n    ...     shape=[100, 200],\n    ...     dtype=ts.uint32,\n    ... )\n    >>> downsampled = ts.downsample(store,\n    ...                             downsample_factors=[2, 4],\n    ...                             method=\"mean\")\n    >>> downsampled\n    TensorStore({\n      'base': {\n        'driver': 'zarr',\n        'kvstore': {'driver': 'memory', 'path': 'abc/'},\n        'metadata': {\n          'chunks': [100, 200],\n          'compressor': {\n            'blocksize': 0,\n            'clevel': 5,\n            'cname': 'lz4',\n            'id': 'blosc',\n            'shuffle': -1,\n          },\n          'dimension_separator': '.',\n          'dtype': '<u4',\n          'fill_value': None,\n          'filters': None,\n          'order': 'C',\n          'shape': [100, 200],\n          'zarr_format': 2,\n        },\n        'transform': {\n          'input_exclusive_max': [[100], [200]],\n          'input_inclusive_min': [0, 0],\n        },\n      },\n      'context': {\n        'cache_pool': {},\n        'data_copy_concurrency': {},\n        'memory_key_value_store': {},\n      },\n      'downsample_factors': [2, 4],\n      'downsample_method': 'mean',\n      'driver': 'downsample',\n      'dtype': 'uint32',\n      'transform': {\n        'input_exclusive_max': [[50], [50]],\n        'input_inclusive_min': [0, 0],\n      },\n    })\n    >>> downsampled[30:40, 20:25].base\n    TensorStore({\n      'context': {\n        'cache_pool': {},\n        'data_copy_concurrency': {},\n        'memory_key_value_store': {},\n      },\n      'driver': 'zarr',\n      'dtype': 'uint32',\n      'kvstore': {'driver': 'memory', 'path': 'abc/'},\n      'metadata': {\n        'chunks': [100, 200],\n        'compressor': {\n          'blocksize': 0,\n          'clevel': 5,\n          'cname': 'lz4',\n          'id': 'blosc',\n          'shuffle': -1,\n        },\n        'dimension_separator': '.',\n        'dtype': '<u4',\n        'fill_value': None,\n        'filters': None,\n        'order': 'C',\n        'shape': [100, 200],\n        'zarr_format': 2,\n      },\n      'transform': {\n        'input_exclusive_max': [80, 100],\n        'input_inclusive_min': [60, 80],\n      },\n    })\n    >>> converted = ts.cast(store, ts.float32)\n    >>> converted.base\n    TensorStore({\n      'context': {\n        'cache_pool': {},\n        'data_copy_concurrency': {},\n        'memory_key_value_store': {},\n      },\n      'driver': 'zarr',\n      'dtype': 'uint32',\n      'kvstore': {'driver': 'memory', 'path': 'abc/'},\n      'metadata': {\n        'chunks': [100, 200],\n        'compressor': {\n          'blocksize': 0,\n          'clevel': 5,\n          'cname': 'lz4',\n          'id': 'blosc',\n          'shuffle': -1,\n        },\n        'dimension_separator': '.',\n        'dtype': '<u4',\n        'fill_value': None,\n        'filters': None,\n        'order': 'C',\n        'shape': [100, 200],\n        'zarr_format': 2,\n      },\n      'transform': {\n        'input_exclusive_max': [[100], [200]],\n        'input_inclusive_min': [0, 0],\n      },\n    })\n\nDrivers that support this method include:\n\n- :ref:`driver/cast`\n- :ref:`driver/downsample`\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='chunk_layout', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='ChunkLayout', ctx=Load()))",
                "definition": "@property\ndef chunk_layout (arg0: TensorStore) -> ChunkLayout: ...",
                "doc": "\n:ref:`Chunk layout<chunk-layout>` of the TensorStore.\n\nExample:\n\n  >>> store = await ts.open(\n  ...     {\n  ...         'driver': 'zarr',\n  ...         'kvstore': {\n  ...             'driver': 'memory'\n  ...         }\n  ...     },\n  ...     shape=[1000, 2000, 3000],\n  ...     dtype=ts.float32,\n  ...     create=True)\n  >>> store.chunk_layout\n  ChunkLayout({\n    'grid_origin': [0, 0, 0],\n    'inner_order': [0, 1, 2],\n    'read_chunk': {'shape': [101, 101, 101]},\n    'write_chunk': {'shape': [101, 101, 101]},\n  })\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='codec', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='CodecSpec', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef codec (arg0: TensorStore) -> Optional[CodecSpec]: ...",
                "doc": "\nData codec spec.\n\nThis may be used to create a new TensorStore with the same codec.\n\nEqual to :py:obj:`None` if the codec is unknown or not applicable.\n\nExample:\n\n    >>> store = await ts.open(\n    ...     {\n    ...         'driver': 'zarr',\n    ...         'kvstore': {\n    ...             'driver': 'memory'\n    ...         }\n    ...     },\n    ...     create=True,\n    ...     shape=[100],\n    ...     dtype=ts.uint32)\n    >>> store.codec\n    CodecSpec({\n      'compressor': {\n        'blocksize': 0,\n        'clevel': 5,\n        'cname': 'lz4',\n        'id': 'blosc',\n        'shuffle': -1,\n      },\n      'driver': 'zarr',\n      'filters': None,\n    })\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='dimension_units', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Unit', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef dimension_units (arg0: TensorStore) -> Tuple[Optional[Unit], ...]: ...",
                "doc": "\nPhysical units of each dimension of the domain.\n\nThe *physical unit* for a dimension is the physical quantity corresponding to a\nsingle index increment along each dimension.\n\nA value of :python:`None` indicates that the unit is unknown.  A dimension-less\nquantity is indicated by a unit of :python:`ts.Unit(1, \"\")`.\n\nExample:\n\n    >>> store = await ts.open(\n    ...     {\n    ...         'driver': 'n5',\n    ...         'kvstore': {\n    ...             'driver': 'memory'\n    ...         }\n    ...     },\n    ...     create=True,\n    ...     shape=[100, 200],\n    ...     dtype=ts.uint32,\n    ...     dimension_units=['5nm', '8nm'])\n    >>> store.dimension_units\n    (Unit(5, \"nm\"), Unit(8, \"nm\"))\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='domain', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='IndexDomain', ctx=Load()))",
                "definition": "@property\ndef domain (arg0: TensorStore) -> IndexDomain: ...",
                "doc": "\nDomain of the array.\n\nExample:\n\n    >>> dataset = await ts.open(\n    ...     {\n    ...         'driver': 'n5',\n    ...         'kvstore': {\n    ...             'driver': 'memory'\n    ...         }\n    ...     },\n    ...     dtype=ts.uint32,\n    ...     domain=ts.IndexDomain(shape=[70, 80], labels=['x', 'y']),\n    ...     create=True)\n    >>> dataset.domain\n    { \"x\": [0, 70*), \"y\": [0, 80*) }\n\nThe bounds of the domain reflect any transformations that have been applied:\n\n    >>> dataset[30:50].domain\n    { \"x\": [30, 50), \"y\": [0, 80*) }\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='dtype', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='dtype', ctx=Load()))",
                "definition": "@property\ndef dtype (arg0: TensorStore) -> dtype: ...",
                "doc": "\nData type of the array.\n\nExample:\n\n    >>> dataset = await ts.open(\n    ...     {\n    ...         'driver': 'zarr',\n    ...         'kvstore': {\n    ...             'driver': 'memory'\n    ...         }\n    ...     },\n    ...     dtype=ts.uint32,\n    ...     shape=[70, 80],\n    ...     create=True)\n    >>> dataset.dtype\n    dtype(\"uint32\")\n\nGroup:\n  Data type\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='fill_value', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef fill_value (arg0: TensorStore) -> Optional[numpy.typing.ArrayLike]: ...",
                "doc": "\nFill value for positions not yet written.\n\nEqual to :py:obj:`None` if the fill value is unknown or not applicable.\n\nThe fill value has data type equal to :python:`self.dtype` and a shape that is\n:ref:`broadcast-compatible<index-domain-alignment>` with :python:`self.shape`.\n\nExample:\n\n    >>> store = await ts.open(\n    ...     {\n    ...         'driver': 'zarr',\n    ...         'kvstore': {\n    ...             'driver': 'memory'\n    ...         }\n    ...     },\n    ...     create=True,\n    ...     shape=[100],\n    ...     dtype=ts.uint32,\n    ...     fill_value=42)\n    >>> store.fill_value\n    array(42, dtype=uint32)\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='kvstore', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='KvStore', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef kvstore (arg0: TensorStore) -> Optional[KvStore]: ...",
                "doc": "\nAssociated key-value store used as the underlying storage.\n\nEqual to :python:`None` if the driver does not use a key-value store.\n\nExample:\n\n    >>> store = await ts.open(\n    ...     {\n    ...         'driver': 'n5',\n    ...         'kvstore': {\n    ...             'driver': 'memory',\n    ...             'path': 'abc/',\n    ...         }\n    ...     },\n    ...     create=True,\n    ...     shape=[100, 200],\n    ...     dtype=ts.uint32,\n    ... )\n    >>> store.kvstore\n    KvStore({'context': {'memory_key_value_store': {}}, 'driver': 'memory', 'path': 'abc/'})\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='label', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='_Label', ctx=Load()))",
                "definition": "@property\ndef label (arg0: object) -> TensorStore._Label: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='mark_bounds_implicit', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='_MarkBoundsImplicit', ctx=Load()))",
                "definition": "@property\ndef mark_bounds_implicit (arg0: object) -> TensorStore._MarkBoundsImplicit: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='mode', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))",
                "definition": "@property\ndef mode (arg0: TensorStore) -> str: ...",
                "doc": "\nRead/write mode.\n\nReturns:\n\n  :python:`'r'`\n    read only\n\n  :python:`'w'`\n    write only\n\n  :python:`'rw'`\n    read-write\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='ndim', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef ndim (arg0: TensorStore) -> int: ...",
                "doc": "\nAlias for :py:obj:`.rank`.\n\nExample:\n\n    >>> dataset = ts.array([[1, 2, 3], [4, 5, 6]], dtype=ts.int32)\n    >>> dataset.ndim\n    2\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='oindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='_Oindex', ctx=Load()))",
                "definition": "@property\ndef oindex (arg0: object) -> TensorStore._Oindex: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='origin', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef origin (arg0: TensorStore) -> Tuple[int, ...]: ...",
                "doc": "Inclusive lower bound of the domain.\n\nThis is equivalent to :python:`self.domain.origin`.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='rank', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef rank (arg0: TensorStore) -> int: ...",
                "doc": "Number of dimensions in the domain.\n\nThis is equivalent to :python:`self.domain.rank`.\n\nExample:\n\n    >>> dataset = ts.array([[1, 2, 3], [4, 5, 6]], dtype=ts.int32)\n    >>> dataset.rank\n    2\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='read', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='TensorStore', ctx=Load())), arg(arg='order', annotation=Subscript(value=Name(id='Literal', ctx=Load()), slice=Tuple(elts=[Constant(value='C'), Constant(value='F')], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='C')]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load()), ctx=Load()))",
                "definition": "def read(self: TensorStore, order: Literal['C','F'] = 'C') -> Future[numpy.typing.ArrayLike]: ...",
                "doc": "read(self: tensorstore.TensorStore, order: Literal['C','F'] = 'C') -> tensorstore.Future[numpy.typing.ArrayLike]\n\n\nReads the data within the current domain.\n\nExample:\n\n    >>> dataset = await ts.open(\n    ...     {\n    ...         'driver': 'zarr',\n    ...         'kvstore': {\n    ...             'driver': 'memory'\n    ...         }\n    ...     },\n    ...     dtype=ts.uint32,\n    ...     shape=[70, 80],\n    ...     create=True)\n    >>> await dataset[5:10, 8:12].read()\n    array([[0, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 0, 0, 0]], dtype=uint32)\n\n.. tip::\n\n   Depending on the cache behavior of the driver, the read may be satisfied by\n   the cache and not require any I/O.\n\nWhen *not* using a :py:obj:`.transaction`, the\nread result only reflects committed data; the result never includes uncommitted\nwrites.\n\nWhen using a transaction, the read result reflects all writes completed (but not\nyet committed) to the transaction.\n\nArgs:\n  order: Contiguous layout order of the returned array:\n\n    :python:`'C'`\n      Specifies C order, i.e. lexicographic/row-major order.\n\n    :python:`'F'`\n      Specifies Fortran order, i.e. colexicographic/column-major order.\n\nReturns:\n  A future representing the asynchronous read result.\n\n.. tip::\n\n   Synchronous reads (blocking the current thread) may be performed by calling\n   :py:obj:`Future.result` on the returned future:\n\n   >>> dataset[5:10, 8:12].read().result()\n   array([[0, 0, 0, 0],\n          [0, 0, 0, 0],\n          [0, 0, 0, 0],\n          [0, 0, 0, 0],\n          [0, 0, 0, 0]], dtype=uint32)\n\nSee also:\n\n  - :py:obj:`.__array__`\n\nGroup:\n  I/O\n\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='readable', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))",
                "definition": "@property\ndef readable (arg0: TensorStore) -> bool: ...",
                "doc": "\nIndicates if reading is supported.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='resize', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='TensorStore', ctx=Load())), arg(arg='inclusive_min', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='exclusive_max', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='resize_metadata_only', annotation=Name(id='bool', ctx=Load())), arg(arg='resize_tied_bounds', annotation=Name(id='bool', ctx=Load())), arg(arg='expand_only', annotation=Name(id='bool', ctx=Load())), arg(arg='shrink_only', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=False), Constant(value=False), Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Name(id='TensorStore', ctx=Load()), ctx=Load()))",
                "definition": "def resize(self: TensorStore, inclusive_min: Optional[Sequence[Optional[int]]] = None, exclusive_max: Optional[Sequence[Optional[int]]] = None, resize_metadata_only: bool = False, resize_tied_bounds: bool = False, expand_only: bool = False, shrink_only: bool = False) -> Future[TensorStore]: ...",
                "doc": "resize(self: tensorstore.TensorStore, inclusive_min: Optional[Sequence[Optional[int]]] = None, exclusive_max: Optional[Sequence[Optional[int]]] = None, resize_metadata_only: bool = False, resize_tied_bounds: bool = False, expand_only: bool = False, shrink_only: bool = False) -> tensorstore.Future[tensorstore.TensorStore]\n\n\nResizes the current domain, persistently modifying the stored representation.\n\nDepending on the :py:param`resize_metadata_only`, if the bounds are shrunk,\nexisting elements outside of the new bounds may be deleted. If the bounds are\nexpanded, elements outside the existing bounds will initially contain either the\nfill value, or existing out-of-bounds data remaining after a prior resize\noperation.\n\nExample:\n\n    >>> dataset = await ts.open(\n    ...     {\n    ...         'driver': 'zarr',\n    ...         'kvstore': {\n    ...             'driver': 'memory'\n    ...         }\n    ...     },\n    ...     dtype=ts.uint32,\n    ...     shape=[3, 3],\n    ...     create=True)\n    >>> await dataset.write(np.arange(9, dtype=np.uint32).reshape((3, 3)))\n    >>> dataset = await dataset.resize(exclusive_max=(3, 2))\n    >>> await dataset.read()\n    array([[0, 1],\n           [3, 4],\n           [6, 7]], dtype=uint32)\n\nArgs:\n\n  inclusive_min: Sequence of length :python:`self.rank()` specifying the new\n    inclusive min bounds.  A bound of :python:`None` indicates no change.\n  exclusive_max: Sequence of length :python:`self.rank()` specifying the new\n    exclusive max bounds.  A bound of :python:`None` indicates no change.\n  resize_metadata_only: Requests that, if applicable, the resize operation\n    affect only the metadata but not delete data chunks that are outside of the\n    new bounds.\n  resize_tied_bounds: Requests that the resize be permitted even if other\n    bounds tied to the specified bounds must also be resized.  This option\n    should be used with caution.\n  expand_only: Fail if any bounds would be reduced.\n  shrink_only: Fail if any bounds would be increased.\n\nReturns:\n\n  Future that resolves to a copy of :python:`self` with the updated bounds, once\n  the resize operation completes.\n\nGroup:\n  I/O\n\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='resolve', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='TensorStore', ctx=Load())), arg(arg='fix_resizable_bounds', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Name(id='TensorStore', ctx=Load()), ctx=Load()))",
                "definition": "def resolve(self: TensorStore, fix_resizable_bounds: bool = False) -> Future[TensorStore]: ...",
                "doc": "resolve(self: tensorstore.TensorStore, fix_resizable_bounds: bool = False) -> tensorstore.Future[tensorstore.TensorStore]\n\n\nObtains updated bounds, subject to the cache policy.\n\nGroup:\n  I/O\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='schema', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Schema', ctx=Load()))",
                "definition": "@property\ndef schema (arg0: TensorStore) -> Schema: ...",
                "doc": "\n:ref:`Schema<schema>` of this TensorStore.\n\nThis schema may be used to create a new TensorStore with the same schema, but\npossibly using a different driver, storage location, etc.\n\nExample:\n\n    >>> store = await ts.open(\n    ...     {\n    ...         'driver': 'zarr',\n    ...         'kvstore': {\n    ...             'driver': 'memory'\n    ...         }\n    ...     },\n    ...     create=True,\n    ...     shape=[100],\n    ...     dtype=ts.uint32,\n    ...     fill_value=42)\n    >>> store.schema\n    Schema({\n      'chunk_layout': {\n        'grid_origin': [0],\n        'inner_order': [0],\n        'read_chunk': {'shape': [100]},\n        'write_chunk': {'shape': [100]},\n      },\n      'codec': {\n        'compressor': {\n          'blocksize': 0,\n          'clevel': 5,\n          'cname': 'lz4',\n          'id': 'blosc',\n          'shuffle': -1,\n        },\n        'driver': 'zarr',\n        'filters': None,\n      },\n      'domain': {'exclusive_max': [[100]], 'inclusive_min': [0]},\n      'dtype': 'uint32',\n      'fill_value': 42,\n      'rank': 1,\n    })\n\n.. note:\n\n   Each access to this property results in a new copy of the schema.  Modifying\n   that copying by calling `Schema.update` does not affect this TensorStore.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='shape', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef shape (arg0: TensorStore) -> Tuple[int, ...]: ...",
                "doc": "Shape of the domain.\n\nThis is equivalent to :python:`self.domain.shape`.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='size', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))",
                "definition": "@property\ndef size (arg0: TensorStore) -> int: ...",
                "doc": "Total number of elements in the domain.\n\nThis is equivalent to :python:`self.domain.size`.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='spec', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[arg(arg='open_mode', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='OpenMode', ctx=Load()), ctx=Load())), arg(arg='open', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='create', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='delete_existing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='assume_metadata', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='assume_cached_metadata', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='minimal_spec', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='retain_context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='unbind_context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Spec', ctx=Load()))",
                "definition": "def spec(self: TensorStore, *, open_mode: Optional[OpenMode] = None, open: Optional[bool] = None, create: Optional[bool] = None, delete_existing: Optional[bool] = None, assume_metadata: Optional[bool] = None, assume_cached_metadata: Optional[bool] = None, minimal_spec: Optional[bool] = None, retain_context: Optional[bool] = None, unbind_context: Optional[bool] = None) -> Spec: ...",
                "doc": "spec(self: tensorstore.TensorStore, *, open_mode: Optional[tensorstore.OpenMode] = None, open: Optional[bool] = None, create: Optional[bool] = None, delete_existing: Optional[bool] = None, assume_metadata: Optional[bool] = None, assume_cached_metadata: Optional[bool] = None, minimal_spec: Optional[bool] = None, retain_context: Optional[bool] = None, unbind_context: Optional[bool] = None) -> tensorstore.Spec\n\n\nSpec that may be used to re-open or re-create the TensorStore.\n\nExample:\n\n    >>> dataset = await ts.open(\n    ...     {\n    ...         'driver': 'zarr',\n    ...         'kvstore': {\n    ...             'driver': 'memory'\n    ...         }\n    ...     },\n    ...     dtype=ts.uint32,\n    ...     shape=[70, 80],\n    ...     create=True)\n    >>> dataset.spec()\n    Spec({\n      'driver': 'zarr',\n      'dtype': 'uint32',\n      'kvstore': {'driver': 'memory'},\n      'metadata': {\n        'chunks': [70, 80],\n        'compressor': {\n          'blocksize': 0,\n          'clevel': 5,\n          'cname': 'lz4',\n          'id': 'blosc',\n          'shuffle': -1,\n        },\n        'dimension_separator': '.',\n        'dtype': '<u4',\n        'fill_value': None,\n        'filters': None,\n        'order': 'C',\n        'shape': [70, 80],\n        'zarr_format': 2,\n      },\n      'transform': {\n        'input_exclusive_max': [[70], [80]],\n        'input_inclusive_min': [0, 0],\n      },\n    })\n    >>> dataset.spec(minimal_spec=True)\n    Spec({\n      'driver': 'zarr',\n      'dtype': 'uint32',\n      'kvstore': {'driver': 'memory'},\n      'transform': {\n        'input_exclusive_max': [[70], [80]],\n        'input_inclusive_min': [0, 0],\n      },\n    })\n    >>> dataset.spec(minimal_spec=True, unbind_context=True)\n    Spec({\n      'context': {\n        'cache_pool': {},\n        'data_copy_concurrency': {},\n        'memory_key_value_store': {},\n      },\n      'driver': 'zarr',\n      'dtype': 'uint32',\n      'kvstore': {'driver': 'memory'},\n      'transform': {\n        'input_exclusive_max': [[70], [80]],\n        'input_inclusive_min': [0, 0],\n      },\n    })\n\nIf neither :py:param:`.retain_context` nor :py:param:`.unbind_context` is\nspecified, the returned :py:obj:`~tensorstore.Spec` does not include any context\nresources, equivalent to specifying\n:py:param:`tensorstore.Spec.update.strip_context`.\n\nArgs:\n\n  open_mode: Overrides the existing open mode.\n  open: Allow opening an existing TensorStore.  Overrides the existing open mode.\n  create: Allow creating a new TensorStore.  Overrides the existing open mode.  To open or\n    create, specify :python:`create=True` and :python:`open=True`.\n  delete_existing: Delete any existing data before creating a new array.  Overrides the existing\n    open mode.  Must be specified in conjunction with :python:`create=True`.\n  assume_metadata: Neither read nor write stored metadata.  Instead, just assume any necessary\n    metadata based on constraints in the spec, using the same defaults for any\n    unspecified metadata as when creating a new TensorStore.  The stored metadata\n    need not even exist.  Operations such as resizing that modify the stored\n    metadata are not supported.  Overrides the existing open mode.  Requires that\n    :py:param:`.open` is `True` and :py:param:`.delete_existing` is `False`.  This\n    option takes precedence over `.assume_cached_metadata` if that option is also\n    specified.\n    \n    .. warning::\n    \n       This option can lead to data corruption if the assumed metadata does\n       not match the stored metadata, or multiple concurrent writers use\n       different assumed metadata.\n    \n    .. seealso:\n    \n       - :ref:`python-open-assume-metadata`\n  assume_cached_metadata: Skip reading the metadata when opening.  Instead, just assume any necessary\n    metadata based on constraints in the spec, using the same defaults for any\n    unspecified metadata as when creating a new TensorStore.  The stored metadata\n    may still be accessed by subsequent operations that need to re-validate or\n    modify the metadata.  Requires that :py:param:`.open` is `True` and\n    :py:param:`.delete_existing` is `False`.  The :py:param:`.assume_metadata`\n    option takes precedence if also specified.\n    \n    .. warning::\n    \n       This option can lead to data corruption if the assumed metadata does\n       not match the stored metadata, or multiple concurrent writers use\n       different assumed metadata.\n    \n    .. seealso:\n    \n       - :ref:`python-open-assume-metadata`\n  minimal_spec: Indicates whether to include in the returned :py:obj:`~tensorstore.Spec` the\n    metadata necessary to re-create the :py:obj:`~tensorstore.TensorStore`.  By\n    default, the returned :py:obj:`~tensorstore.Spec` includes the full metadata,\n    but it is skipped if :py:param:`.minimal_spec` is set to :python:`True`.\n  retain_context: Retain all bound context resources (e.g. specific concurrency pools, specific\n    cache pools).\n    \n    The resultant :py:obj:`~tensorstore.Spec` may be used to re-open the\n    :py:obj:`~tensorstore.TensorStore` using the identical context resources.\n    \n    Specifying a value of :python:`False` has no effect.\n  unbind_context: Convert any bound context resources to context resource specs that fully capture\n    the graph of shared context resources and interdependencies.\n    \n    Re-binding/re-opening the resultant spec will result in a new graph of new\n    context resources that is isomorphic to the original graph of context resources.\n    The resultant spec will not refer to any external context resources;\n    consequently, binding it to any specific context will have the same effect as\n    binding it to a default context.\n    \n    Specifying a value of :python:`False` has no effect.\n\n\nGroup:\n  Accessors\n\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='storage_statistics', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[arg(arg='query_not_stored', annotation=Name(id='bool', ctx=Load())), arg(arg='query_fully_stored', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False), Constant(value=False)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='StorageStatistics', ctx=Load()), ctx=Load()))",
                "definition": "def storage_statistics(self: TensorStore, *, query_not_stored: bool = False, query_fully_stored: bool = False) -> Future[TensorStore.StorageStatistics]: ...",
                "doc": "storage_statistics(self: tensorstore.TensorStore, *, query_not_stored: bool = False, query_fully_stored: bool = False) -> tensorstore.Future[tensorstore.TensorStore.StorageStatistics]\n\n\nObtains statistics of the data stored for the :py:obj:`.domain`.\n\nOnly the specific information indicated by the parameters will be returned.  If\nno query options are specified, no information will be computed.\n\nExample:\n\n    >>> store = await ts.open({\n    ...     \"driver\": \"zarr\",\n    ...     \"kvstore\": \"memory://\"\n    ... },\n    ...                       shape=(100, 200),\n    ...                       dtype=ts.uint32,\n    ...                       create=True)\n    >>> await store.storage_statistics(query_not_stored=True)\n    TensorStore.StorageStatistics(not_stored=True, fully_stored=None)\n    >>> await store[10:20, 30:40].write(5)\n    >>> await store.storage_statistics(query_not_stored=True)\n    TensorStore.StorageStatistics(not_stored=False, fully_stored=None)\n    >>> await store.storage_statistics(query_not_stored=True,\n    ...                                query_fully_stored=True)\n    TensorStore.StorageStatistics(not_stored=False, fully_stored=True)\n    >>> await store[10:20, 30:40].storage_statistics(query_fully_stored=True)\n    TensorStore.StorageStatistics(not_stored=None, fully_stored=True)\n\nArgs:\n\n  query_not_stored: Check whether there is data stored for *any* element of the\n    :py:obj:`.domain`.\n\n  query_fully_stored: Check whether there is data stored for *all* elements of\n    the :py:obj:`.domain`.\n\n    .. warning::\n\n         Enabling this option may significantly increase the cost of the\n         :py:obj:`.storage_statistics` query.\n\nReturns:\n  The requested statistics.\n\nRaises:\n  NotImplementedError: If the :ref:`driver<tensorstore-drivers>` does not\n    support this operation.\n\nGroup:\n  I/O\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='transaction', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Transaction', ctx=Load()), ctx=Load()))",
                "definition": "@property\ndef transaction (arg0: TensorStore) -> Optional[Transaction]: ...",
                "doc": "\nAssociated transaction used for read/write operations.\n\nGroup:\n  Transactions\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='translate_backward_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='_TranslateBackwardBy', ctx=Load()))",
                "definition": "@property\ndef translate_backward_by (arg0: object) -> TensorStore._TranslateBackwardBy: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='translate_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='_TranslateBy', ctx=Load()))",
                "definition": "@property\ndef translate_by (arg0: object) -> TensorStore._TranslateBy: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='translate_to', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='_TranslateTo', ctx=Load()))",
                "definition": "@property\ndef translate_to (arg0: object) -> TensorStore._TranslateTo: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='transpose', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='TensorStore', ctx=Load())), arg(arg='axes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='DimSelectionLike', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='TensorStore', ctx=Load()))",
                "definition": "def transpose(self: TensorStore, axes: Optional[DimSelectionLike] = None) -> TensorStore: ...",
                "doc": "transpose(self: tensorstore.TensorStore, axes: Optional[DimSelectionLike] = None) -> tensorstore.TensorStore\n\n\nReturns a view with a transposed domain.\n\nThis is equivalent to :python:`self[ts.d[axes].transpose[:]]`.\n\nArgs:\n\n  axes: Specifies the existing dimension corresponding to each dimension of the\n    new view.  Dimensions may be specified either by index or label.  Specifying\n    `None` is equivalent to specifying :python:`[rank-1, ..., 0]`, which\n    reverses the dimension order.\n\nRaises:\n\n  ValueError: If :py:param:`.axes` does not specify a valid permutation.\n\nSee also:\n  - `tensorstore.DimExpression.transpose`\n  - :py:obj:`.T`\n\nGroup:\n  Indexing\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='vindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='TensorStore', ctx=Load()), attr='_Vindex', ctx=Load()))",
                "definition": "@property\ndef vindex (arg0: object) -> TensorStore._Vindex: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='with_transaction', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='TensorStore', ctx=Load())), arg(arg='transaction', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Transaction', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='TensorStore', ctx=Load()))",
                "definition": "def with_transaction(self: TensorStore, transaction: Optional[Transaction]) -> TensorStore: ...",
                "doc": "with_transaction(self: tensorstore.TensorStore, transaction: Optional[tensorstore.Transaction]) -> tensorstore.TensorStore\n\nReturns a transaction-bound view of this TensorStore.\n\nThe returned view may be used to perform transactional read/write operations.\n\nGroup:\n  Transactions\n\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='writable', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='TensorStore', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))",
                "definition": "@property\ndef writable (arg0: TensorStore) -> bool: ...",
                "doc": "\nIndicates if writing is supported.\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='write', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='TensorStore', ctx=Load())), arg(arg='source', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='TensorStore', ctx=Load()), Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='WriteFutures', ctx=Load()))",
                "definition": "def write(self: TensorStore, source: Union[TensorStore, numpy.typing.ArrayLike]) -> WriteFutures: ...",
                "doc": "write(self: tensorstore.TensorStore, source: Union[tensorstore.TensorStore, numpy.typing.ArrayLike]) -> tensorstore.WriteFutures\n\n\nWrites to the current domain.\n\nExample:\n\n    >>> dataset = await ts.open(\n    ...     {\n    ...         'driver': 'zarr',\n    ...         'kvstore': {\n    ...             'driver': 'memory'\n    ...         }\n    ...     },\n    ...     dtype=ts.uint32,\n    ...     shape=[70, 80],\n    ...     create=True)\n    >>> await dataset[5:10, 6:8].write(42)\n    >>> await dataset[0:10, 0:10].read()\n    array([[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],\n           [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],\n           [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],\n           [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],\n           [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],\n           [ 0,  0,  0,  0,  0,  0, 42, 42,  0,  0],\n           [ 0,  0,  0,  0,  0,  0, 42, 42,  0,  0],\n           [ 0,  0,  0,  0,  0,  0, 42, 42,  0,  0],\n           [ 0,  0,  0,  0,  0,  0, 42, 42,  0,  0],\n           [ 0,  0,  0,  0,  0,  0, 42, 42,  0,  0]], dtype=uint32)\n    >>> await dataset[5:10, 6:8].write([1, 2])\n    >>> await dataset[5:10, 6:8].read()\n    array([[1, 2],\n           [1, 2],\n           [1, 2],\n           [1, 2],\n           [1, 2]], dtype=uint32)\n\nArgs:\n\n  source: Source array, :ref:`broadcast-compatible<index-domain-alignment>` with\n    :python:`self.domain` and with a data type convertible to\n    :python:`self.dtype`.  May be an existing :py:obj:`TensorStore` or any\n    :py:obj:`~numpy.typing.ArrayLike`, including a scalar.\n\nReturns:\n\n  Future representing the asynchronous result of the write operation.\n\nLogically there are two steps to the write operation:\n\n1. reading/copying from the :python:`source`, and\n\n2. waiting for the write to be committed, such that it will be reflected in\n   subsequent reads.\n\nThe completion of these two steps can be tracked separately using the returned\n:py:obj:`WriteFutures.copy` and :py:obj:`WriteFutures.commit` futures,\nrespectively:\n\nWaiting on the returned `WriteFutures` object itself waits for\nthe entire write operation to complete, and is equivalent to waiting on the\n:py:obj:`WriteFutures.commit` future.  The returned\n:py:obj:`WriteFutures.copy` future becomes ready once the data has been fully\nread from :python:`source`.  After this point, :python:`source` may be safely\nmodified without affecting the write operation.\n\n.. warning::\n\n   You must either synchronously or asynchronously wait on the returned future\n   in order to ensure the write actually completes.  If all references to the\n   future are dropped without waiting on it, the write may be cancelled.\n\nGroup:\n  I/O\n\nNon-transactional semantics\n---------------------------\n\nWhen *not* using a :py:obj:`Transaction`, the returned `WriteFutures.commit`\nfuture becomes ready only once the data has been durably committed by the\nunderlying storage layer.  The precise durability guarantees depend on the\ndriver, but for example:\n\n- when using the :ref:`file-kvstore-driver`, the data is only considered\n  committed once the ``fsync`` system call completes, which should normally\n  guarantee that it will survive a system crash;\n\n- when using the :ref:`gcs-kvstore-driver`, the data is only considered\n  committed once the write is acknowledged and durability is guaranteed by\n  Google Cloud Storage.\n\nBecause committing a write often has significant latency, it is advantageous to\nissue multiple writes concurrently and then wait on all of them jointly:\n\n    >>> dataset = await ts.open(\n    ...     {\n    ...         'driver': 'zarr',\n    ...         'kvstore': {\n    ...             'driver': 'memory'\n    ...         }\n    ...     },\n    ...     dtype=ts.uint32,\n    ...     shape=[70, 80],\n    ...     create=True)\n    >>> await asyncio.wait([\n    ...     asyncio.ensure_future(dataset[i * 5].write(i)) for i in range(10)\n    ... ])\n\nThis can also be accomplished with synchronous blocking:\n\n    >>> dataset = ts.open({\n    ...     'driver': 'zarr',\n    ...     'kvstore': {\n    ...         'driver': 'memory'\n    ...     }\n    ... },\n    ...                   dtype=ts.uint32,\n    ...                   shape=[70, 80],\n    ...                   create=True).result()\n    >>> futures = [dataset[i * 5].write(i) for i in range(10)]\n    >>> for f in futures:\n    ...     f.result()\n\nNote:\n\n  When issuing writes asynchronously, keep in mind that uncommitted writes are\n  never reflected in non-transactional reads.\n\nFor most drivers, data is written in fixed-size\n:ref:`write chunks<chunk-layout>` arranged in a regular grid.  When concurrently\nissuing multiple writes that are not perfectly aligned to disjoint write chunks,\nspecifying a :json:schema:`Context.cache_pool` enables writeback caching, which\ncan improve efficiency by coalescing multiple writes to the same chunk.\n\nAlternatively, for more explicit control over writeback behavior, you can use a\n:py:obj:`Transaction`.\n\nTransactional semantics\n-----------------------\n\nTransactions provide explicit control over writeback, and allow uncommitted\nwrites to be read:\n\n    >>> txn = ts.Transaction()\n    >>> dataset = await ts.open(\n    ...     {\n    ...         'driver': 'zarr',\n    ...         'kvstore': {\n    ...             'driver': 'memory'\n    ...         }\n    ...     },\n    ...     dtype=ts.uint32,\n    ...     shape=[70, 80],\n    ...     create=True)\n    >>> await dataset.with_transaction(txn)[5:10, 6:8].write([1, 2])\n    >>> # Transactional read reflects uncommitted write\n    >>> await dataset.with_transaction(txn)[5:10, 6:8].read()\n    array([[1, 2],\n           [1, 2],\n           [1, 2],\n           [1, 2],\n           [1, 2]], dtype=uint32)\n    >>> # Non-transactional read does not reflect uncommitted write\n    >>> await dataset[5:10, 6:8].read()\n    array([[0, 0],\n           [0, 0],\n           [0, 0],\n           [0, 0],\n           [0, 0]], dtype=uint32)\n    >>> await txn.commit_async()\n    >>> # Now, non-transactional read reflects committed write\n    >>> await dataset[5:10, 6:8].read()\n    array([[1, 2],\n           [1, 2],\n           [1, 2],\n           [1, 2],\n           [1, 2]], dtype=uint32)\n\n.. warning::\n\n   When using a :py:obj:`Transaction`, the returned `WriteFutures.commit` future\n   does *not* indicate that the data is durably committed by the underlying\n   storage layer.  Instead, it merely indicates that the write will be reflected\n   in any subsequent reads *using the same transaction*.  The write is only\n   durably committed once the *transaction* is committed successfully.\n\n\n",
                "type": "function"
            }
        ],
        "definition": "<class 'tensorstore.TensorStore'>",
        "doc": "\nAsynchronous multi-dimensional array handle.\n\nExamples:\n\n    >>> dataset = await ts.open(\n    ...     {\n    ...         'driver': 'zarr',\n    ...         'kvstore': {\n    ...             'driver': 'memory'\n    ...         },\n    ...     },\n    ...     dtype=ts.uint32,\n    ...     shape=[1000, 20000],\n    ...     create=True)\n    >>> dataset\n    TensorStore({\n      'context': {\n        'cache_pool': {},\n        'data_copy_concurrency': {},\n        'memory_key_value_store': {},\n      },\n      'driver': 'zarr',\n      'dtype': 'uint32',\n      'kvstore': {'driver': 'memory'},\n      'metadata': {\n        'chunks': [1000, 1048],\n        'compressor': {\n          'blocksize': 0,\n          'clevel': 5,\n          'cname': 'lz4',\n          'id': 'blosc',\n          'shuffle': -1,\n        },\n        'dimension_separator': '.',\n        'dtype': '<u4',\n        'fill_value': None,\n        'filters': None,\n        'order': 'C',\n        'shape': [1000, 20000],\n        'zarr_format': 2,\n      },\n      'transform': {\n        'input_exclusive_max': [[1000], [20000]],\n        'input_inclusive_min': [0, 0],\n      },\n    })\n    >>> await dataset[5:10, 6:8].write(42)\n    >>> await dataset[0:10, 0:10].read()\n    array([[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],\n           [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],\n           [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],\n           [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],\n           [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0],\n           [ 0,  0,  0,  0,  0,  0, 42, 42,  0,  0],\n           [ 0,  0,  0,  0,  0,  0, 42, 42,  0,  0],\n           [ 0,  0,  0,  0,  0,  0, 42, 42,  0,  0],\n           [ 0,  0,  0,  0,  0,  0, 42, 42,  0,  0],\n           [ 0,  0,  0,  0,  0,  0, 42, 42,  0,  0]], dtype=uint32)\n\nGroup:\n  Core\n",
        "type": "class"
    },
    "Transaction": {
        "ast": "ClassDef(name='Transaction', bases=[], keywords=[], body=[FunctionDef(name='abort', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Transaction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='aborted', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Transaction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='atomic', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Transaction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='commit_async', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Transaction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Constant(value=None), ctx=Load())), FunctionDef(name='commit_started', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Transaction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='commit_sync', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Transaction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='future', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Transaction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Constant(value=None), ctx=Load())), FunctionDef(name='open', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Transaction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "FunctionDef(name='abort', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Transaction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None))",
                "definition": "def abort(self: Transaction) -> None: ...",
                "doc": "abort(self: tensorstore.Transaction) -> None\n\n\nAborts the transaction.\n\nHas no effect if :py:meth:`.commit_async` or :py:meth:`.abort` has already been\ncalled.\n\n  - :py:obj:`.commit_async`\n\nGroup:\n  Operations\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='aborted', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Transaction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))",
                "definition": "@property\ndef aborted (arg0: Transaction) -> bool: ...",
                "doc": "\nIndicates whether the transaction has been aborted.\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='atomic', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Transaction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))",
                "definition": "@property\ndef atomic (arg0: Transaction) -> bool: ...",
                "doc": "\nIndicates whether the transaction is atomic.\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='commit_async', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Transaction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Constant(value=None), ctx=Load()))",
                "definition": "def commit_async(self: Transaction) -> Future[None]: ...",
                "doc": "commit_async(self: tensorstore.Transaction) -> tensorstore.Future[None]\n\n\nAsynchronously commits the transaction.\n\nHas no effect if :py:meth:`.commit_async` or :py:meth:`.abort` has already been\ncalled.\n\nReturns the associated :py:obj:`.future`, which may be used to check if the\ncommit was successful.\n\nSee also:\n\n  - :py:obj:`.commit_sync`\n  - :py:obj:`.abort`\n\nGroup:\n  Operations\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='commit_started', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Transaction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))",
                "definition": "@property\ndef commit_started (arg0: Transaction) -> bool: ...",
                "doc": "\nIndicates whether the commit of the transaction has already started.\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='commit_sync', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Transaction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None))",
                "definition": "def commit_sync(self: Transaction) -> None: ...",
                "doc": "commit_sync(self: tensorstore.Transaction) -> None\n\n\nSynchronously commits the transaction.\n\nEquivalent to :python:`self.commit_async().result()`.\n\nReturns:\n\n   :py:obj:`None` if the commit is successful, and raises an error otherwise.\n\nSee also:\n\n  - :py:obj:`.commit_async`\n  - :py:obj:`.abort`\n\nGroup:\n  Operations\n\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='future', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Transaction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Constant(value=None), ctx=Load()))",
                "definition": "@property\ndef future (arg0: Transaction) -> Future[None]: ...",
                "doc": "\nCommit result future.\n\nBecomes ready when the transaction has either been committed successfully or\naborted.\n\nGroup:\n  Accessors\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='open', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Transaction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))",
                "definition": "@property\ndef open (arg0: Transaction) -> bool: ...",
                "doc": "\nIndicates whether the transaction is still open.\n\nThe transaction remains open until commit starts or it is aborted.  Once commit\nstarts or it has been aborted, it may not be used for any additional\ntransactional operations.\n\nGroup:\n  Accessors\n",
                "type": "property"
            }
        ],
        "definition": "<class 'tensorstore.Transaction'>",
        "doc": "\n\nTransactions are used to stage a group of modifications (e.g. writes to\n:py:obj:`tensorstore.TensorStore` objects) in memory, and then either commit the\ngroup all at once or abort it.\n\nTwo transaction modes are currently supported:\n\n\"Isolated\" transactions provide write isolation: no modifications made are\nvisible or persist outside the transactions until the transaction is committed.\nIn addition to allowing modifications to be aborted/rolled back, this can also\nimprove efficiency by ensuring multiple writes to the same underlying storage\nkey are coalesced.\n\n\"Atomic isolated\" transactions have all the properties of \"isolated\"\ntransactions but additionally guarantee that all of the modifications will be\ncommitted atomically, i.e. at no point will an external reader observe only some\nbut not all of the modifications.  If the modifications made in the transaction\ncannot be committed atomically, the transaction will fail (without any changes\nbeing made).\n\nExample usage:\n\n    >>> txn = ts.Transaction()\n    >>> store = ts.open({\n    ...     'driver': 'n5',\n    ...     'kvstore': {\n    ...         'driver': 'file',\n    ...         'path': 'tmp/dataset/'\n    ...     },\n    ...     'metadata': {\n    ...         'dataType': 'uint16',\n    ...         'blockSize': [2, 3],\n    ...         'dimensions': [5, 6],\n    ...         'compression': {\n    ...             'type': 'raw'\n    ...         }\n    ...     },\n    ...     'create': True,\n    ...     'delete_existing': True\n    ... }).result()\n    >>> store.with_transaction(txn)[1:4, 2:5] = 42\n    >>> store.with_transaction(txn)[0:2, 4] = 43\n\nUncommitted changes made in a transaction are visible from a transactional read\nusing the same transaction, but not from a non-transactional read:\n\n    >>> store.with_transaction(txn).read().result()\n    array([[ 0,  0,  0,  0, 43,  0],\n           [ 0,  0, 42, 42, 43,  0],\n           [ 0,  0, 42, 42, 42,  0],\n           [ 0,  0, 42, 42, 42,  0],\n           [ 0,  0,  0,  0,  0,  0]], dtype=uint16)\n    >>> store.read().result()\n    array([[0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0]], dtype=uint16)\n\nThe transaction can be committed using :py:meth:`.commit_async`.\n\n    >>> txn.commit_async().result()\n    >>> store.read().result()\n    array([[ 0,  0,  0,  0, 43,  0],\n           [ 0,  0, 42, 42, 43,  0],\n           [ 0,  0, 42, 42, 42,  0],\n           [ 0,  0, 42, 42, 42,  0],\n           [ 0,  0,  0,  0,  0,  0]], dtype=uint16)\n\nThe :py:obj:`tensorstore.Transaction` class can also be used as a regular or\nasynchronous context manager:\n\n    >>> with ts.Transaction() as txn:\n    ...     store.with_transaction(txn)[0:2, 1:3] = 44\n    ...     store.with_transaction(txn)[0, 0] = 45\n    >>> store.read().result()\n    array([[45, 44, 44,  0, 43,  0],\n           [ 0, 44, 44, 42, 43,  0],\n           [ 0,  0, 42, 42, 42,  0],\n           [ 0,  0, 42, 42, 42,  0],\n           [ 0,  0,  0,  0,  0,  0]], dtype=uint16)\n\n    >>> async with ts.Transaction() as txn:\n    ...     store.with_transaction(txn)[0:2, 1:3] = 44\n    ...     store.with_transaction(txn)[0, 0] = 45\n    >>> await store.read()\n    array([[45, 44, 44,  0, 43,  0],\n           [ 0, 44, 44, 42, 43,  0],\n           [ 0,  0, 42, 42, 42,  0],\n           [ 0,  0, 42, 42, 42,  0],\n           [ 0,  0,  0,  0,  0,  0]], dtype=uint16)\n\nIf the block exits normally, the transaction is committed automatically.  If the\nblock raises an exception, the transaction is aborted.\n\nGroup:\n  Core\n\nConstructors\n============\n\nAccessors\n=========\n\nOperations\n==========\n\n",
        "type": "class"
    },
    "Unit": {
        "ast": "ClassDef(name='Unit', bases=[], keywords=[], body=[FunctionDef(name='base_unit', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Unit', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='multiplier', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Unit', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Unit', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "FunctionDef(name='base_unit', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Unit', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))",
                "definition": "@property\ndef base_unit (arg0: Unit) -> str: ...",
                "doc": "\nBase unit from which this unit is derived.\n\nExample:\n\n  >>> u = ts.Unit('3.5nm')\n  >>> u.base_unit\n  'nm'\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='multiplier', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='Unit', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))",
                "definition": "@property\ndef multiplier (arg0: Unit) -> float: ...",
                "doc": "\nMultiplier for the :py:obj:`.base_unit`.\n\nExample:\n\n  >>> u = ts.Unit('3.5nm')\n  >>> u.multiplier\n  3.5\n\nGroup:\n  Accessors\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='Unit', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='Any', ctx=Load()))",
                "definition": "def to_json(self: Unit) -> Any: ...",
                "doc": "to_json(self: tensorstore.Unit) -> Any\n\n\nConverts to the :json:schema:`JSON representation<Unit>`.\n\nExample:\n\n  >>> ts.Unit('3nm').to_json()\n  [3.0, 'nm']\n\nGroup:\n  Accessors\n\n\n",
                "type": "function"
            }
        ],
        "definition": "<class 'tensorstore.Unit'>",
        "doc": "\nSpecifies a physical quantity/unit.\n\nThe quantity is specified as the combination of:\n\n- A numerical :py:obj:`.multiplier`, represented as a\n  `double-precision floating-point number <https://en.wikipedia.org/wiki/Double-precision_floating-point_format>`_.\n  A multiplier of :python:`1` may be used to indicate a quanity equal to a\n  single base unit.\n\n- A :py:obj:`.base_unit`, represented as a string.  An empty string may be used\n  to indicate a dimensionless quantity.  In general, TensorStore does not\n  interpret the base unit string; some drivers impose additional constraints on\n  the base unit, while other drivers may store the specified unit directly.  It\n  is recommended to follow the\n  `udunits2 syntax <https://www.unidata.ucar.edu/software/udunits/udunits-2.0.4/udunits2lib.html#Syntax>`_\n  unless there is a specific need to deviate.\n\nObjects of this type are immutable.\n\nGroup:\n  Spec\n",
        "type": "class"
    },
    "VirtualChunkedReadParameters": {
        "ast": "ClassDef(name='VirtualChunkedReadParameters', bases=[], keywords=[], body=[FunctionDef(name='if_not_equal', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='VirtualChunkedReadParameters', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bytes', ctx=Load())), FunctionDef(name='staleness_bound', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='VirtualChunkedReadParameters', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "FunctionDef(name='if_not_equal', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='VirtualChunkedReadParameters', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bytes', ctx=Load()))",
                "definition": "@property\ndef if_not_equal (arg0: VirtualChunkedReadParameters) -> bytes: ...",
                "doc": "\nCached generation, read request can be skipped if no newer data is available.\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='staleness_bound', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='VirtualChunkedReadParameters', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))",
                "definition": "@property\ndef staleness_bound (arg0: VirtualChunkedReadParameters) -> float: ...",
                "doc": "\nRead may be fulfilled with cached data no older than the specified bound.\n",
                "type": "property"
            }
        ],
        "definition": "<class 'tensorstore.VirtualChunkedReadParameters'>",
        "doc": "\nOptions passed to read callbacks used with :py:obj:`.virtual_chunked`.\n\nGroup:\n  Virtual views\n",
        "type": "class"
    },
    "VirtualChunkedWriteParameters": {
        "ast": "ClassDef(name='VirtualChunkedWriteParameters', bases=[], keywords=[], body=[FunctionDef(name='if_equal', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='VirtualChunkedWriteParameters', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bytes', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "FunctionDef(name='if_equal', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='VirtualChunkedWriteParameters', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bytes', ctx=Load()))",
                "definition": "@property\ndef if_equal (arg0: VirtualChunkedWriteParameters) -> bytes: ...",
                "doc": "\nIf non-empty, writeback should be conditioned on the existing data matching the specified generation.\n",
                "type": "property"
            }
        ],
        "definition": "<class 'tensorstore.VirtualChunkedWriteParameters'>",
        "doc": "\nOptions passed to write callbacks used with :py:obj:`.virtual_chunked`.\n\nGroup:\n  Virtual views\n",
        "type": "class"
    },
    "WriteFutures": {
        "ast": "ClassDef(name='WriteFutures', bases=[], keywords=[], body=[FunctionDef(name='add_done_callback', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='WriteFutures', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='Future', ctx=Load())], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='cancel', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='WriteFutures', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='cancelled', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='WriteFutures', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='commit', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='WriteFutures', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Constant(value=None), ctx=Load())), FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='WriteFutures', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Constant(value=None), ctx=Load())), FunctionDef(name='done', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='WriteFutures', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='exception', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='WriteFutures', ctx=Load())), arg(arg='timeout', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='deadline', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='object', ctx=Load())), FunctionDef(name='remove_done_callback', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='WriteFutures', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='Future', ctx=Load())], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='result', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='WriteFutures', ctx=Load())), arg(arg='timeout', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='deadline', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='object', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "FunctionDef(name='add_done_callback', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='WriteFutures', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='Future', ctx=Load())], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None))",
                "definition": "def add_done_callback(self: WriteFutures, callback: Callable[[Future], None]) -> None: ...",
                "doc": "add_done_callback(self: tensorstore.WriteFutures, callback: Callable[[tensorstore.Future], None]) -> None\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='cancel', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='WriteFutures', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='bool', ctx=Load()))",
                "definition": "def cancel(self: WriteFutures) -> bool: ...",
                "doc": "cancel(self: tensorstore.WriteFutures) -> bool\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='cancelled', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='WriteFutures', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='bool', ctx=Load()))",
                "definition": "def cancelled(self: WriteFutures) -> bool: ...",
                "doc": "cancelled(self: tensorstore.WriteFutures) -> bool\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='commit', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='WriteFutures', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Constant(value=None), ctx=Load()))",
                "definition": "@property\ndef commit (arg0: WriteFutures) -> Future[None]: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='WriteFutures', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Constant(value=None), ctx=Load()))",
                "definition": "@property\ndef copy (arg0: WriteFutures) -> Future[None]: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='done', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='WriteFutures', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='bool', ctx=Load()))",
                "definition": "def done(self: WriteFutures) -> bool: ...",
                "doc": "done(self: tensorstore.WriteFutures) -> bool\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='exception', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='WriteFutures', ctx=Load())), arg(arg='timeout', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='deadline', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='object', ctx=Load()))",
                "definition": "def exception(self: WriteFutures, timeout: Optional[float] = None, deadline: Optional[float] = None) -> object: ...",
                "doc": "exception(self: tensorstore.WriteFutures, timeout: Optional[float] = None, deadline: Optional[float] = None) -> object\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='remove_done_callback', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='WriteFutures', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='Future', ctx=Load())], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='int', ctx=Load()))",
                "definition": "def remove_done_callback(self: WriteFutures, callback: Callable[[Future], None]) -> int: ...",
                "doc": "remove_done_callback(self: tensorstore.WriteFutures, callback: Callable[[tensorstore.Future], None]) -> int\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='result', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='WriteFutures', ctx=Load())), arg(arg='timeout', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='deadline', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='object', ctx=Load()))",
                "definition": "def result(self: WriteFutures, timeout: Optional[float] = None, deadline: Optional[float] = None) -> object: ...",
                "doc": "result(self: tensorstore.WriteFutures, timeout: Optional[float] = None, deadline: Optional[float] = None) -> object\n",
                "type": "function"
            }
        ],
        "definition": "<class 'tensorstore.WriteFutures'>",
        "doc": "\nHandle for consuming the result of an asynchronous write operation.\n\nThis holds two futures:\n\n- The :py:obj:`.copy` future indicates when reading has completed, after which\n  the source is no longer accessed.\n\n- The :py:obj:`.commit` future indicates when the write is guaranteed to be\n  reflected in subsequent reads.  For non-transactional writes, the\n  :py:obj:`.commit` future completes successfully only once durability of the\n  write is guaranteed (subject to the limitations of the underlying storage\n  mechanism).  For transactional writes, the :py:obj:`.commit` future merely\n  indicates when the write is reflected in subsequent reads using the same\n  transaction.  Durability is *not* guaranteed until the transaction itself is\n  committed successfully.\n\nIn addition, this class also provides the same interface as :py:class:`Future`,\nwhich simply forwards to the corresponding operation on the :py:obj:`.commit`\nfuture.\n\nSee also:\n  - :py:meth:`TensorStore.write`\n\nGroup:\n  Asynchronous support\n",
        "type": "class"
    },
    "array": {
        "ast": "FunctionDef(name='array', args=arguments(posonlyargs=[], args=[arg(arg='array', annotation=Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load())), arg(arg='dtype', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='dtype', ctx=Load()), ctx=Load())), arg(arg='context', annotation=Name(id='Context', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='TensorStore', ctx=Load()))",
        "definition": "def array(array: numpy.typing.ArrayLike, dtype: Optional[dtype] = None, context: Context = None) -> TensorStore: ...",
        "doc": "array(array: numpy.typing.ArrayLike, dtype: Optional[tensorstore.dtype] = None, context: tensorstore.Context = None) -> tensorstore.TensorStore\n\n\nReturns a TensorStore that reads/writes from an in-memory array.\n\nArgs:\n  array: Source array.\n  dtype: Data type to which :python:`array` will be converted.\n  context: Context to use.\n\nGroup:\n  Views\n\n",
        "type": "function"
    },
    "bfloat16": {
        "ast": "Assign(targets=[Name(id='bfloat16', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='bfloat16')], keywords=[]))",
        "definition": "dtype(\"bfloat16\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "bool": {
        "ast": "Assign(targets=[Name(id='bool', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='bool')], keywords=[]))",
        "definition": "dtype(\"bool\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "byte": {
        "ast": "Assign(targets=[Name(id='byte', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='byte')], keywords=[]))",
        "definition": "dtype(\"byte\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "cast": {
        "ast": "FunctionDef(name='cast', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[])",
        "definition": "def cast(*args, **kwargs): ...",
        "doc": "cast(*args, **kwargs)\nOverloaded function.\n\n1. cast(base: tensorstore.TensorStore, dtype: tensorstore.dtype) -> tensorstore.TensorStore\n\n\nReturns a read/write view with the data type converted.\n\nExample:\n\n    >>> array = ts.array([1.5, 2.5, 3.5, 4.5, 5.5], dtype=ts.float32)\n    >>> view = ts.cast(array, ts.uint32)\n    >>> view\n    TensorStore({\n      'base': {\n        'array': [1.5, 2.5, 3.5, 4.5, 5.5],\n        'driver': 'array',\n        'dtype': 'float32',\n      },\n      'context': {'data_copy_concurrency': {}},\n      'driver': 'cast',\n      'dtype': 'uint32',\n      'transform': {'input_exclusive_max': [5], 'input_inclusive_min': [0]},\n    })\n    >>> await view.read()\n    array([1, 2, 3, 4, 5], dtype=uint32)\n\nOverload:\n  store\n\nGroup:\n  Views\n\n\n2. cast(base: tensorstore.Spec, dtype: tensorstore.dtype) -> tensorstore.Spec\n\n\nReturns a view with the data type converted.\n\nExample:\n\n    >>> base = ts.Spec({\"driver\": \"zarr\", \"kvstore\": \"memory://\"})\n    >>> view = ts.cast(base, ts.uint32)\n    >>> view\n    Spec({\n      'base': {'driver': 'zarr', 'kvstore': {'driver': 'memory'}},\n      'driver': 'cast',\n      'dtype': 'uint32',\n    })\n\nOverload:\n  spec\n\nGroup:\n  Views\n\n",
        "type": "function"
    },
    "char": {
        "ast": "Assign(targets=[Name(id='char', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='char')], keywords=[]))",
        "definition": "dtype(\"char\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "complex128": {
        "ast": "Assign(targets=[Name(id='complex128', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='complex128')], keywords=[]))",
        "definition": "dtype(\"complex128\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "complex64": {
        "ast": "Assign(targets=[Name(id='complex64', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='complex64')], keywords=[]))",
        "definition": "dtype(\"complex64\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "concat": {
        "ast": "FunctionDef(name='concat', args=arguments(posonlyargs=[], args=[arg(arg='layers', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='TensorStore', ctx=Load()), Name(id='Spec', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='axis', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='read', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='write', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Context', ctx=Load()), ctx=Load())), arg(arg='transaction', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Transaction', ctx=Load()), ctx=Load())), arg(arg='rank', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='dtype', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='dtype', ctx=Load()), ctx=Load())), arg(arg='domain', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='IndexDomain', ctx=Load()), ctx=Load())), arg(arg='shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='dimension_units', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Unit', ctx=Load()), Name(id='str', ctx=Load()), Name(id='Real', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='Real', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='schema', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Schema', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='TensorStore', ctx=Load()))",
        "definition": "def concat(layers: Sequence[Union[TensorStore, Spec]], axis: Union[int, str], *, read: Optional[bool] = None, write: Optional[bool] = None, context: Optional[Context] = None, transaction: Optional[Transaction] = None, rank: Optional[int] = None, dtype: Optional[dtype] = None, domain: Optional[IndexDomain] = None, shape: Optional[Sequence[int]] = None, dimension_units: Optional[Sequence[Optional[Union[Unit, str, Real, Tuple[Real, str]]]]] = None, schema: Optional[Schema] = None) -> TensorStore: ...",
        "doc": "concat(layers: Sequence[Union[tensorstore.TensorStore, tensorstore.Spec]], axis: Union[int, str], *, read: Optional[bool] = None, write: Optional[bool] = None, context: Optional[tensorstore.Context] = None, transaction: Optional[tensorstore.Transaction] = None, rank: Optional[int] = None, dtype: Optional[tensorstore.dtype] = None, domain: Optional[tensorstore.IndexDomain] = None, shape: Optional[Sequence[int]] = None, dimension_units: Optional[Sequence[Optional[Union[tensorstore.Unit, str, Real, Tuple[Real, str]]]]] = None, schema: Optional[tensorstore.Schema] = None) -> tensorstore.TensorStore\n\n\nVirtually concatenates a sequence of :py:obj:`TensorStore` layers along an existing dimension.\n\n    >>> store = ts.concat([\n    ...     ts.array([1, 2, 3, 4], dtype=ts.uint32),\n    ...     ts.array([5, 6, 7, 8], dtype=ts.uint32)\n    ... ],\n    ...                   axis=0)\n    >>> store\n    TensorStore({\n      'context': {'data_copy_concurrency': {}},\n      'driver': 'stack',\n      'dtype': 'uint32',\n      'layers': [\n        {\n          'array': [1, 2, 3, 4],\n          'driver': 'array',\n          'dtype': 'uint32',\n          'transform': {'input_exclusive_max': [4], 'input_inclusive_min': [0]},\n        },\n        {\n          'array': [5, 6, 7, 8],\n          'driver': 'array',\n          'dtype': 'uint32',\n          'transform': {\n            'input_exclusive_max': [8],\n            'input_inclusive_min': [4],\n            'output': [{'input_dimension': 0, 'offset': -4}],\n          },\n        },\n      ],\n      'schema': {'domain': {'exclusive_max': [8], 'inclusive_min': [0]}},\n      'transform': {'input_exclusive_max': [8], 'input_inclusive_min': [0]},\n    })\n    >>> await store.read()\n    array([1, 2, 3, 4, 5, 6, 7, 8], dtype=uint32)\n    >>> store = ts.concat([\n    ...     ts.array([[1, 2, 3], [4, 5, 6]], dtype=ts.uint32),\n    ...     ts.array([[7, 8, 9], [10, 11, 12]], dtype=ts.uint32)\n    ... ],\n    ...                   axis=0)\n    >>> store\n    TensorStore({\n      'context': {'data_copy_concurrency': {}},\n      'driver': 'stack',\n      'dtype': 'uint32',\n      'layers': [\n        {\n          'array': [[1, 2, 3], [4, 5, 6]],\n          'driver': 'array',\n          'dtype': 'uint32',\n          'transform': {\n            'input_exclusive_max': [2, 3],\n            'input_inclusive_min': [0, 0],\n          },\n        },\n        {\n          'array': [[7, 8, 9], [10, 11, 12]],\n          'driver': 'array',\n          'dtype': 'uint32',\n          'transform': {\n            'input_exclusive_max': [4, 3],\n            'input_inclusive_min': [2, 0],\n            'output': [\n              {'input_dimension': 0, 'offset': -2},\n              {'input_dimension': 1},\n            ],\n          },\n        },\n      ],\n      'schema': {'domain': {'exclusive_max': [4, 3], 'inclusive_min': [0, 0]}},\n      'transform': {'input_exclusive_max': [4, 3], 'input_inclusive_min': [0, 0]},\n    })\n    >>> await store.read()\n    array([[ 1,  2,  3],\n           [ 4,  5,  6],\n           [ 7,  8,  9],\n           [10, 11, 12]], dtype=uint32)\n    >>> store = ts.concat([\n    ...     ts.array([[1, 2, 3], [4, 5, 6]], dtype=ts.uint32),\n    ...     ts.array([[7, 8, 9], [10, 11, 12]], dtype=ts.uint32)\n    ... ],\n    ...                   axis=-1)\n    >>> store\n    TensorStore({\n      'context': {'data_copy_concurrency': {}},\n      'driver': 'stack',\n      'dtype': 'uint32',\n      'layers': [\n        {\n          'array': [[1, 2, 3], [4, 5, 6]],\n          'driver': 'array',\n          'dtype': 'uint32',\n          'transform': {\n            'input_exclusive_max': [2, 3],\n            'input_inclusive_min': [0, 0],\n          },\n        },\n        {\n          'array': [[7, 8, 9], [10, 11, 12]],\n          'driver': 'array',\n          'dtype': 'uint32',\n          'transform': {\n            'input_exclusive_max': [2, 6],\n            'input_inclusive_min': [0, 3],\n            'output': [\n              {'input_dimension': 0},\n              {'input_dimension': 1, 'offset': -3},\n            ],\n          },\n        },\n      ],\n      'schema': {'domain': {'exclusive_max': [2, 6], 'inclusive_min': [0, 0]}},\n      'transform': {'input_exclusive_max': [2, 6], 'input_inclusive_min': [0, 0]},\n    })\n    >>> await store.read()\n    array([[ 1,  2,  3,  7,  8,  9],\n           [ 4,  5,  6, 10, 11, 12]], dtype=uint32)\n    >>> await ts.concat([\n    ...     ts.array([[1, 2, 3], [4, 5, 6]], dtype=ts.uint32).label[\"x\", \"y\"],\n    ...     ts.array([[7, 8, 9], [10, 11, 12]], dtype=ts.uint32)\n    ... ],\n    ...                 axis=\"y\").read()\n    array([[ 1,  2,  3,  7,  8,  9],\n           [ 4,  5,  6, 10, 11, 12]], dtype=uint32)\n\nArgs:\n\n  layers: Sequence of layers to concatenate.  If a layer is specified as a\n    :py:obj:`Spec` rather than a :py:obj:`TensorStore`, it must have a known\n    :py:obj:`~Spec.domain` and will be opened on-demand as needed for individual\n    read and write operations.\n\n  axis: Existing dimension along which to concatenate.  A negative number counts\n    from the end.  May also be specified by a\n    :ref:`dimension label<dimension-labels>`.\n  read: Allow read access.  Defaults to `True` if neither ``read`` nor ``write`` is specified.\n  write: Allow write access.  Defaults to `True` if neither ``read`` nor ``write`` is specified.\n  context: Shared resource context.  Defaults to a new (unshared) context with default\n    options, as returned by :py:meth:`tensorstore.Context`.  To share resources,\n    such as cache pools, between multiple open TensorStores, you must specify a\n    context.\n  transaction: Transaction to use for opening/creating, and for subsequent operations.  By\n    default, the open is non-transactional.\n    \n    .. note::\n    \n       To perform transactional operations using a :py:obj:`TensorStore` that was\n       previously opened without a transaction, use\n       :py:obj:`TensorStore.with_transaction`.\n  rank: Constrains the rank of the TensorStore.  If there is an index transform, the\n    rank constraint must match the rank of the *input* space.\n  dtype: Constrains the data type of the TensorStore.  If a data type has already been\n    set, it is an error to specify a different data type.\n  domain: Constrains the domain of the TensorStore.  If there is an existing\n    domain, the specified domain is merged with it as follows:\n    \n    1. The rank must match the existing rank.\n    \n    2. All bounds must match, except that a finite or explicit bound is permitted to\n       match an infinite and implicit bound, and takes precedence.\n    \n    3. If both the new and existing domain specify non-empty labels for a dimension,\n       the labels must be equal.  If only one of the domains specifies a non-empty\n       label for a dimension, the non-empty label takes precedence.\n    \n    Note that if there is an index transform, the domain must match the *input*\n    space, not the output space.\n  shape: Constrains the shape and origin of the TensorStore.  Equivalent to specifying a\n    :py:param:`domain` of :python:`ts.IndexDomain(shape=shape)`.\n    \n    .. note::\n    \n       This option also constrains the origin of all dimensions to be zero.\n  dimension_units: Specifies the physical units of each dimension of the domain.\n    \n    The *physical unit* for a dimension is the physical quantity corresponding to a\n    single index increment along each dimension.\n    \n    A value of :python:`None` indicates that the unit is unknown.  A dimension-less\n    quantity can be indicated by a unit of :python:`\"\"`.\n  schema: Additional schema constraints to merge with existing constraints.\n\n\nSee also:\n  - :py:obj:`numpy.concatenate`\n  - :ref:`stack-driver`\n  - :py:obj:`tensorstore.overlay`\n  - :py:obj:`tensorstore.stack`\n\nGroup:\n  Views\n\n",
        "type": "function"
    },
    "d": {
        "ast": "ClassDef(name='d', bases=[], keywords=[], body=[FunctionDef(name='diagonal', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='DimExpression', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='DimExpression', ctx=Load())), FunctionDef(name='label', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Label', ctx=Load())), FunctionDef(name='mark_bounds_implicit', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_MarkBoundsImplicit', ctx=Load())), FunctionDef(name='oindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Oindex', ctx=Load())), FunctionDef(name='stride', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Stride', ctx=Load())), FunctionDef(name='translate_backward_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_TranslateBackwardBy', ctx=Load())), FunctionDef(name='translate_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_TranslateBy', ctx=Load())), FunctionDef(name='translate_to', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_TranslateTo', ctx=Load())), FunctionDef(name='transpose', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Transpose', ctx=Load())), FunctionDef(name='vindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Vindex', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "definition": "<class 'tensorstore.DimExpression._Label'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.DimExpression._MarkBoundsImplicit'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.DimExpression._Oindex'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.DimExpression._Stride'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.DimExpression._TranslateBackwardBy'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.DimExpression._TranslateBy'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.DimExpression._TranslateTo'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.DimExpression._Transpose'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "definition": "<class 'tensorstore.DimExpression._Vindex'>",
                "doc": null,
                "type": "unknown_type"
            },
            {
                "ast": "FunctionDef(name='diagonal', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='DimExpression', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='DimExpression', ctx=Load()))",
                "definition": "@property\ndef diagonal (arg0: DimExpression) -> DimExpression: ...",
                "doc": "\nExtracts the diagonal of the selected dimensions.\n\nThe selection dimensions are removed from the resultant index space, and a new\ndimension corresponding to the diagonal is added as the first dimension, with an\ninput domain equal to the intersection of the input domains of the selection\ndimensions.  The new dimension selection is equal to :python:`ts.d[0]`,\ncorresponding to the newly added diagonal dimension.\n\nThe lower and upper bounds of the new diagonal dimension are\n:ref:`implicit<implicit-bounds>` if, and only if, the lower or upper bounds,\nrespectively, of every selected dimension are implicit.\n\nExamples:\n\n    >>> transform = ts.IndexTransform(input_shape=[2, 3],\n    ...                               input_labels=[\"x\", \"y\"])\n    >>> transform[ts.d['x', 'y'].diagonal]\n    Rank 1 -> 2 index space transform:\n      Input domain:\n        0: [0, 2)\n      Output index maps:\n        out[0] = 0 + 1 * in[0]\n        out[1] = 0 + 1 * in[0]\n    >>> transform = ts.IndexTransform(3)\n    >>> transform[ts.d[0, 2].diagonal]\n    Rank 2 -> 3 index space transform:\n      Input domain:\n        0: (-inf*, +inf*)\n        1: (-inf*, +inf*)\n      Output index maps:\n        out[0] = 0 + 1 * in[0]\n        out[1] = 0 + 1 * in[1]\n        out[2] = 0 + 1 * in[0]\n\nNote:\n\n  If zero dimensions are selected, :py:obj:`.diagonal` simply results in a new singleton\n  dimension as the first dimension, equivalent to :python:`[ts.newaxis]`:\n\n  >>> transform = ts.IndexTransform(1)\n  >>> transform[ts.d[()].diagonal]\n  Rank 2 -> 1 index space transform:\n    Input domain:\n      0: (-inf*, +inf*)\n      1: (-inf*, +inf*)\n    Output index maps:\n      out[0] = 0 + 1 * in[1]\n\n  If only one dimension is selected, :py:obj:`.diagonal` is equivalent to\n  :python:`.label[''].transpose[0]`:\n\n  >>> transform = ts.IndexTransform(input_labels=['x', 'y'])\n  >>> transform[ts.d[1].diagonal]\n  Rank 2 -> 2 index space transform:\n    Input domain:\n      0: (-inf*, +inf*)\n      1: (-inf*, +inf*) \"x\"\n    Output index maps:\n      out[0] = 0 + 1 * in[1]\n      out[1] = 0 + 1 * in[0]\n\nGroup:\n  Operations\n\n",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='label', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Label', ctx=Load()))",
                "definition": "@property\ndef label (arg0: object) -> DimExpression._Label: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='mark_bounds_implicit', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_MarkBoundsImplicit', ctx=Load()))",
                "definition": "@property\ndef mark_bounds_implicit (arg0: object) -> DimExpression._MarkBoundsImplicit: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='oindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Oindex', ctx=Load()))",
                "definition": "@property\ndef oindex (arg0: object) -> DimExpression._Oindex: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='stride', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Stride', ctx=Load()))",
                "definition": "@property\ndef stride (arg0: object) -> DimExpression._Stride: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='translate_backward_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_TranslateBackwardBy', ctx=Load()))",
                "definition": "@property\ndef translate_backward_by (arg0: object) -> DimExpression._TranslateBackwardBy: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='translate_by', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_TranslateBy', ctx=Load()))",
                "definition": "@property\ndef translate_by (arg0: object) -> DimExpression._TranslateBy: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='translate_to', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_TranslateTo', ctx=Load()))",
                "definition": "@property\ndef translate_to (arg0: object) -> DimExpression._TranslateTo: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='transpose', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Transpose', ctx=Load()))",
                "definition": "@property\ndef transpose (arg0: object) -> DimExpression._Transpose: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='vindex', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='DimExpression', ctx=Load()), attr='_Vindex', ctx=Load()))",
                "definition": "@property\ndef vindex (arg0: object) -> DimExpression._Vindex: ...",
                "doc": "",
                "type": "property"
            }
        ],
        "definition": "<class 'tensorstore.d'>",
        "doc": "\nSpecifies a dimension selection, for starting a :ref:`dimension expression<python-dim-expressions>`.\n\nA dimension selection specifies a sequence of dimensions, either by index or\n:ref:`label<dimension-labels>`.\n\n:ref:`python-dim-selections` may be used as part of a\n:ref:`dimension expression<python-dim-expression-construction>` to specify the\ndimensions to which an indexing operation applies.\n\nGroup:\n  Indexing\n\nConstructors\n============\n\nOperations\n==========\n\n",
        "type": "class"
    },
    "downsample": {
        "ast": "FunctionDef(name='downsample', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[])",
        "definition": "def downsample(*args, **kwargs): ...",
        "doc": "downsample(*args, **kwargs)\nOverloaded function.\n\n1. downsample(base: tensorstore.TensorStore, downsample_factors: List[int], method: DownsampleMethod) -> tensorstore.TensorStore\n\n\nReturns a virtual :ref:`downsampled view<driver/downsample>` of a :py:obj:`TensorStore`.\n\nGroup:\n  Views\n\nOverload:\n  store\n\n\n2. downsample(base: tensorstore.Spec, downsample_factors: List[int], method: DownsampleMethod) -> tensorstore.Spec\n\n\nReturns a virtual :ref:`downsampled view<driver/downsample>` view of a :py:obj:`Spec`.\n\nGroup:\n  Views\n\nOverload:\n  spec\n\n",
        "type": "function"
    },
    "dtype": {
        "ast": "ClassDef(name='dtype', bases=[], keywords=[], body=[FunctionDef(name='name', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='dtype', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='numpy_dtype', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='dtype', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='dtype', ctx=Load())), FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='dtype', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='type', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='dtype', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='object', ctx=Load()))], decorator_list=[])",
        "children": [
            {
                "ast": "FunctionDef(name='name', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='dtype', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))",
                "definition": "@property\ndef name (arg0: dtype) -> str: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='numpy_dtype', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='dtype', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='dtype', ctx=Load()))",
                "definition": "@property\ndef numpy_dtype (arg0: dtype) -> dtype: ...",
                "doc": "",
                "type": "property"
            },
            {
                "ast": "FunctionDef(name='to_json', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='dtype', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='str', ctx=Load()))",
                "definition": "def to_json(self: dtype) -> str: ...",
                "doc": "to_json(self: tensorstore.dtype) -> str\n",
                "type": "function"
            },
            {
                "ast": "FunctionDef(name='type', args=arguments(posonlyargs=[], args=[arg(arg='arg0', annotation=Name(id='dtype', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='object', ctx=Load()))",
                "definition": "@property\ndef type (arg0: dtype) -> object: ...",
                "doc": "",
                "type": "property"
            }
        ],
        "definition": "<class 'tensorstore.dtype'>",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "class"
    },
    "experimental_collect_matching_metrics": {
        "ast": "FunctionDef(name='experimental_collect_matching_metrics', args=arguments(posonlyargs=[], args=[arg(arg='metric_prefix', annotation=Name(id='str', ctx=Load())), arg(arg='include_zero_metrics', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=''), Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Any', ctx=Load()), ctx=Load()))",
        "definition": "def experimental_collect_matching_metrics(metric_prefix: str = '', include_zero_metrics: bool = False) -> List[Any]: ...",
        "doc": "experimental_collect_matching_metrics(metric_prefix: str = '', include_zero_metrics: bool = False) -> List[Any]\n\n\nCollects metrics with a matching prefix.\n\nArgs:\n  metric_prefix: Prefix of the metric names to collect.\n  include_zero_metrics: Indicate whether zero-valued metrics are included.\n\nReturns:\n  :py:obj:`list` of a :py:obj:`dict` of metrics.\n\nGroup:\n  Experimental\n\n",
        "type": "function"
    },
    "experimental_collect_prometheus_format_metrics": {
        "ast": "FunctionDef(name='experimental_collect_prometheus_format_metrics', args=arguments(posonlyargs=[], args=[arg(arg='metric_prefix', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='')]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))",
        "definition": "def experimental_collect_prometheus_format_metrics(metric_prefix: str = '') -> List[str]: ...",
        "doc": "experimental_collect_prometheus_format_metrics(metric_prefix: str = '') -> List[str]\n\n\nCollects metrics in prometheus exposition format.\nSee: https://prometheus.io/docs/instrumenting/exposition_formats/\n\nArgs:\n  metric_prefix: Prefix of the metric names to collect.\n\nReturns:\n  :py:obj:`list` of a :py:obj:`str` of prometheus exposition format metrics.\n\nGroup:\n  Experimental\n\n",
        "type": "function"
    },
    "experimental_push_metrics_to_prometheus": {
        "ast": "FunctionDef(name='experimental_push_metrics_to_prometheus', args=arguments(posonlyargs=[], args=[arg(arg='pushgateway', annotation=Name(id='str', ctx=Load())), arg(arg='job', annotation=Name(id='str', ctx=Load())), arg(arg='instance', annotation=Name(id='str', ctx=Load())), arg(arg='metric_prefix', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=''), Constant(value=''), Constant(value=''), Constant(value='')]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))",
        "definition": "def experimental_push_metrics_to_prometheus(pushgateway: str = '', job: str = '', instance: str = '', metric_prefix: str = '') -> Future[int]: ...",
        "doc": "experimental_push_metrics_to_prometheus(pushgateway: str = '', job: str = '', instance: str = '', metric_prefix: str = '') -> tensorstore.Future[int]\n\n\nPublishes metrics to the prometheus pushgateway.\nSee: https://github.com/prometheus/pushgateway\n\nArgs:\n  pushgateway: prometheus pushgateway url, like 'http://localhost:1234/'\n  job: prometheus job name\n  instance: prometheus instance identifier\n  metric_prefix: Prefix of the metric names to publish.\n\nReturns:\n  A future with the response status code.\n\nGroup:\n  Experimental\n\n",
        "type": "function"
    },
    "float16": {
        "ast": "Assign(targets=[Name(id='float16', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='float16')], keywords=[]))",
        "definition": "dtype(\"float16\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "float32": {
        "ast": "Assign(targets=[Name(id='float32', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='float32')], keywords=[]))",
        "definition": "dtype(\"float32\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "float64": {
        "ast": "Assign(targets=[Name(id='float64', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='float64')], keywords=[]))",
        "definition": "dtype(\"float64\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "float8_e4m3b11fnuz": {
        "ast": "Assign(targets=[Name(id='float8_e4m3b11fnuz', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='float8_e4m3b11fnuz')], keywords=[]))",
        "definition": "dtype(\"float8_e4m3b11fnuz\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "float8_e4m3fn": {
        "ast": "Assign(targets=[Name(id='float8_e4m3fn', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='float8_e4m3fn')], keywords=[]))",
        "definition": "dtype(\"float8_e4m3fn\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "float8_e4m3fnuz": {
        "ast": "Assign(targets=[Name(id='float8_e4m3fnuz', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='float8_e4m3fnuz')], keywords=[]))",
        "definition": "dtype(\"float8_e4m3fnuz\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "float8_e5m2": {
        "ast": "Assign(targets=[Name(id='float8_e5m2', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='float8_e5m2')], keywords=[]))",
        "definition": "dtype(\"float8_e5m2\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "float8_e5m2fnuz": {
        "ast": "Assign(targets=[Name(id='float8_e5m2fnuz', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='float8_e5m2fnuz')], keywords=[]))",
        "definition": "dtype(\"float8_e5m2fnuz\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "inf": {
        "ast": "Assign(targets=[Name(id='inf', ctx=Store())], value=Constant(value=4611686018427387903))",
        "definition": "4611686018427387903",
        "doc": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
        "type": "unknown"
    },
    "int16": {
        "ast": "Assign(targets=[Name(id='int16', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='int16')], keywords=[]))",
        "definition": "dtype(\"int16\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "int32": {
        "ast": "Assign(targets=[Name(id='int32', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='int32')], keywords=[]))",
        "definition": "dtype(\"int32\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "int4": {
        "ast": "Assign(targets=[Name(id='int4', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='int4')], keywords=[]))",
        "definition": "dtype(\"int4\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "int64": {
        "ast": "Assign(targets=[Name(id='int64', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='int64')], keywords=[]))",
        "definition": "dtype(\"int64\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "int8": {
        "ast": "Assign(targets=[Name(id='int8', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='int8')], keywords=[]))",
        "definition": "dtype(\"int8\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "json": {
        "ast": "Assign(targets=[Name(id='json', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='json')], keywords=[]))",
        "definition": "dtype(\"json\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "newaxis": {
        "ast": "Assign(targets=[Name(id='newaxis', ctx=Store())], value=Constant(value=None))",
        "definition": "None",
        "doc": null,
        "type": "unknown"
    },
    "open": {
        "ast": "FunctionDef(name='open', args=arguments(posonlyargs=[], args=[arg(arg='spec', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Spec', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='read', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='write', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='open_mode', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='OpenMode', ctx=Load()), ctx=Load())), arg(arg='open', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='create', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='delete_existing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='assume_metadata', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='assume_cached_metadata', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Context', ctx=Load()), ctx=Load())), arg(arg='transaction', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Transaction', ctx=Load()), ctx=Load())), arg(arg='kvstore', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='KvStore', ctx=Load()), attr='Spec', ctx=Load()), ctx=Load())), arg(arg='rank', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='dtype', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='dtype', ctx=Load()), ctx=Load())), arg(arg='domain', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='IndexDomain', ctx=Load()), ctx=Load())), arg(arg='shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='chunk_layout', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='ChunkLayout', ctx=Load()), ctx=Load())), arg(arg='codec', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='CodecSpec', ctx=Load()), ctx=Load())), arg(arg='fill_value', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load()), ctx=Load())), arg(arg='dimension_units', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Unit', ctx=Load()), Name(id='str', ctx=Load()), Name(id='Real', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='Real', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='schema', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Schema', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Future', ctx=Load()), slice=Name(id='TensorStore', ctx=Load()), ctx=Load()))",
        "definition": "def open(spec: Union[Spec, Any], *, read: Optional[bool] = None, write: Optional[bool] = None, open_mode: Optional[OpenMode] = None, open: Optional[bool] = None, create: Optional[bool] = None, delete_existing: Optional[bool] = None, assume_metadata: Optional[bool] = None, assume_cached_metadata: Optional[bool] = None, context: Optional[Context] = None, transaction: Optional[Transaction] = None, kvstore: Optional[KvStore.Spec] = None, rank: Optional[int] = None, dtype: Optional[dtype] = None, domain: Optional[IndexDomain] = None, shape: Optional[Sequence[int]] = None, chunk_layout: Optional[ChunkLayout] = None, codec: Optional[CodecSpec] = None, fill_value: Optional[numpy.typing.ArrayLike] = None, dimension_units: Optional[Sequence[Optional[Union[Unit, str, Real, Tuple[Real, str]]]]] = None, schema: Optional[Schema] = None) -> Future[TensorStore]: ...",
        "doc": "open(spec: Union[tensorstore.Spec, Any], *, read: Optional[bool] = None, write: Optional[bool] = None, open_mode: Optional[tensorstore.OpenMode] = None, open: Optional[bool] = None, create: Optional[bool] = None, delete_existing: Optional[bool] = None, assume_metadata: Optional[bool] = None, assume_cached_metadata: Optional[bool] = None, context: Optional[tensorstore.Context] = None, transaction: Optional[tensorstore.Transaction] = None, kvstore: Optional[tensorstore.KvStore.Spec] = None, rank: Optional[int] = None, dtype: Optional[tensorstore.dtype] = None, domain: Optional[tensorstore.IndexDomain] = None, shape: Optional[Sequence[int]] = None, chunk_layout: Optional[tensorstore.ChunkLayout] = None, codec: Optional[tensorstore.CodecSpec] = None, fill_value: Optional[numpy.typing.ArrayLike] = None, dimension_units: Optional[Sequence[Optional[Union[tensorstore.Unit, str, Real, Tuple[Real, str]]]]] = None, schema: Optional[tensorstore.Schema] = None) -> tensorstore.Future[tensorstore.TensorStore]\n\n\nOpens or creates a :py:class:`TensorStore` from a :py:class:`Spec`.\n\n    >>> store = await ts.open(\n    ...     {\n    ...         'driver': 'zarr',\n    ...         'kvstore': {\n    ...             'driver': 'memory'\n    ...         }\n    ...     },\n    ...     create=True,\n    ...     dtype=ts.int32,\n    ...     shape=[1000, 2000, 3000],\n    ...     chunk_layout=ts.ChunkLayout(inner_order=[2, 1, 0]),\n    ... )\n    >>> store\n    TensorStore({\n      'context': {\n        'cache_pool': {},\n        'data_copy_concurrency': {},\n        'memory_key_value_store': {},\n      },\n      'driver': 'zarr',\n      'dtype': 'int32',\n      'kvstore': {'driver': 'memory'},\n      'metadata': {\n        'chunks': [101, 101, 101],\n        'compressor': {\n          'blocksize': 0,\n          'clevel': 5,\n          'cname': 'lz4',\n          'id': 'blosc',\n          'shuffle': -1,\n        },\n        'dimension_separator': '.',\n        'dtype': '<i4',\n        'fill_value': None,\n        'filters': None,\n        'order': 'F',\n        'shape': [1000, 2000, 3000],\n        'zarr_format': 2,\n      },\n      'transform': {\n        'input_exclusive_max': [[1000], [2000], [3000]],\n        'input_inclusive_min': [0, 0, 0],\n      },\n    })\n\nArgs:\n  spec: TensorStore Spec to open.  May also be specified as :json:schema:`JSON<TensorStore>`.\n\n  read: Allow read access.  Defaults to `True` if neither ``read`` nor ``write`` is specified.\n  write: Allow write access.  Defaults to `True` if neither ``read`` nor ``write`` is specified.\n  open_mode: Overrides the existing open mode.\n  open: Allow opening an existing TensorStore.  Overrides the existing open mode.\n  create: Allow creating a new TensorStore.  Overrides the existing open mode.  To open or\n    create, specify :python:`create=True` and :python:`open=True`.\n  delete_existing: Delete any existing data before creating a new array.  Overrides the existing\n    open mode.  Must be specified in conjunction with :python:`create=True`.\n  assume_metadata: Neither read nor write stored metadata.  Instead, just assume any necessary\n    metadata based on constraints in the spec, using the same defaults for any\n    unspecified metadata as when creating a new TensorStore.  The stored metadata\n    need not even exist.  Operations such as resizing that modify the stored\n    metadata are not supported.  Overrides the existing open mode.  Requires that\n    :py:param:`.open` is `True` and :py:param:`.delete_existing` is `False`.  This\n    option takes precedence over `.assume_cached_metadata` if that option is also\n    specified.\n    \n    .. warning::\n    \n       This option can lead to data corruption if the assumed metadata does\n       not match the stored metadata, or multiple concurrent writers use\n       different assumed metadata.\n    \n    .. seealso:\n    \n       - :ref:`python-open-assume-metadata`\n  assume_cached_metadata: Skip reading the metadata when opening.  Instead, just assume any necessary\n    metadata based on constraints in the spec, using the same defaults for any\n    unspecified metadata as when creating a new TensorStore.  The stored metadata\n    may still be accessed by subsequent operations that need to re-validate or\n    modify the metadata.  Requires that :py:param:`.open` is `True` and\n    :py:param:`.delete_existing` is `False`.  The :py:param:`.assume_metadata`\n    option takes precedence if also specified.\n    \n    .. warning::\n    \n       This option can lead to data corruption if the assumed metadata does\n       not match the stored metadata, or multiple concurrent writers use\n       different assumed metadata.\n    \n    .. seealso:\n    \n       - :ref:`python-open-assume-metadata`\n  context: Shared resource context.  Defaults to a new (unshared) context with default\n    options, as returned by :py:meth:`tensorstore.Context`.  To share resources,\n    such as cache pools, between multiple open TensorStores, you must specify a\n    context.\n  transaction: Transaction to use for opening/creating, and for subsequent operations.  By\n    default, the open is non-transactional.\n    \n    .. note::\n    \n       To perform transactional operations using a :py:obj:`TensorStore` that was\n       previously opened without a transaction, use\n       :py:obj:`TensorStore.with_transaction`.\n  kvstore: Sets the associated key-value store used as the underlying storage.\n    \n    If the :py:obj:`~tensorstore.Spec.kvstore` has already been set, it is\n    overridden.\n    \n    It is an error to specify this if the TensorStore driver does not use a\n    key-value store.\n  rank: Constrains the rank of the TensorStore.  If there is an index transform, the\n    rank constraint must match the rank of the *input* space.\n  dtype: Constrains the data type of the TensorStore.  If a data type has already been\n    set, it is an error to specify a different data type.\n  domain: Constrains the domain of the TensorStore.  If there is an existing\n    domain, the specified domain is merged with it as follows:\n    \n    1. The rank must match the existing rank.\n    \n    2. All bounds must match, except that a finite or explicit bound is permitted to\n       match an infinite and implicit bound, and takes precedence.\n    \n    3. If both the new and existing domain specify non-empty labels for a dimension,\n       the labels must be equal.  If only one of the domains specifies a non-empty\n       label for a dimension, the non-empty label takes precedence.\n    \n    Note that if there is an index transform, the domain must match the *input*\n    space, not the output space.\n  shape: Constrains the shape and origin of the TensorStore.  Equivalent to specifying a\n    :py:param:`domain` of :python:`ts.IndexDomain(shape=shape)`.\n    \n    .. note::\n    \n       This option also constrains the origin of all dimensions to be zero.\n  chunk_layout: Constrains the chunk layout.  If there is an existing chunk layout constraint,\n    the constraints are merged.  If the constraints are incompatible, an error\n    is raised.\n  codec: Constrains the codec.  If there is an existing codec constraint, the constraints\n    are merged.  If the constraints are incompatible, an error is raised.\n  fill_value: Specifies the fill value for positions that have not been written.\n    \n    The fill value data type must be convertible to the actual data type, and the\n    shape must be :ref:`broadcast-compatible<index-domain-alignment>` with the\n    domain.\n    \n    If an existing fill value has already been set as a constraint, it is an\n    error to specify a different fill value (where the comparison is done after\n    normalization by broadcasting).\n  dimension_units: Specifies the physical units of each dimension of the domain.\n    \n    The *physical unit* for a dimension is the physical quantity corresponding to a\n    single index increment along each dimension.\n    \n    A value of :python:`None` indicates that the unit is unknown.  A dimension-less\n    quantity can be indicated by a unit of :python:`\"\"`.\n  schema: Additional schema constraints to merge with existing constraints.\n\n\nExamples\n========\n\nOpening an existing TensorStore\n-------------------------------\n\nTo open an existing TensorStore, you can use a *minimal* :py:class:`.Spec` that\nspecifies required driver-specific options, like the storage location.\nInformation that can be determined automatically from the existing metadata,\nlike the data type, domain, and chunk layout, may be omitted:\n\n    >>> store = await ts.open(\n    ...     {\n    ...         'driver': 'neuroglancer_precomputed',\n    ...         'kvstore': {\n    ...             'driver': 'gcs',\n    ...             'bucket': 'neuroglancer-janelia-flyem-hemibrain',\n    ...             'path': 'v1.2/segmentation/',\n    ...         },\n    ...     },\n    ...     read=True)\n    >>> store\n    TensorStore({\n      'context': {\n        'cache_pool': {},\n        'data_copy_concurrency': {},\n        'gcs_request_concurrency': {},\n        'gcs_request_retries': {},\n        'gcs_user_project': {},\n      },\n      'driver': 'neuroglancer_precomputed',\n      'dtype': 'uint64',\n      'kvstore': {\n        'bucket': 'neuroglancer-janelia-flyem-hemibrain',\n        'driver': 'gcs',\n        'path': 'v1.2/segmentation/',\n      },\n      'multiscale_metadata': {'num_channels': 1, 'type': 'segmentation'},\n      'scale_index': 0,\n      'scale_metadata': {\n        'chunk_size': [64, 64, 64],\n        'compressed_segmentation_block_size': [8, 8, 8],\n        'encoding': 'compressed_segmentation',\n        'key': '8.0x8.0x8.0',\n        'resolution': [8.0, 8.0, 8.0],\n        'sharding': {\n          '@type': 'neuroglancer_uint64_sharded_v1',\n          'data_encoding': 'gzip',\n          'hash': 'identity',\n          'minishard_bits': 6,\n          'minishard_index_encoding': 'gzip',\n          'preshift_bits': 9,\n          'shard_bits': 15,\n        },\n        'size': [34432, 39552, 41408],\n        'voxel_offset': [0, 0, 0],\n      },\n      'transform': {\n        'input_exclusive_max': [34432, 39552, 41408, 1],\n        'input_inclusive_min': [0, 0, 0, 0],\n        'input_labels': ['x', 'y', 'z', 'channel'],\n      },\n    })\n\nCreating a new TensorStore\n--------------------------\n\nTo create a new TensorStore, you must specify required driver-specific options,\nlike the storage location, as well as :py:class:`Schema` constraints like the\ndata type and domain.  Suitable defaults are chosen automatically for schema\nproperties that are left unconstrained:\n\n    >>> store = await ts.open(\n    ...     {\n    ...         'driver': 'zarr',\n    ...         'kvstore': {\n    ...             'driver': 'memory'\n    ...         },\n    ...     },\n    ...     create=True,\n    ...     dtype=ts.float32,\n    ...     shape=[1000, 2000, 3000],\n    ...     fill_value=42)\n    >>> store\n    TensorStore({\n      'context': {\n        'cache_pool': {},\n        'data_copy_concurrency': {},\n        'memory_key_value_store': {},\n      },\n      'driver': 'zarr',\n      'dtype': 'float32',\n      'kvstore': {'driver': 'memory'},\n      'metadata': {\n        'chunks': [101, 101, 101],\n        'compressor': {\n          'blocksize': 0,\n          'clevel': 5,\n          'cname': 'lz4',\n          'id': 'blosc',\n          'shuffle': -1,\n        },\n        'dimension_separator': '.',\n        'dtype': '<f4',\n        'fill_value': 42.0,\n        'filters': None,\n        'order': 'C',\n        'shape': [1000, 2000, 3000],\n        'zarr_format': 2,\n      },\n      'transform': {\n        'input_exclusive_max': [[1000], [2000], [3000]],\n        'input_inclusive_min': [0, 0, 0],\n      },\n    })\n\nPartial constraints may be specified on the chunk layout, and the driver will\ndetermine a matching chunk layout automatically:\n\n    >>> store = await ts.open(\n    ...     {\n    ...         'driver': 'zarr',\n    ...         'kvstore': {\n    ...             'driver': 'memory'\n    ...         },\n    ...     },\n    ...     create=True,\n    ...     dtype=ts.float32,\n    ...     shape=[1000, 2000, 3000],\n    ...     chunk_layout=ts.ChunkLayout(\n    ...         chunk_shape=[10, None, None],\n    ...         chunk_aspect_ratio=[None, 2, 1],\n    ...         chunk_elements=10000000,\n    ...     ),\n    ... )\n    >>> store\n    TensorStore({\n      'context': {\n        'cache_pool': {},\n        'data_copy_concurrency': {},\n        'memory_key_value_store': {},\n      },\n      'driver': 'zarr',\n      'dtype': 'float32',\n      'kvstore': {'driver': 'memory'},\n      'metadata': {\n        'chunks': [10, 1414, 707],\n        'compressor': {\n          'blocksize': 0,\n          'clevel': 5,\n          'cname': 'lz4',\n          'id': 'blosc',\n          'shuffle': -1,\n        },\n        'dimension_separator': '.',\n        'dtype': '<f4',\n        'fill_value': None,\n        'filters': None,\n        'order': 'C',\n        'shape': [1000, 2000, 3000],\n        'zarr_format': 2,\n      },\n      'transform': {\n        'input_exclusive_max': [[1000], [2000], [3000]],\n        'input_inclusive_min': [0, 0, 0],\n      },\n    })\n\nThe schema constraints allow key storage characteristics to be specified\nindependent of the driver/format:\n\n    >>> store = await ts.open(\n    ...     {\n    ...         'driver': 'n5',\n    ...         'kvstore': {\n    ...             'driver': 'memory'\n    ...         },\n    ...     },\n    ...     create=True,\n    ...     dtype=ts.float32,\n    ...     shape=[1000, 2000, 3000],\n    ...     chunk_layout=ts.ChunkLayout(\n    ...         chunk_shape=[10, None, None],\n    ...         chunk_aspect_ratio=[None, 2, 1],\n    ...         chunk_elements=10000000,\n    ...     ),\n    ... )\n    >>> store\n    TensorStore({\n      'context': {\n        'cache_pool': {},\n        'data_copy_concurrency': {},\n        'memory_key_value_store': {},\n      },\n      'driver': 'n5',\n      'dtype': 'float32',\n      'kvstore': {'driver': 'memory'},\n      'metadata': {\n        'blockSize': [10, 1414, 707],\n        'compression': {\n          'blocksize': 0,\n          'clevel': 5,\n          'cname': 'lz4',\n          'shuffle': 1,\n          'type': 'blosc',\n        },\n        'dataType': 'float32',\n        'dimensions': [1000, 2000, 3000],\n      },\n      'transform': {\n        'input_exclusive_max': [[1000], [2000], [3000]],\n        'input_inclusive_min': [0, 0, 0],\n      },\n    })\n\nDriver-specific constraints can be used in combination with, or instead of,\nschema constraints:\n\n    >>> store = await ts.open(\n    ...     {\n    ...         'driver': 'zarr',\n    ...         'kvstore': {\n    ...             'driver': 'memory'\n    ...         },\n    ...         'metadata': {\n    ...             'dtype': '>f4'\n    ...         },\n    ...     },\n    ...     create=True,\n    ...     shape=[1000, 2000, 3000])\n    >>> store\n    TensorStore({\n      'context': {\n        'cache_pool': {},\n        'data_copy_concurrency': {},\n        'memory_key_value_store': {},\n      },\n      'driver': 'zarr',\n      'dtype': 'float32',\n      'kvstore': {'driver': 'memory'},\n      'metadata': {\n        'chunks': [101, 101, 101],\n        'compressor': {\n          'blocksize': 0,\n          'clevel': 5,\n          'cname': 'lz4',\n          'id': 'blosc',\n          'shuffle': -1,\n        },\n        'dimension_separator': '.',\n        'dtype': '>f4',\n        'fill_value': None,\n        'filters': None,\n        'order': 'C',\n        'shape': [1000, 2000, 3000],\n        'zarr_format': 2,\n      },\n      'transform': {\n        'input_exclusive_max': [[1000], [2000], [3000]],\n        'input_inclusive_min': [0, 0, 0],\n      },\n    })\n\n.. _python-open-assume-metadata:\n\nUsing :py:param:`.assume_metadata` for improved concurrent open efficiency\n--------------------------------------------------------------------------\n\nNormally, when opening or creating a chunked format like\n:ref:`zarr<zarr-driver>`, TensorStore first attempts to read the existing\nmetadata (and confirms that it matches any specified constraints), or (if\ncreating is allowed) creates a new metadata file based on any specified\nconstraints.\n\nWhen the same TensorStore stored on a distributed filesystem or cloud storage is\nopened concurrently from many machines, the simultaneous requests to read and\nwrite the metadata file by every machine can create contention and result in\nhigh latency on some distributed filesystems.\n\nThe :py:param:`.assume_metadata` open mode allows redundant reading and writing\nof the metadata file to be avoided, but requires careful use to avoid data\ncorruption.\n\n.. admonition:: Example of skipping reading the metadata when opening an existing array\n   :class: example\n\n   >>> context = ts.Context()\n   >>> # First create the array normally\n   >>> store = await ts.open({\n   ...     \"driver\": \"zarr\",\n   ...     \"kvstore\": \"memory://\"\n   ... },\n   ...                       context=context,\n   ...                       dtype=ts.float32,\n   ...                       shape=[5],\n   ...                       create=True)\n   >>> # Note that the .zarray metadata has been written.\n   >>> await store.kvstore.list()\n   [b'.zarray']\n   >>> await store.write([1, 2, 3, 4, 5])\n   >>> spec = store.spec()\n   >>> spec\n   Spec({\n     'driver': 'zarr',\n     'dtype': 'float32',\n     'kvstore': {'driver': 'memory'},\n     'metadata': {\n       'chunks': [5],\n       'compressor': {\n         'blocksize': 0,\n         'clevel': 5,\n         'cname': 'lz4',\n         'id': 'blosc',\n         'shuffle': -1,\n       },\n       'dimension_separator': '.',\n       'dtype': '<f4',\n       'fill_value': None,\n       'filters': None,\n       'order': 'C',\n       'shape': [5],\n       'zarr_format': 2,\n     },\n     'transform': {'input_exclusive_max': [[5]], 'input_inclusive_min': [0]},\n   })\n   >>> # Re-open later without re-reading metadata\n   >>> store2 = await ts.open(spec,\n   ...                        context=context,\n   ...                        open=True,\n   ...                        assume_metadata=True)\n   >>> # Read data using the unverified metadata from `spec`\n   >>> await store2.read()\n\n.. admonition:: Example of skipping writing the metadata when creating a new array\n   :class: example\n\n   >>> context = ts.Context()\n   >>> spec = ts.Spec(json={\"driver\": \"zarr\", \"kvstore\": \"memory://\"})\n   >>> spec.update(dtype=ts.float32, shape=[5])\n   >>> # Open the array without writing the metadata.  If using a distributed\n   >>> # filesystem, this can safely be executed on multiple machines concurrently,\n   >>> # provided that the `spec` is identical and the metadata is either fully\n   >>> # constrained, or exactly the same TensorStore version is used to ensure the\n   >>> # same defaults are applied.\n   >>> store = await ts.open(spec,\n   ...                       context=context,\n   ...                       open=True,\n   ...                       create=True,\n   ...                       assume_metadata=True)\n   >>> await store.write([1, 2, 3, 4, 5])\n   >>> # Note that the data chunk has been written but not the .zarray metadata\n   >>> await store.kvstore.list()\n   [b'0']\n   >>> # From a single machine, actually write the metadata to ensure the array\n   >>> # can be re-opened knowing the metadata.  This can be done in parallel with\n   >>> # any other writing.\n   >>> await ts.open(spec, context=context, open=True, create=True)\n   >>> # Metadata has now been written.\n   >>> await store.kvstore.list()\n   [b'.zarray', b'0']\n\nGroup:\n  Core\n\n",
        "type": "function"
    },
    "overlay": {
        "ast": "FunctionDef(name='overlay', args=arguments(posonlyargs=[], args=[arg(arg='layers', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='TensorStore', ctx=Load()), Name(id='Spec', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='read', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='write', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Context', ctx=Load()), ctx=Load())), arg(arg='transaction', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Transaction', ctx=Load()), ctx=Load())), arg(arg='rank', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='dtype', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='dtype', ctx=Load()), ctx=Load())), arg(arg='domain', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='IndexDomain', ctx=Load()), ctx=Load())), arg(arg='shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='dimension_units', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Unit', ctx=Load()), Name(id='str', ctx=Load()), Name(id='Real', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='Real', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='schema', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Schema', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='TensorStore', ctx=Load()))",
        "definition": "def overlay(layers: Sequence[Union[TensorStore, Spec]], *, read: Optional[bool] = None, write: Optional[bool] = None, context: Optional[Context] = None, transaction: Optional[Transaction] = None, rank: Optional[int] = None, dtype: Optional[dtype] = None, domain: Optional[IndexDomain] = None, shape: Optional[Sequence[int]] = None, dimension_units: Optional[Sequence[Optional[Union[Unit, str, Real, Tuple[Real, str]]]]] = None, schema: Optional[Schema] = None) -> TensorStore: ...",
        "doc": "overlay(layers: Sequence[Union[tensorstore.TensorStore, tensorstore.Spec]], *, read: Optional[bool] = None, write: Optional[bool] = None, context: Optional[tensorstore.Context] = None, transaction: Optional[tensorstore.Transaction] = None, rank: Optional[int] = None, dtype: Optional[tensorstore.dtype] = None, domain: Optional[tensorstore.IndexDomain] = None, shape: Optional[Sequence[int]] = None, dimension_units: Optional[Sequence[Optional[Union[tensorstore.Unit, str, Real, Tuple[Real, str]]]]] = None, schema: Optional[tensorstore.Schema] = None) -> tensorstore.TensorStore\n\n\nVirtually overlays a sequence of :py:obj:`TensorStore` layers within a common domain.\n\n    >>> store = ts.overlay([\n    ...     ts.array([1, 2, 3, 4], dtype=ts.uint32),\n    ...     ts.array([5, 6, 7, 8], dtype=ts.uint32).translate_to[3]\n    ... ])\n    >>> store\n    TensorStore({\n      'context': {'data_copy_concurrency': {}},\n      'driver': 'stack',\n      'dtype': 'uint32',\n      'layers': [\n        {\n          'array': [1, 2, 3, 4],\n          'driver': 'array',\n          'dtype': 'uint32',\n          'transform': {'input_exclusive_max': [4], 'input_inclusive_min': [0]},\n        },\n        {\n          'array': [5, 6, 7, 8],\n          'driver': 'array',\n          'dtype': 'uint32',\n          'transform': {\n            'input_exclusive_max': [7],\n            'input_inclusive_min': [3],\n            'output': [{'input_dimension': 0, 'offset': -3}],\n          },\n        },\n      ],\n      'schema': {'domain': {'exclusive_max': [7], 'inclusive_min': [0]}},\n      'transform': {'input_exclusive_max': [7], 'input_inclusive_min': [0]},\n    })\n    >>> await store.read()\n    array([1, 2, 3, 5, 6, 7, 8], dtype=uint32)\n\nArgs:\n\n  layers: Sequence of layers to overlay.  Later layers take precedence.  If a\n    layer is specified as a :py:obj:`Spec` rather than a :py:obj:`TensorStore`,\n    it must have a known :py:obj:`~Spec.domain` and will be opened on-demand as\n    neneded for individual read and write operations.\n\n  read: Allow read access.  Defaults to `True` if neither ``read`` nor ``write`` is specified.\n  write: Allow write access.  Defaults to `True` if neither ``read`` nor ``write`` is specified.\n  context: Shared resource context.  Defaults to a new (unshared) context with default\n    options, as returned by :py:meth:`tensorstore.Context`.  To share resources,\n    such as cache pools, between multiple open TensorStores, you must specify a\n    context.\n  transaction: Transaction to use for opening/creating, and for subsequent operations.  By\n    default, the open is non-transactional.\n    \n    .. note::\n    \n       To perform transactional operations using a :py:obj:`TensorStore` that was\n       previously opened without a transaction, use\n       :py:obj:`TensorStore.with_transaction`.\n  rank: Constrains the rank of the TensorStore.  If there is an index transform, the\n    rank constraint must match the rank of the *input* space.\n  dtype: Constrains the data type of the TensorStore.  If a data type has already been\n    set, it is an error to specify a different data type.\n  domain: Constrains the domain of the TensorStore.  If there is an existing\n    domain, the specified domain is merged with it as follows:\n    \n    1. The rank must match the existing rank.\n    \n    2. All bounds must match, except that a finite or explicit bound is permitted to\n       match an infinite and implicit bound, and takes precedence.\n    \n    3. If both the new and existing domain specify non-empty labels for a dimension,\n       the labels must be equal.  If only one of the domains specifies a non-empty\n       label for a dimension, the non-empty label takes precedence.\n    \n    Note that if there is an index transform, the domain must match the *input*\n    space, not the output space.\n  shape: Constrains the shape and origin of the TensorStore.  Equivalent to specifying a\n    :py:param:`domain` of :python:`ts.IndexDomain(shape=shape)`.\n    \n    .. note::\n    \n       This option also constrains the origin of all dimensions to be zero.\n  dimension_units: Specifies the physical units of each dimension of the domain.\n    \n    The *physical unit* for a dimension is the physical quantity corresponding to a\n    single index increment along each dimension.\n    \n    A value of :python:`None` indicates that the unit is unknown.  A dimension-less\n    quantity can be indicated by a unit of :python:`\"\"`.\n  schema: Additional schema constraints to merge with existing constraints.\n\n\nSee also:\n  - :ref:`stack-driver`\n  - :py:obj:`tensorstore.stack`\n  - :py:obj:`tensorstore.concat`\n\nGroup:\n  Views\n\n",
        "type": "function"
    },
    "stack": {
        "ast": "FunctionDef(name='stack', args=arguments(posonlyargs=[], args=[arg(arg='layers', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='TensorStore', ctx=Load()), Name(id='Spec', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='axis', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[arg(arg='read', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='write', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Context', ctx=Load()), ctx=Load())), arg(arg='transaction', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Transaction', ctx=Load()), ctx=Load())), arg(arg='rank', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='dtype', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='dtype', ctx=Load()), ctx=Load())), arg(arg='domain', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='IndexDomain', ctx=Load()), ctx=Load())), arg(arg='shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='dimension_units', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Unit', ctx=Load()), Name(id='str', ctx=Load()), Name(id='Real', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='Real', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='schema', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Schema', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[Constant(value=0)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='TensorStore', ctx=Load()))",
        "definition": "def stack(layers: Sequence[Union[TensorStore, Spec]], axis: int = 0, *, read: Optional[bool] = None, write: Optional[bool] = None, context: Optional[Context] = None, transaction: Optional[Transaction] = None, rank: Optional[int] = None, dtype: Optional[dtype] = None, domain: Optional[IndexDomain] = None, shape: Optional[Sequence[int]] = None, dimension_units: Optional[Sequence[Optional[Union[Unit, str, Real, Tuple[Real, str]]]]] = None, schema: Optional[Schema] = None) -> TensorStore: ...",
        "doc": "stack(layers: Sequence[Union[tensorstore.TensorStore, tensorstore.Spec]], axis: int = 0, *, read: Optional[bool] = None, write: Optional[bool] = None, context: Optional[tensorstore.Context] = None, transaction: Optional[tensorstore.Transaction] = None, rank: Optional[int] = None, dtype: Optional[tensorstore.dtype] = None, domain: Optional[tensorstore.IndexDomain] = None, shape: Optional[Sequence[int]] = None, dimension_units: Optional[Sequence[Optional[Union[tensorstore.Unit, str, Real, Tuple[Real, str]]]]] = None, schema: Optional[tensorstore.Schema] = None) -> tensorstore.TensorStore\n\n\nVirtually stacks a sequence of :py:obj:`TensorStore` layers along a new dimension.\n\n    >>> store = ts.stack([\n    ...     ts.array([1, 2, 3, 4], dtype=ts.uint32),\n    ...     ts.array([5, 6, 7, 8], dtype=ts.uint32)\n    ... ])\n    >>> store\n    TensorStore({\n      'context': {'data_copy_concurrency': {}},\n      'driver': 'stack',\n      'dtype': 'uint32',\n      'layers': [\n        {\n          'array': [1, 2, 3, 4],\n          'driver': 'array',\n          'dtype': 'uint32',\n          'transform': {\n            'input_exclusive_max': [1, 4],\n            'input_inclusive_min': [0, 0],\n            'output': [{'input_dimension': 1}],\n          },\n        },\n        {\n          'array': [5, 6, 7, 8],\n          'driver': 'array',\n          'dtype': 'uint32',\n          'transform': {\n            'input_exclusive_max': [2, 4],\n            'input_inclusive_min': [1, 0],\n            'output': [{'input_dimension': 1}],\n          },\n        },\n      ],\n      'schema': {'domain': {'exclusive_max': [2, 4], 'inclusive_min': [0, 0]}},\n      'transform': {'input_exclusive_max': [2, 4], 'input_inclusive_min': [0, 0]},\n    })\n    >>> await store.read()\n    array([[1, 2, 3, 4],\n           [5, 6, 7, 8]], dtype=uint32)\n    >>> store = ts.stack([\n    ...     ts.array([1, 2, 3, 4], dtype=ts.uint32),\n    ...     ts.array([5, 6, 7, 8], dtype=ts.uint32)\n    ... ],\n    ...                  axis=-1)\n    >>> store\n    TensorStore({\n      'context': {'data_copy_concurrency': {}},\n      'driver': 'stack',\n      'dtype': 'uint32',\n      'layers': [\n        {\n          'array': [1, 2, 3, 4],\n          'driver': 'array',\n          'dtype': 'uint32',\n          'transform': {\n            'input_exclusive_max': [4, 1],\n            'input_inclusive_min': [0, 0],\n            'output': [{'input_dimension': 0}],\n          },\n        },\n        {\n          'array': [5, 6, 7, 8],\n          'driver': 'array',\n          'dtype': 'uint32',\n          'transform': {\n            'input_exclusive_max': [4, 2],\n            'input_inclusive_min': [0, 1],\n            'output': [{'input_dimension': 0}],\n          },\n        },\n      ],\n      'schema': {'domain': {'exclusive_max': [4, 2], 'inclusive_min': [0, 0]}},\n      'transform': {'input_exclusive_max': [4, 2], 'input_inclusive_min': [0, 0]},\n    })\n    >>> await store.read()\n    array([[1, 5],\n           [2, 6],\n           [3, 7],\n           [4, 8]], dtype=uint32)\n\nArgs:\n\n  layers: Sequence of layers to stack.  If a layer is specified as a\n    :py:obj:`Spec` rather than a :py:obj:`TensorStore`, it must have a known\n    :py:obj:`~Spec.domain` and will be opened on-demand as needed for individual\n    read and write operations.\n\n  axis: New dimension along which to stack.  A negative number counts from the end.\n  read: Allow read access.  Defaults to `True` if neither ``read`` nor ``write`` is specified.\n  write: Allow write access.  Defaults to `True` if neither ``read`` nor ``write`` is specified.\n  context: Shared resource context.  Defaults to a new (unshared) context with default\n    options, as returned by :py:meth:`tensorstore.Context`.  To share resources,\n    such as cache pools, between multiple open TensorStores, you must specify a\n    context.\n  transaction: Transaction to use for opening/creating, and for subsequent operations.  By\n    default, the open is non-transactional.\n    \n    .. note::\n    \n       To perform transactional operations using a :py:obj:`TensorStore` that was\n       previously opened without a transaction, use\n       :py:obj:`TensorStore.with_transaction`.\n  rank: Constrains the rank of the TensorStore.  If there is an index transform, the\n    rank constraint must match the rank of the *input* space.\n  dtype: Constrains the data type of the TensorStore.  If a data type has already been\n    set, it is an error to specify a different data type.\n  domain: Constrains the domain of the TensorStore.  If there is an existing\n    domain, the specified domain is merged with it as follows:\n    \n    1. The rank must match the existing rank.\n    \n    2. All bounds must match, except that a finite or explicit bound is permitted to\n       match an infinite and implicit bound, and takes precedence.\n    \n    3. If both the new and existing domain specify non-empty labels for a dimension,\n       the labels must be equal.  If only one of the domains specifies a non-empty\n       label for a dimension, the non-empty label takes precedence.\n    \n    Note that if there is an index transform, the domain must match the *input*\n    space, not the output space.\n  shape: Constrains the shape and origin of the TensorStore.  Equivalent to specifying a\n    :py:param:`domain` of :python:`ts.IndexDomain(shape=shape)`.\n    \n    .. note::\n    \n       This option also constrains the origin of all dimensions to be zero.\n  dimension_units: Specifies the physical units of each dimension of the domain.\n    \n    The *physical unit* for a dimension is the physical quantity corresponding to a\n    single index increment along each dimension.\n    \n    A value of :python:`None` indicates that the unit is unknown.  A dimension-less\n    quantity can be indicated by a unit of :python:`\"\"`.\n  schema: Additional schema constraints to merge with existing constraints.\n\n\nSee also:\n  - :py:obj:`numpy.stack`\n  - :ref:`stack-driver`\n  - :py:obj:`tensorstore.overlay`\n  - :py:obj:`tensorstore.concat`\n\nGroup:\n  Views\n\n",
        "type": "function"
    },
    "string": {
        "ast": "Assign(targets=[Name(id='string', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='string')], keywords=[]))",
        "definition": "dtype(\"string\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "uint16": {
        "ast": "Assign(targets=[Name(id='uint16', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='uint16')], keywords=[]))",
        "definition": "dtype(\"uint16\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "uint32": {
        "ast": "Assign(targets=[Name(id='uint32', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='uint32')], keywords=[]))",
        "definition": "dtype(\"uint32\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "uint64": {
        "ast": "Assign(targets=[Name(id='uint64', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='uint64')], keywords=[]))",
        "definition": "dtype(\"uint64\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "uint8": {
        "ast": "Assign(targets=[Name(id='uint8', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='uint8')], keywords=[]))",
        "definition": "dtype(\"uint8\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "ustring": {
        "ast": "Assign(targets=[Name(id='ustring', ctx=Store())], value=Call(func=Name(id='dtype', ctx=Load()), args=[Constant(value='ustring')], keywords=[]))",
        "definition": "dtype(\"ustring\")",
        "doc": "\nTensorStore data type representation.\n\nGroup:\n  Data types\n",
        "type": "unknown"
    },
    "virtual_chunked": {
        "ast": "FunctionDef(name='virtual_chunked', args=arguments(posonlyargs=[], args=[arg(arg='read_function', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='IndexDomain', ctx=Load()), Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load()), Name(id='VirtualChunkedReadParameters', ctx=Load())], ctx=Load()), Subscript(value=Name(id='FutureLike', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='KvStore', ctx=Load()), attr='TimestampedStorageGeneration', ctx=Load()), ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='write_function', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='IndexDomain', ctx=Load()), Attribute(value=Attribute(value=Name(id='numpy', ctx=Load()), attr='typing', ctx=Load()), attr='ArrayLike', ctx=Load()), Name(id='VirtualChunkedWriteParameters', ctx=Load())], ctx=Load()), Subscript(value=Name(id='FutureLike', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='KvStore', ctx=Load()), attr='TimestampedStorageGeneration', ctx=Load()), ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='loop', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='asyncio', ctx=Load()), attr='AbstractEventLoop', ctx=Load()), ctx=Load())), arg(arg='rank', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='dtype', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='dtype', ctx=Load()), ctx=Load())), arg(arg='domain', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='IndexDomain', ctx=Load()), ctx=Load())), arg(arg='shape', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='chunk_layout', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='ChunkLayout', ctx=Load()), ctx=Load())), arg(arg='dimension_units', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Unit', ctx=Load()), Name(id='str', ctx=Load()), Name(id='Real', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='Real', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='schema', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Schema', ctx=Load()), ctx=Load())), arg(arg='context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Context', ctx=Load()), ctx=Load())), arg(arg='transaction', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Transaction', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='TensorStore', ctx=Load()))",
        "definition": "def virtual_chunked(read_function: Optional[Callable[[IndexDomain, numpy.typing.ArrayLike, VirtualChunkedReadParameters], FutureLike[Optional[KvStore.TimestampedStorageGeneration]]]] = None, write_function: Optional[Callable[[IndexDomain, numpy.typing.ArrayLike, VirtualChunkedWriteParameters], FutureLike[Optional[KvStore.TimestampedStorageGeneration]]]] = None, *, loop: Optional[asyncio.AbstractEventLoop] = None, rank: Optional[int] = None, dtype: Optional[dtype] = None, domain: Optional[IndexDomain] = None, shape: Optional[Sequence[int]] = None, chunk_layout: Optional[ChunkLayout] = None, dimension_units: Optional[Sequence[Optional[Union[Unit, str, Real, Tuple[Real, str]]]]] = None, schema: Optional[Schema] = None, context: Optional[Context] = None, transaction: Optional[Transaction] = None) -> TensorStore: ...",
        "doc": "virtual_chunked(read_function: Optional[Callable[[tensorstore.IndexDomain, numpy.typing.ArrayLike, tensorstore.VirtualChunkedReadParameters], tensorstore.FutureLike[Optional[tensorstore.KvStore.TimestampedStorageGeneration]]]] = None, write_function: Optional[Callable[[tensorstore.IndexDomain, numpy.typing.ArrayLike, tensorstore.VirtualChunkedWriteParameters], tensorstore.FutureLike[Optional[tensorstore.KvStore.TimestampedStorageGeneration]]]] = None, *, loop: Optional[asyncio.AbstractEventLoop] = None, rank: Optional[int] = None, dtype: Optional[tensorstore.dtype] = None, domain: Optional[tensorstore.IndexDomain] = None, shape: Optional[Sequence[int]] = None, chunk_layout: Optional[tensorstore.ChunkLayout] = None, dimension_units: Optional[Sequence[Optional[Union[tensorstore.Unit, str, Real, Tuple[Real, str]]]]] = None, schema: Optional[tensorstore.Schema] = None, context: Optional[tensorstore.Context] = None, transaction: Optional[tensorstore.Transaction] = None) -> tensorstore.TensorStore\n\n\nCreates a :py:obj:`.TensorStore` where the content is read/written chunk-wise by an arbitrary function.\n\nExample (read-only):\n\n    >>> a = ts.array([[1, 2, 3], [4, 5, 6]], dtype=ts.uint32)\n    >>> async def do_read(domain: ts.IndexDomain, array: np.ndarray,\n    ...                   read_params: ts.VirtualChunkedReadParameters):\n    ...     print(f'Computing content for: {domain}')\n    ...     array[...] = (await a[domain].read()) + 100\n    >>> t = ts.virtual_chunked(do_read, dtype=a.dtype, domain=a.domain)\n    >>> await t.read()\n    Computing content for: { [0, 2), [0, 3) }\n    array([[101, 102, 103],\n           [104, 105, 106]], dtype=uint32)\n\nExample (read/write):\n\n    >>> array = np.zeros(shape=[4, 5], dtype=np.uint32)\n    >>> array[1] = 50\n    >>> def do_read(domain, chunk, read_context):\n    ...     chunk[...] = array[domain.index_exp]\n    >>> def do_write(domain, chunk, write_context):\n    ...     array[domain.index_exp] = chunk\n    >>> t = ts.virtual_chunked(\n    ...     do_read,\n    ...     do_write,\n    ...     dtype=array.dtype,\n    ...     shape=array.shape,\n    ...     chunk_layout=ts.ChunkLayout(read_chunk_shape=(2, 3)))\n    >>> await t.read()\n    array([[ 0,  0,  0,  0,  0],\n           [50, 50, 50, 50, 50],\n           [ 0,  0,  0,  0,  0],\n           [ 0,  0,  0,  0,  0]], dtype=uint32)\n    >>> t[1:3, 1:3] = 42\n    >>> array\n    array([[ 0,  0,  0,  0,  0],\n           [50, 42, 42, 50, 50],\n           [ 0, 42, 42,  0,  0],\n           [ 0,  0,  0,  0,  0]], dtype=uint32)\n\nArgs:\n\n  read_function: Callback that handles chunk read requests.  Must be specified\n    to create a virtual view that supports reads.  To create a write-only view,\n    leave this unspecified (as :py:obj:`None`).\n\n    This function should assign to the array the content for the specified\n    :py:obj:`~tensorstore.IndexDomain`.\n\n    The returned :py:obj:`~tensorstore.KvStore.TimestampedStorageGeneration`\n    identifies the version of the content, for caching purposes.  If versioning\n    is not applicable, :py:obj:`None` may be returned to indicate a value that\n    may be cached indefinitely.\n\n    If it returns a :ref:`coroutine<python:async>`, the coroutine will be\n    executed using the event loop indicated by :py:param:`.loop`.\n\n  write_function: Callback that handles chunk write requests.  Must be specified\n    to create a virtual view that supports writes.  To create a read-only view,\n    leave this unspecified (as :py:obj:`None`).\n\n    This function store the content of the array for the specified\n    :py:obj:`~tensorstore.IndexDomain`.\n\n    The returned :py:obj:`~tensorstore.KvStore.TimestampedStorageGeneration`\n    identifies the stored version of the content, for caching purposes.  If\n    versioning is not applicable, :py:obj:`None` may be returned to indicate a\n    value that may be cached indefinitely.\n\n    If it returns a :ref:`coroutine<python:async>`, the coroutine will be\n    executed using the event loop indicated by :py:param:`.loop`.\n\n  loop: Event loop on which to execute :py:param:`.read_function` and/or\n    :py:param:`.write_function` if they are\n    :ref:`async functions<python:async def>`.  If not specified (or\n    :py:obj:`None` is specified), defaults to the loop returned by\n    :py:obj:`asyncio.get_running_loop` (in the context of the call to\n    :py:obj:`.virtual_chunked`).  If :py:param:`.loop` is not specified and\n    there is no running event loop, it is an error for\n    :py:param:`.read_function` or :py:param:`.write_function` to return a\n    coroutine.\n\n  rank: Constrains the rank of the TensorStore.  If there is an index transform, the\n    rank constraint must match the rank of the *input* space.\n  dtype: Constrains the data type of the TensorStore.  If a data type has already been\n    set, it is an error to specify a different data type.\n  domain: Constrains the domain of the TensorStore.  If there is an existing\n    domain, the specified domain is merged with it as follows:\n    \n    1. The rank must match the existing rank.\n    \n    2. All bounds must match, except that a finite or explicit bound is permitted to\n       match an infinite and implicit bound, and takes precedence.\n    \n    3. If both the new and existing domain specify non-empty labels for a dimension,\n       the labels must be equal.  If only one of the domains specifies a non-empty\n       label for a dimension, the non-empty label takes precedence.\n    \n    Note that if there is an index transform, the domain must match the *input*\n    space, not the output space.\n  shape: Constrains the shape and origin of the TensorStore.  Equivalent to specifying a\n    :py:param:`domain` of :python:`ts.IndexDomain(shape=shape)`.\n    \n    .. note::\n    \n       This option also constrains the origin of all dimensions to be zero.\n  chunk_layout: Constrains the chunk layout.  If there is an existing chunk layout constraint,\n    the constraints are merged.  If the constraints are incompatible, an error\n    is raised.\n  dimension_units: Specifies the physical units of each dimension of the domain.\n    \n    The *physical unit* for a dimension is the physical quantity corresponding to a\n    single index increment along each dimension.\n    \n    A value of :python:`None` indicates that the unit is unknown.  A dimension-less\n    quantity can be indicated by a unit of :python:`\"\"`.\n  schema: Additional schema constraints to merge with existing constraints.\n  context: Shared resource context.  Defaults to a new (unshared) context with default\n    options, as returned by :py:meth:`tensorstore.Context`.  To share resources,\n    such as cache pools, between multiple open TensorStores, you must specify a\n    context.\n  transaction: Transaction to use for opening/creating, and for subsequent operations.  By\n    default, the open is non-transactional.\n    \n    .. note::\n    \n       To perform transactional operations using a TensorStore that was previously\n       opened without a transaction, use :py:obj:`TensorStore.with_transaction`.\n\n\n\nWarning:\n\n  Neither :py:param:`.read_function` nor :py:param:`.write_function` should\n  block synchronously while waiting for another TensorStore operation; blocking\n  on another operation that uses the same\n  :json:schema:`Context.data_copy_concurrency` resource may result in deadlock.\n  Instead, it is better to specify a :ref:`coroutine function<python:async def>`\n  for :py:param:`.read_function` and :py:param:`.write_function` and use\n  :ref:`await<python:await>` to wait for the result of other TensorStore\n  operations.\n\nGroup:\n  Virtual views\n\nCaching\n-------\n\nBy default, the computed content of chunks is not cached, and will be\nrecomputed on every read.  To enable caching:\n\n- Specify a :py:obj:`~tensorstore.Context` that contains a\n  :json:schema:`~Context.cache_pool` with a non-zero size limit, e.g.:\n  :json:`{\"cache_pool\": {\"total_bytes_limit\": 100000000}}` for 100MB.\n\n- Additionally, if the data is not immutable, the :py:param:`read_function`\n  should return a unique generation and a timestamp that is not\n  :python:`float('inf')`.  When a cached chunk is re-read, the\n  :py:param:`read_function` will be called with\n  :py:obj:`~tensorstore.VirtualChunkedReadParameters.if_not_equal` specified.\n  If the generation specified by\n  :py:obj:`~tensorstore.VirtualChunkedReadParameters.if_not_equal` is still\n  current, the :py:param:`read_function` may leave the output array unmodified\n  and return a :py:obj:`~tensorstore.KvStore.TimestampedStorageGeneration` with\n  an appropriate\n  :py:obj:`~tensorstore.KvStore.TimestampedStorageGeneration.time` but\n  :py:obj:`~tensorstore.KvStore.TimestampedStorageGeneration.generation` left\n  unspecified.\n\nPickle support\n--------------\n\nThe returned :py:obj:`.TensorStore` supports pickling if, and only if, the\n:py:param:`.read_function` and :py:param:`.write_function` support pickling.\n\n.. note::\n\n   The :py:mod:`pickle` module only supports global functions defined in named\n   modules.  For broader function support, you may wish to use\n   `cloudpickle <https://github.com/cloudpipe/cloudpickle>`__.\n\n.. warning::\n\n   The specified :py:param:`.loop` is not preserved when the returned\n   :py:obj:`.TensorStore` is pickled, since it is a property of the current\n   thread.  Instead, when unpickled, the resultant :py:obj:`.TensorStore` will\n   use the running event loop (as returned by\n   :py:obj:`asyncio.get_running_loop`) of the thread used for unpickling, if\n   there is one.\n\nTransaction support\n-------------------\n\nTransactional reads and writes are supported on virtual_chunked views.  A\ntransactional write simply serves to buffer the write in memory until it is\ncommitted.  Transactional reads will observe prior writes made using the same\ntransaction.  However, when the transaction commit is initiated, the\n:py:param:`.write_function` is called in exactly the same way as for a\nnon-transactional write, and if more than one chunk is affected, the commit will\nbe non-atomic.  If the transaction is atomic, it is an error to write to more\nthan one chunk in the same transaction.\n\nYou are also free to use transactional operations, e.g. operations on a\n:py:class:`.KvStore` or another :py:class:`.TensorStore`, within the\n:py:param:`.read_function` or :py:param:`.write_function`.\n\n- For read-write views, you should not attempt to use the same transaction\n  within the :py:param:`.read_function` or :py:param:`.write_function` that is\n  also used for read or write operations on the virtual view directly, because\n  both :py:param:`.write_function` and :py:param:`.read_function` may be called\n  after the commit starts, and any attempt to perform new operations using the\n  same transaction once it is already being committed will fail; instead, any\n  transactional operations performed within the :py:param:`.read_function` or\n  :py:param:`.write_function` should use a different transaction.\n\n- For read-only views, it is possible to use the same transaction within the\n  :py:param:`.read_function` as is also used for read operations on the virtual\n  view directly, though this may not be particularly useful.\n\nSpecifying a transaction directly when creating the virtual chunked view is no\ndifferent than binding the transaction to an existing virtual chunked view.\n\n\n",
        "type": "function"
    }
}